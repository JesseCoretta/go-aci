// Code generated from ACIParser.g4 by ANTLR 4.13.0. DO NOT EDIT.

package parser // ACIParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type ACIParser struct {
	*antlr.BaseParser
}

var ACIParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func aciparserParserInit() {
	staticData := &ACIParserParserStaticData
	staticData.LiteralNames = []string{
		"", "", "'\"'", "'['", "'('", "']'", "')'", "'.'", "':'", "'~'", "'='",
		"", "'>'", "'<'", "", "", "", "", "", "", "'#'", "", "", "", "", "",
		"", "','", "';'", "'*'", "'ldap:///'", "'parent'", "'version 3.0; acl '",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "'groupdn'", "'roledn'", "'userattr'", "'groupattr'",
		"'ssf'", "'dns'", "'ip'", "'authmethod'", "'timeofday'", "'dayofweek'",
		"'USERDN'", "'GROUPDN'", "'ROLEDN'", "'SELFDN'", "'LDAPURL'",
	}
	staticData.SymbolicNames = []string{
		"", "WHSP", "DQUOTE", "LBRAK", "LPAREN", "RBRAK", "RPAREN", "DOT", "COLON",
		"TILDE", "EQ", "NE", "GT", "LT", "APX", "GE", "LE", "EXA", "EXO", "EXD",
		"HASH", "SYMBOLIC_AND", "SYMBOLIC_OR", "FILTER_AND", "FILTER_OR", "FILTER_NOT",
		"FILTER_OPERATOR", "COMMA", "SEMI", "STAR", "LOCAL_LDAP_SCHEME", "INHERITANCE_PREFIX",
		"ANCHOR", "SUNDAY", "MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY",
		"SATURDAY", "ANONYMOUS", "SIMPLE", "SSL", "SASL", "TARGET", "TARGET_TO",
		"TARGET_FROM", "TARGET_SCOPE", "TARGET_ATTR", "TARGET_FILTER", "TARGET_ATTR_FILTERS",
		"TARGET_CONTROL", "TARGET_EXTENDED_OPERATION", "BIND_USER_DN", "BIND_GROUP_DN",
		"BIND_ROLE_DN", "BIND_USER_ATTR", "BIND_GROUP_ATTR", "BIND_SSF", "BIND_DNS",
		"BIND_IP", "BIND_AUTH_METHOD", "BIND_TIME_OF_DAY", "BIND_DAY_OF_WEEK",
		"BINDTYPE_USER_DN", "BINDTYPE_GROUP_DN", "BINDTYPE_ROLE_DN", "BINDTYPE_SELF_DN",
		"BINDTYPE_LDAP_URL", "BASE_OBJECT_SCOPE", "ONE_LEVEL_SCOPE", "ONE_LEVEL_TARGET_SCOPE",
		"SUB_TREE_SCOPE", "SUB_TREE_TARGET_SCOPE", "SUBORDINATE_TARGET_SCOPE",
		"ALLOW_ACCESS", "DENY_ACCESS", "SEARCH_PRIVILEGE", "READ_PRIVILEGE",
		"COMPARE_PRIVILEGE", "ADD_PRIVILEGE", "DELETE_PRIVILEGE", "SELFWRITE_PRIVILEGE",
		"PROXY_PRIVILEGE", "IMPORT_PRIVILEGE", "EXPORT_PRIVILEGE", "ALL_PRIVILEGES",
		"RDN_MACROS", "BOOLEAN_AND", "BOOLEAN_OR", "BOOLEAN_NOT", "WHITESPACE",
		"INT", "KEY_OR_VALUE",
	}
	staticData.RuleNames = []string{
		"parse", "instruction", "permissionBindRules", "permissionBindRule",
		"permission", "permissionDisposition", "accessPrivileges", "targetRules",
		"targetRule", "target", "targetTo", "targetFrom", "targetFilter", "targetAttrFilters",
		"targetScope", "targetAttributes", "targetControl", "targetExtendedOperation",
		"targetSearchScopes", "objectIdentifiers", "targetedAttributes", "objectIdentifier",
		"objectIdentifierArc", "targetAttrFiltersValue", "attributeFilters",
		"attributeFilterSet", "attributeFilterOperation", "attributeFilter",
		"bindRule", "bindRuleExprParen", "bindRuleExpr", "bindDayOfWeek", "doW",
		"bindAuthMethod", "authenticationMethods", "bindUserDN", "bindRoleDN",
		"bindGroupDN", "bindUserAttr", "bindGroupAttr", "bindSecurityStrengthFactor",
		"bindTimeOfDay", "bindIP", "bindDNS", "iPAddresses", "iPAddress", "iPv4Address",
		"iPv6Address", "fQDN", "distinguishedNames", "distinguishedName", "rDNMacros",
		"lDAPFilter", "lDAPFilterExpr", "aVAOrRDN", "inheritance", "inheritanceLevels",
		"attributeBindTypeOrValue", "bindTypes", "attributeTypeOrValue", "attributeComparisonOperator",
		"equalTo", "notEqualTo", "greaterThan", "lessThan", "greaterThanOrEqual",
		"lessThanOrEqual", "approximate", "extensibleRule", "extensibleRuleDNOID",
		"extensibleRuleDN", "extensibleRuleAttr", "oRDelimiter", "aNDDelimiter",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 93, 886, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2,
		63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 68,
		7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 7,
		73, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 159,
		8, 1, 10, 1, 12, 1, 162, 9, 1, 1, 1, 1, 1, 5, 1, 166, 8, 1, 10, 1, 12,
		1, 169, 9, 1, 1, 1, 1, 1, 3, 1, 173, 8, 1, 1, 1, 1, 1, 1, 2, 5, 2, 178,
		8, 2, 10, 2, 12, 2, 181, 9, 2, 1, 3, 1, 3, 1, 3, 3, 3, 186, 8, 3, 1, 3,
		1, 3, 3, 3, 190, 8, 3, 1, 4, 1, 4, 5, 4, 194, 8, 4, 10, 4, 12, 4, 197,
		9, 4, 1, 4, 1, 4, 5, 4, 201, 8, 4, 10, 4, 12, 4, 204, 9, 4, 1, 4, 1, 4,
		1, 4, 1, 4, 5, 4, 210, 8, 4, 10, 4, 12, 4, 213, 9, 4, 5, 4, 215, 8, 4,
		10, 4, 12, 4, 218, 9, 4, 1, 4, 5, 4, 221, 8, 4, 10, 4, 12, 4, 224, 9, 4,
		1, 4, 1, 4, 1, 5, 1, 5, 3, 5, 230, 8, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6,
		1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 242, 8, 6, 1, 7, 5, 7, 245, 8, 7, 10,
		7, 12, 7, 248, 9, 7, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1,
		8, 3, 8, 259, 8, 8, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 265, 8, 9, 1, 9, 1, 9,
		1, 9, 1, 10, 1, 10, 1, 10, 1, 10, 3, 10, 274, 8, 10, 1, 10, 1, 10, 1, 10,
		1, 10, 1, 10, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 285, 8, 11, 1, 11, 1,
		11, 1, 11, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 296, 8, 12,
		1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1,
		13, 1, 13, 1, 13, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14,
		1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 323, 8, 15, 1, 15, 1, 15, 1, 15, 1,
		16, 1, 16, 1, 16, 1, 16, 3, 16, 332, 8, 16, 1, 16, 1, 16, 1, 16, 1, 17,
		1, 17, 1, 17, 1, 17, 3, 17, 341, 8, 17, 1, 17, 1, 17, 1, 17, 1, 18, 1,
		18, 1, 18, 1, 18, 3, 18, 350, 8, 18, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19,
		5, 19, 357, 8, 19, 10, 19, 12, 19, 360, 9, 19, 1, 19, 1, 19, 1, 19, 1,
		19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 5, 19, 372, 8, 19, 10, 19,
		12, 19, 375, 9, 19, 3, 19, 377, 8, 19, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20,
		5, 20, 384, 8, 20, 10, 20, 12, 20, 387, 9, 20, 1, 20, 1, 20, 1, 20, 1,
		20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 5, 20, 399, 8, 20, 10, 20,
		12, 20, 402, 9, 20, 3, 20, 404, 8, 20, 1, 21, 1, 21, 1, 21, 4, 21, 409,
		8, 21, 11, 21, 12, 21, 410, 1, 22, 1, 22, 1, 23, 1, 23, 1, 23, 3, 23, 418,
		8, 23, 1, 24, 1, 24, 1, 24, 4, 24, 423, 8, 24, 11, 24, 12, 24, 424, 1,
		25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 5, 25, 433, 8, 25, 10, 25, 12, 25,
		436, 9, 25, 3, 25, 438, 8, 25, 1, 26, 1, 26, 3, 26, 442, 8, 26, 1, 27,
		1, 27, 1, 27, 1, 27, 1, 28, 1, 28, 1, 28, 1, 28, 5, 28, 452, 8, 28, 10,
		28, 12, 28, 455, 9, 28, 3, 28, 457, 8, 28, 1, 29, 1, 29, 1, 29, 1, 29,
		5, 29, 463, 8, 29, 10, 29, 12, 29, 466, 9, 29, 1, 29, 1, 29, 1, 29, 1,
		29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 3, 29, 477, 8, 29, 1, 30, 1, 30,
		1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1,
		30, 1, 30, 1, 30, 3, 30, 494, 8, 30, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31,
		1, 31, 1, 31, 3, 31, 503, 8, 31, 1, 31, 1, 31, 1, 31, 1, 31, 5, 31, 509,
		8, 31, 10, 31, 12, 31, 512, 9, 31, 1, 31, 1, 31, 3, 31, 516, 8, 31, 1,
		32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 525, 8, 32, 1, 33,
		1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 3, 33, 534, 8, 33, 1, 33, 1,
		33, 1, 33, 1, 33, 3, 33, 540, 8, 33, 1, 34, 1, 34, 1, 34, 1, 34, 3, 34,
		546, 8, 34, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 3, 35, 555,
		8, 35, 1, 35, 3, 35, 558, 8, 35, 1, 35, 1, 35, 3, 35, 562, 8, 35, 1, 36,
		1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 3, 36, 571, 8, 36, 1, 36, 1,
		36, 3, 36, 575, 8, 36, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37,
		3, 37, 584, 8, 37, 1, 37, 1, 37, 3, 37, 588, 8, 37, 1, 38, 1, 38, 1, 38,
		1, 38, 1, 38, 1, 38, 1, 38, 3, 38, 597, 8, 38, 1, 38, 1, 38, 1, 38, 3,
		38, 602, 8, 38, 1, 38, 1, 38, 3, 38, 606, 8, 38, 1, 39, 1, 39, 1, 39, 1,
		39, 1, 39, 1, 39, 1, 39, 3, 39, 615, 8, 39, 1, 39, 1, 39, 1, 39, 3, 39,
		620, 8, 39, 1, 39, 1, 39, 3, 39, 624, 8, 39, 1, 40, 1, 40, 1, 40, 1, 40,
		1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 3, 40, 637, 8, 40, 1,
		40, 1, 40, 1, 40, 1, 40, 3, 40, 643, 8, 40, 1, 41, 1, 41, 1, 41, 1, 41,
		1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 656, 8, 41, 1,
		41, 1, 41, 1, 41, 1, 41, 3, 41, 662, 8, 41, 1, 42, 1, 42, 1, 42, 1, 42,
		1, 42, 1, 42, 1, 42, 3, 42, 671, 8, 42, 1, 42, 1, 42, 1, 42, 1, 42, 3,
		42, 677, 8, 42, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43,
		686, 8, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 692, 8, 43, 1, 44, 1, 44,
		1, 44, 5, 44, 697, 8, 44, 10, 44, 12, 44, 700, 9, 44, 4, 44, 702, 8, 44,
		11, 44, 12, 44, 703, 1, 45, 1, 45, 3, 45, 708, 8, 45, 1, 46, 1, 46, 1,
		46, 5, 46, 713, 8, 46, 10, 46, 12, 46, 716, 9, 46, 1, 47, 1, 47, 1, 47,
		4, 47, 721, 8, 47, 11, 47, 12, 47, 722, 1, 47, 3, 47, 726, 8, 47, 1, 48,
		1, 48, 3, 48, 730, 8, 48, 1, 48, 1, 48, 1, 48, 3, 48, 735, 8, 48, 4, 48,
		737, 8, 48, 11, 48, 12, 48, 738, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 5,
		49, 746, 8, 49, 10, 49, 12, 49, 749, 9, 49, 1, 49, 1, 49, 1, 49, 1, 49,
		1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 5, 49, 761, 8, 49, 10, 49, 12,
		49, 764, 9, 49, 3, 49, 766, 8, 49, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3,
		50, 773, 8, 50, 5, 50, 775, 8, 50, 10, 50, 12, 50, 778, 9, 50, 1, 51, 1,
		51, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 5, 52, 787, 8, 52, 10, 52, 12, 52,
		790, 9, 52, 3, 52, 792, 8, 52, 1, 53, 1, 53, 3, 53, 796, 8, 53, 1, 53,
		1, 53, 1, 53, 4, 53, 801, 8, 53, 11, 53, 12, 53, 802, 1, 53, 1, 53, 1,
		53, 3, 53, 808, 8, 53, 1, 54, 1, 54, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55,
		1, 55, 1, 55, 1, 56, 1, 56, 1, 56, 1, 56, 5, 56, 823, 8, 56, 10, 56, 12,
		56, 826, 9, 56, 4, 56, 828, 8, 56, 11, 56, 12, 56, 829, 1, 56, 1, 56, 1,
		57, 1, 57, 1, 57, 1, 57, 3, 57, 838, 8, 57, 1, 58, 1, 58, 1, 58, 1, 58,
		1, 58, 3, 58, 845, 8, 58, 1, 59, 1, 59, 1, 60, 1, 60, 1, 60, 1, 60, 1,
		60, 1, 60, 1, 60, 1, 60, 1, 60, 3, 60, 858, 8, 60, 1, 61, 1, 61, 1, 62,
		1, 62, 1, 63, 1, 63, 1, 64, 1, 64, 1, 65, 1, 65, 1, 66, 1, 66, 1, 67, 1,
		67, 1, 68, 1, 68, 1, 69, 1, 69, 1, 70, 1, 70, 1, 71, 1, 71, 1, 72, 1, 72,
		1, 73, 1, 73, 1, 73, 10, 160, 167, 195, 202, 211, 222, 424, 703, 802, 829,
		0, 74, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34,
		36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70,
		72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104,
		106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134,
		136, 138, 140, 142, 144, 146, 0, 4, 1, 0, 27, 28, 1, 0, 88, 90, 2, 0, 29,
		29, 92, 92, 1, 0, 23, 25, 959, 0, 148, 1, 0, 0, 0, 2, 151, 1, 0, 0, 0,
		4, 179, 1, 0, 0, 0, 6, 182, 1, 0, 0, 0, 8, 191, 1, 0, 0, 0, 10, 229, 1,
		0, 0, 0, 12, 241, 1, 0, 0, 0, 14, 246, 1, 0, 0, 0, 16, 258, 1, 0, 0, 0,
		18, 260, 1, 0, 0, 0, 20, 269, 1, 0, 0, 0, 22, 280, 1, 0, 0, 0, 24, 291,
		1, 0, 0, 0, 26, 302, 1, 0, 0, 0, 28, 310, 1, 0, 0, 0, 30, 318, 1, 0, 0,
		0, 32, 327, 1, 0, 0, 0, 34, 336, 1, 0, 0, 0, 36, 349, 1, 0, 0, 0, 38, 376,
		1, 0, 0, 0, 40, 403, 1, 0, 0, 0, 42, 405, 1, 0, 0, 0, 44, 412, 1, 0, 0,
		0, 46, 417, 1, 0, 0, 0, 48, 419, 1, 0, 0, 0, 50, 426, 1, 0, 0, 0, 52, 441,
		1, 0, 0, 0, 54, 443, 1, 0, 0, 0, 56, 456, 1, 0, 0, 0, 58, 476, 1, 0, 0,
		0, 60, 493, 1, 0, 0, 0, 62, 515, 1, 0, 0, 0, 64, 524, 1, 0, 0, 0, 66, 539,
		1, 0, 0, 0, 68, 545, 1, 0, 0, 0, 70, 561, 1, 0, 0, 0, 72, 574, 1, 0, 0,
		0, 74, 587, 1, 0, 0, 0, 76, 605, 1, 0, 0, 0, 78, 623, 1, 0, 0, 0, 80, 642,
		1, 0, 0, 0, 82, 661, 1, 0, 0, 0, 84, 676, 1, 0, 0, 0, 86, 691, 1, 0, 0,
		0, 88, 701, 1, 0, 0, 0, 90, 707, 1, 0, 0, 0, 92, 709, 1, 0, 0, 0, 94, 717,
		1, 0, 0, 0, 96, 729, 1, 0, 0, 0, 98, 765, 1, 0, 0, 0, 100, 767, 1, 0, 0,
		0, 102, 779, 1, 0, 0, 0, 104, 791, 1, 0, 0, 0, 106, 807, 1, 0, 0, 0, 108,
		809, 1, 0, 0, 0, 110, 813, 1, 0, 0, 0, 112, 818, 1, 0, 0, 0, 114, 833,
		1, 0, 0, 0, 116, 844, 1, 0, 0, 0, 118, 846, 1, 0, 0, 0, 120, 857, 1, 0,
		0, 0, 122, 859, 1, 0, 0, 0, 124, 861, 1, 0, 0, 0, 126, 863, 1, 0, 0, 0,
		128, 865, 1, 0, 0, 0, 130, 867, 1, 0, 0, 0, 132, 869, 1, 0, 0, 0, 134,
		871, 1, 0, 0, 0, 136, 873, 1, 0, 0, 0, 138, 875, 1, 0, 0, 0, 140, 877,
		1, 0, 0, 0, 142, 879, 1, 0, 0, 0, 144, 881, 1, 0, 0, 0, 146, 883, 1, 0,
		0, 0, 148, 149, 3, 2, 1, 0, 149, 150, 5, 0, 0, 1, 150, 1, 1, 0, 0, 0, 151,
		152, 3, 14, 7, 0, 152, 153, 5, 4, 0, 0, 153, 154, 5, 32, 0, 0, 154, 155,
		5, 2, 0, 0, 155, 156, 3, 118, 59, 0, 156, 160, 5, 2, 0, 0, 157, 159, 5,
		1, 0, 0, 158, 157, 1, 0, 0, 0, 159, 162, 1, 0, 0, 0, 160, 161, 1, 0, 0,
		0, 160, 158, 1, 0, 0, 0, 161, 163, 1, 0, 0, 0, 162, 160, 1, 0, 0, 0, 163,
		167, 5, 28, 0, 0, 164, 166, 5, 1, 0, 0, 165, 164, 1, 0, 0, 0, 166, 169,
		1, 0, 0, 0, 167, 168, 1, 0, 0, 0, 167, 165, 1, 0, 0, 0, 168, 170, 1, 0,
		0, 0, 169, 167, 1, 0, 0, 0, 170, 172, 3, 4, 2, 0, 171, 173, 5, 1, 0, 0,
		172, 171, 1, 0, 0, 0, 172, 173, 1, 0, 0, 0, 173, 174, 1, 0, 0, 0, 174,
		175, 5, 6, 0, 0, 175, 3, 1, 0, 0, 0, 176, 178, 3, 6, 3, 0, 177, 176, 1,
		0, 0, 0, 178, 181, 1, 0, 0, 0, 179, 177, 1, 0, 0, 0, 179, 180, 1, 0, 0,
		0, 180, 5, 1, 0, 0, 0, 181, 179, 1, 0, 0, 0, 182, 183, 3, 8, 4, 0, 183,
		185, 3, 56, 28, 0, 184, 186, 5, 1, 0, 0, 185, 184, 1, 0, 0, 0, 185, 186,
		1, 0, 0, 0, 186, 187, 1, 0, 0, 0, 187, 189, 5, 28, 0, 0, 188, 190, 5, 1,
		0, 0, 189, 188, 1, 0, 0, 0, 189, 190, 1, 0, 0, 0, 190, 7, 1, 0, 0, 0, 191,
		195, 3, 10, 5, 0, 192, 194, 5, 1, 0, 0, 193, 192, 1, 0, 0, 0, 194, 197,
		1, 0, 0, 0, 195, 196, 1, 0, 0, 0, 195, 193, 1, 0, 0, 0, 196, 198, 1, 0,
		0, 0, 197, 195, 1, 0, 0, 0, 198, 202, 5, 4, 0, 0, 199, 201, 5, 1, 0, 0,
		200, 199, 1, 0, 0, 0, 201, 204, 1, 0, 0, 0, 202, 203, 1, 0, 0, 0, 202,
		200, 1, 0, 0, 0, 203, 205, 1, 0, 0, 0, 204, 202, 1, 0, 0, 0, 205, 216,
		3, 12, 6, 0, 206, 207, 5, 27, 0, 0, 207, 211, 3, 12, 6, 0, 208, 210, 5,
		1, 0, 0, 209, 208, 1, 0, 0, 0, 210, 213, 1, 0, 0, 0, 211, 212, 1, 0, 0,
		0, 211, 209, 1, 0, 0, 0, 212, 215, 1, 0, 0, 0, 213, 211, 1, 0, 0, 0, 214,
		206, 1, 0, 0, 0, 215, 218, 1, 0, 0, 0, 216, 214, 1, 0, 0, 0, 216, 217,
		1, 0, 0, 0, 217, 222, 1, 0, 0, 0, 218, 216, 1, 0, 0, 0, 219, 221, 5, 1,
		0, 0, 220, 219, 1, 0, 0, 0, 221, 224, 1, 0, 0, 0, 222, 223, 1, 0, 0, 0,
		222, 220, 1, 0, 0, 0, 223, 225, 1, 0, 0, 0, 224, 222, 1, 0, 0, 0, 225,
		226, 5, 6, 0, 0, 226, 9, 1, 0, 0, 0, 227, 230, 5, 75, 0, 0, 228, 230, 5,
		76, 0, 0, 229, 227, 1, 0, 0, 0, 229, 228, 1, 0, 0, 0, 230, 11, 1, 0, 0,
		0, 231, 242, 5, 77, 0, 0, 232, 242, 5, 78, 0, 0, 233, 242, 5, 79, 0, 0,
		234, 242, 5, 80, 0, 0, 235, 242, 5, 81, 0, 0, 236, 242, 5, 82, 0, 0, 237,
		242, 5, 83, 0, 0, 238, 242, 5, 84, 0, 0, 239, 242, 5, 85, 0, 0, 240, 242,
		5, 86, 0, 0, 241, 231, 1, 0, 0, 0, 241, 232, 1, 0, 0, 0, 241, 233, 1, 0,
		0, 0, 241, 234, 1, 0, 0, 0, 241, 235, 1, 0, 0, 0, 241, 236, 1, 0, 0, 0,
		241, 237, 1, 0, 0, 0, 241, 238, 1, 0, 0, 0, 241, 239, 1, 0, 0, 0, 241,
		240, 1, 0, 0, 0, 242, 13, 1, 0, 0, 0, 243, 245, 3, 16, 8, 0, 244, 243,
		1, 0, 0, 0, 245, 248, 1, 0, 0, 0, 246, 244, 1, 0, 0, 0, 246, 247, 1, 0,
		0, 0, 247, 15, 1, 0, 0, 0, 248, 246, 1, 0, 0, 0, 249, 259, 3, 32, 16, 0,
		250, 259, 3, 34, 17, 0, 251, 259, 3, 24, 12, 0, 252, 259, 3, 26, 13, 0,
		253, 259, 3, 28, 14, 0, 254, 259, 3, 30, 15, 0, 255, 259, 3, 18, 9, 0,
		256, 259, 3, 20, 10, 0, 257, 259, 3, 22, 11, 0, 258, 249, 1, 0, 0, 0, 258,
		250, 1, 0, 0, 0, 258, 251, 1, 0, 0, 0, 258, 252, 1, 0, 0, 0, 258, 253,
		1, 0, 0, 0, 258, 254, 1, 0, 0, 0, 258, 255, 1, 0, 0, 0, 258, 256, 1, 0,
		0, 0, 258, 257, 1, 0, 0, 0, 259, 17, 1, 0, 0, 0, 260, 261, 5, 4, 0, 0,
		261, 264, 5, 44, 0, 0, 262, 265, 3, 122, 61, 0, 263, 265, 3, 124, 62, 0,
		264, 262, 1, 0, 0, 0, 264, 263, 1, 0, 0, 0, 265, 266, 1, 0, 0, 0, 266,
		267, 3, 98, 49, 0, 267, 268, 5, 6, 0, 0, 268, 19, 1, 0, 0, 0, 269, 270,
		5, 4, 0, 0, 270, 273, 5, 45, 0, 0, 271, 274, 3, 122, 61, 0, 272, 274, 3,
		124, 62, 0, 273, 271, 1, 0, 0, 0, 273, 272, 1, 0, 0, 0, 274, 275, 1, 0,
		0, 0, 275, 276, 5, 2, 0, 0, 276, 277, 3, 100, 50, 0, 277, 278, 5, 2, 0,
		0, 278, 279, 5, 6, 0, 0, 279, 21, 1, 0, 0, 0, 280, 281, 5, 4, 0, 0, 281,
		284, 5, 46, 0, 0, 282, 285, 3, 122, 61, 0, 283, 285, 3, 124, 62, 0, 284,
		282, 1, 0, 0, 0, 284, 283, 1, 0, 0, 0, 285, 286, 1, 0, 0, 0, 286, 287,
		5, 2, 0, 0, 287, 288, 3, 100, 50, 0, 288, 289, 5, 2, 0, 0, 289, 290, 5,
		6, 0, 0, 290, 23, 1, 0, 0, 0, 291, 292, 5, 4, 0, 0, 292, 295, 5, 49, 0,
		0, 293, 296, 3, 122, 61, 0, 294, 296, 3, 124, 62, 0, 295, 293, 1, 0, 0,
		0, 295, 294, 1, 0, 0, 0, 296, 297, 1, 0, 0, 0, 297, 298, 5, 2, 0, 0, 298,
		299, 3, 104, 52, 0, 299, 300, 5, 2, 0, 0, 300, 301, 5, 6, 0, 0, 301, 25,
		1, 0, 0, 0, 302, 303, 5, 4, 0, 0, 303, 304, 5, 50, 0, 0, 304, 305, 3, 122,
		61, 0, 305, 306, 5, 2, 0, 0, 306, 307, 3, 46, 23, 0, 307, 308, 5, 2, 0,
		0, 308, 309, 5, 6, 0, 0, 309, 27, 1, 0, 0, 0, 310, 311, 5, 4, 0, 0, 311,
		312, 5, 47, 0, 0, 312, 313, 3, 122, 61, 0, 313, 314, 5, 2, 0, 0, 314, 315,
		3, 36, 18, 0, 315, 316, 5, 2, 0, 0, 316, 317, 5, 6, 0, 0, 317, 29, 1, 0,
		0, 0, 318, 319, 5, 4, 0, 0, 319, 322, 5, 48, 0, 0, 320, 323, 3, 122, 61,
		0, 321, 323, 3, 124, 62, 0, 322, 320, 1, 0, 0, 0, 322, 321, 1, 0, 0, 0,
		323, 324, 1, 0, 0, 0, 324, 325, 3, 40, 20, 0, 325, 326, 5, 6, 0, 0, 326,
		31, 1, 0, 0, 0, 327, 328, 5, 4, 0, 0, 328, 331, 5, 51, 0, 0, 329, 332,
		3, 122, 61, 0, 330, 332, 3, 124, 62, 0, 331, 329, 1, 0, 0, 0, 331, 330,
		1, 0, 0, 0, 332, 333, 1, 0, 0, 0, 333, 334, 3, 38, 19, 0, 334, 335, 5,
		6, 0, 0, 335, 33, 1, 0, 0, 0, 336, 337, 5, 4, 0, 0, 337, 340, 5, 52, 0,
		0, 338, 341, 3, 122, 61, 0, 339, 341, 3, 124, 62, 0, 340, 338, 1, 0, 0,
		0, 340, 339, 1, 0, 0, 0, 341, 342, 1, 0, 0, 0, 342, 343, 3, 38, 19, 0,
		343, 344, 5, 6, 0, 0, 344, 35, 1, 0, 0, 0, 345, 350, 5, 69, 0, 0, 346,
		350, 5, 71, 0, 0, 347, 350, 5, 73, 0, 0, 348, 350, 5, 74, 0, 0, 349, 345,
		1, 0, 0, 0, 349, 346, 1, 0, 0, 0, 349, 347, 1, 0, 0, 0, 349, 348, 1, 0,
		0, 0, 350, 37, 1, 0, 0, 0, 351, 352, 5, 2, 0, 0, 352, 358, 3, 42, 21, 0,
		353, 354, 3, 144, 72, 0, 354, 355, 3, 42, 21, 0, 355, 357, 1, 0, 0, 0,
		356, 353, 1, 0, 0, 0, 357, 360, 1, 0, 0, 0, 358, 356, 1, 0, 0, 0, 358,
		359, 1, 0, 0, 0, 359, 361, 1, 0, 0, 0, 360, 358, 1, 0, 0, 0, 361, 362,
		5, 2, 0, 0, 362, 377, 1, 0, 0, 0, 363, 364, 5, 2, 0, 0, 364, 365, 3, 42,
		21, 0, 365, 373, 5, 2, 0, 0, 366, 367, 3, 144, 72, 0, 367, 368, 5, 2, 0,
		0, 368, 369, 3, 42, 21, 0, 369, 370, 5, 2, 0, 0, 370, 372, 1, 0, 0, 0,
		371, 366, 1, 0, 0, 0, 372, 375, 1, 0, 0, 0, 373, 371, 1, 0, 0, 0, 373,
		374, 1, 0, 0, 0, 374, 377, 1, 0, 0, 0, 375, 373, 1, 0, 0, 0, 376, 351,
		1, 0, 0, 0, 376, 363, 1, 0, 0, 0, 377, 39, 1, 0, 0, 0, 378, 379, 5, 2,
		0, 0, 379, 385, 3, 118, 59, 0, 380, 381, 3, 144, 72, 0, 381, 382, 3, 118,
		59, 0, 382, 384, 1, 0, 0, 0, 383, 380, 1, 0, 0, 0, 384, 387, 1, 0, 0, 0,
		385, 383, 1, 0, 0, 0, 385, 386, 1, 0, 0, 0, 386, 388, 1, 0, 0, 0, 387,
		385, 1, 0, 0, 0, 388, 389, 5, 2, 0, 0, 389, 404, 1, 0, 0, 0, 390, 391,
		5, 2, 0, 0, 391, 392, 3, 118, 59, 0, 392, 400, 5, 2, 0, 0, 393, 394, 3,
		144, 72, 0, 394, 395, 5, 2, 0, 0, 395, 396, 3, 118, 59, 0, 396, 397, 5,
		2, 0, 0, 397, 399, 1, 0, 0, 0, 398, 393, 1, 0, 0, 0, 399, 402, 1, 0, 0,
		0, 400, 398, 1, 0, 0, 0, 400, 401, 1, 0, 0, 0, 401, 404, 1, 0, 0, 0, 402,
		400, 1, 0, 0, 0, 403, 378, 1, 0, 0, 0, 403, 390, 1, 0, 0, 0, 404, 41, 1,
		0, 0, 0, 405, 408, 3, 44, 22, 0, 406, 407, 5, 7, 0, 0, 407, 409, 3, 44,
		22, 0, 408, 406, 1, 0, 0, 0, 409, 410, 1, 0, 0, 0, 410, 408, 1, 0, 0, 0,
		410, 411, 1, 0, 0, 0, 411, 43, 1, 0, 0, 0, 412, 413, 5, 92, 0, 0, 413,
		45, 1, 0, 0, 0, 414, 418, 3, 48, 24, 0, 415, 418, 3, 50, 25, 0, 416, 418,
		3, 54, 27, 0, 417, 414, 1, 0, 0, 0, 417, 415, 1, 0, 0, 0, 417, 416, 1,
		0, 0, 0, 418, 47, 1, 0, 0, 0, 419, 422, 3, 50, 25, 0, 420, 421, 7, 0, 0,
		0, 421, 423, 3, 50, 25, 0, 422, 420, 1, 0, 0, 0, 423, 424, 1, 0, 0, 0,
		424, 425, 1, 0, 0, 0, 424, 422, 1, 0, 0, 0, 425, 49, 1, 0, 0, 0, 426, 427,
		3, 52, 26, 0, 427, 437, 3, 122, 61, 0, 428, 434, 3, 54, 27, 0, 429, 430,
		3, 146, 73, 0, 430, 431, 3, 54, 27, 0, 431, 433, 1, 0, 0, 0, 432, 429,
		1, 0, 0, 0, 433, 436, 1, 0, 0, 0, 434, 432, 1, 0, 0, 0, 434, 435, 1, 0,
		0, 0, 435, 438, 1, 0, 0, 0, 436, 434, 1, 0, 0, 0, 437, 428, 1, 0, 0, 0,
		437, 438, 1, 0, 0, 0, 438, 51, 1, 0, 0, 0, 439, 442, 5, 80, 0, 0, 440,
		442, 5, 81, 0, 0, 441, 439, 1, 0, 0, 0, 441, 440, 1, 0, 0, 0, 442, 53,
		1, 0, 0, 0, 443, 444, 3, 118, 59, 0, 444, 445, 5, 8, 0, 0, 445, 446, 3,
		104, 52, 0, 446, 55, 1, 0, 0, 0, 447, 457, 3, 60, 30, 0, 448, 453, 3, 58,
		29, 0, 449, 450, 7, 1, 0, 0, 450, 452, 3, 58, 29, 0, 451, 449, 1, 0, 0,
		0, 452, 455, 1, 0, 0, 0, 453, 451, 1, 0, 0, 0, 453, 454, 1, 0, 0, 0, 454,
		457, 1, 0, 0, 0, 455, 453, 1, 0, 0, 0, 456, 447, 1, 0, 0, 0, 456, 448,
		1, 0, 0, 0, 457, 57, 1, 0, 0, 0, 458, 459, 5, 4, 0, 0, 459, 464, 3, 60,
		30, 0, 460, 461, 7, 1, 0, 0, 461, 463, 3, 60, 30, 0, 462, 460, 1, 0, 0,
		0, 463, 466, 1, 0, 0, 0, 464, 462, 1, 0, 0, 0, 464, 465, 1, 0, 0, 0, 465,
		467, 1, 0, 0, 0, 466, 464, 1, 0, 0, 0, 467, 468, 5, 6, 0, 0, 468, 477,
		1, 0, 0, 0, 469, 470, 5, 90, 0, 0, 470, 477, 3, 60, 30, 0, 471, 472, 5,
		4, 0, 0, 472, 473, 3, 60, 30, 0, 473, 474, 5, 6, 0, 0, 474, 477, 1, 0,
		0, 0, 475, 477, 3, 60, 30, 0, 476, 458, 1, 0, 0, 0, 476, 469, 1, 0, 0,
		0, 476, 471, 1, 0, 0, 0, 476, 475, 1, 0, 0, 0, 477, 59, 1, 0, 0, 0, 478,
		479, 5, 4, 0, 0, 479, 480, 3, 60, 30, 0, 480, 481, 5, 6, 0, 0, 481, 494,
		1, 0, 0, 0, 482, 494, 3, 70, 35, 0, 483, 494, 3, 76, 38, 0, 484, 494, 3,
		74, 37, 0, 485, 494, 3, 78, 39, 0, 486, 494, 3, 72, 36, 0, 487, 494, 3,
		86, 43, 0, 488, 494, 3, 84, 42, 0, 489, 494, 3, 82, 41, 0, 490, 494, 3,
		62, 31, 0, 491, 494, 3, 80, 40, 0, 492, 494, 3, 66, 33, 0, 493, 478, 1,
		0, 0, 0, 493, 482, 1, 0, 0, 0, 493, 483, 1, 0, 0, 0, 493, 484, 1, 0, 0,
		0, 493, 485, 1, 0, 0, 0, 493, 486, 1, 0, 0, 0, 493, 487, 1, 0, 0, 0, 493,
		488, 1, 0, 0, 0, 493, 489, 1, 0, 0, 0, 493, 490, 1, 0, 0, 0, 493, 491,
		1, 0, 0, 0, 493, 492, 1, 0, 0, 0, 494, 61, 1, 0, 0, 0, 495, 496, 5, 4,
		0, 0, 496, 497, 3, 62, 31, 0, 497, 498, 5, 6, 0, 0, 498, 516, 1, 0, 0,
		0, 499, 502, 5, 63, 0, 0, 500, 503, 3, 122, 61, 0, 501, 503, 3, 124, 62,
		0, 502, 500, 1, 0, 0, 0, 502, 501, 1, 0, 0, 0, 503, 504, 1, 0, 0, 0, 504,
		505, 5, 2, 0, 0, 505, 510, 3, 64, 32, 0, 506, 507, 5, 27, 0, 0, 507, 509,
		3, 64, 32, 0, 508, 506, 1, 0, 0, 0, 509, 512, 1, 0, 0, 0, 510, 508, 1,
		0, 0, 0, 510, 511, 1, 0, 0, 0, 511, 513, 1, 0, 0, 0, 512, 510, 1, 0, 0,
		0, 513, 514, 5, 2, 0, 0, 514, 516, 1, 0, 0, 0, 515, 495, 1, 0, 0, 0, 515,
		499, 1, 0, 0, 0, 516, 63, 1, 0, 0, 0, 517, 525, 5, 33, 0, 0, 518, 525,
		5, 34, 0, 0, 519, 525, 5, 35, 0, 0, 520, 525, 5, 36, 0, 0, 521, 525, 5,
		37, 0, 0, 522, 525, 5, 38, 0, 0, 523, 525, 5, 39, 0, 0, 524, 517, 1, 0,
		0, 0, 524, 518, 1, 0, 0, 0, 524, 519, 1, 0, 0, 0, 524, 520, 1, 0, 0, 0,
		524, 521, 1, 0, 0, 0, 524, 522, 1, 0, 0, 0, 524, 523, 1, 0, 0, 0, 525,
		65, 1, 0, 0, 0, 526, 527, 5, 4, 0, 0, 527, 528, 3, 66, 33, 0, 528, 529,
		5, 6, 0, 0, 529, 540, 1, 0, 0, 0, 530, 533, 5, 61, 0, 0, 531, 534, 3, 122,
		61, 0, 532, 534, 3, 124, 62, 0, 533, 531, 1, 0, 0, 0, 533, 532, 1, 0, 0,
		0, 534, 535, 1, 0, 0, 0, 535, 536, 5, 2, 0, 0, 536, 537, 3, 68, 34, 0,
		537, 538, 5, 2, 0, 0, 538, 540, 1, 0, 0, 0, 539, 526, 1, 0, 0, 0, 539,
		530, 1, 0, 0, 0, 540, 67, 1, 0, 0, 0, 541, 546, 5, 40, 0, 0, 542, 546,
		5, 41, 0, 0, 543, 546, 5, 42, 0, 0, 544, 546, 5, 43, 0, 0, 545, 541, 1,
		0, 0, 0, 545, 542, 1, 0, 0, 0, 545, 543, 1, 0, 0, 0, 545, 544, 1, 0, 0,
		0, 546, 69, 1, 0, 0, 0, 547, 548, 5, 4, 0, 0, 548, 549, 3, 70, 35, 0, 549,
		550, 5, 6, 0, 0, 550, 562, 1, 0, 0, 0, 551, 554, 5, 53, 0, 0, 552, 555,
		3, 122, 61, 0, 553, 555, 3, 124, 62, 0, 554, 552, 1, 0, 0, 0, 554, 553,
		1, 0, 0, 0, 555, 557, 1, 0, 0, 0, 556, 558, 5, 1, 0, 0, 557, 556, 1, 0,
		0, 0, 557, 558, 1, 0, 0, 0, 558, 559, 1, 0, 0, 0, 559, 560, 3, 98, 49,
		0, 560, 562, 1, 0, 0, 0, 561, 547, 1, 0, 0, 0, 561, 551, 1, 0, 0, 0, 562,
		71, 1, 0, 0, 0, 563, 564, 5, 4, 0, 0, 564, 565, 3, 72, 36, 0, 565, 566,
		5, 6, 0, 0, 566, 575, 1, 0, 0, 0, 567, 570, 5, 55, 0, 0, 568, 571, 3, 122,
		61, 0, 569, 571, 3, 124, 62, 0, 570, 568, 1, 0, 0, 0, 570, 569, 1, 0, 0,
		0, 571, 572, 1, 0, 0, 0, 572, 573, 3, 98, 49, 0, 573, 575, 1, 0, 0, 0,
		574, 563, 1, 0, 0, 0, 574, 567, 1, 0, 0, 0, 575, 73, 1, 0, 0, 0, 576, 577,
		5, 4, 0, 0, 577, 578, 3, 74, 37, 0, 578, 579, 5, 6, 0, 0, 579, 588, 1,
		0, 0, 0, 580, 583, 5, 54, 0, 0, 581, 584, 3, 122, 61, 0, 582, 584, 3, 124,
		62, 0, 583, 581, 1, 0, 0, 0, 583, 582, 1, 0, 0, 0, 584, 585, 1, 0, 0, 0,
		585, 586, 3, 98, 49, 0, 586, 588, 1, 0, 0, 0, 587, 576, 1, 0, 0, 0, 587,
		580, 1, 0, 0, 0, 588, 75, 1, 0, 0, 0, 589, 590, 5, 4, 0, 0, 590, 591, 3,
		76, 38, 0, 591, 592, 5, 6, 0, 0, 592, 606, 1, 0, 0, 0, 593, 596, 5, 56,
		0, 0, 594, 597, 3, 122, 61, 0, 595, 597, 3, 124, 62, 0, 596, 594, 1, 0,
		0, 0, 596, 595, 1, 0, 0, 0, 597, 598, 1, 0, 0, 0, 598, 601, 5, 2, 0, 0,
		599, 602, 3, 114, 57, 0, 600, 602, 3, 110, 55, 0, 601, 599, 1, 0, 0, 0,
		601, 600, 1, 0, 0, 0, 602, 603, 1, 0, 0, 0, 603, 604, 5, 2, 0, 0, 604,
		606, 1, 0, 0, 0, 605, 589, 1, 0, 0, 0, 605, 593, 1, 0, 0, 0, 606, 77, 1,
		0, 0, 0, 607, 608, 5, 4, 0, 0, 608, 609, 3, 78, 39, 0, 609, 610, 5, 6,
		0, 0, 610, 624, 1, 0, 0, 0, 611, 614, 5, 57, 0, 0, 612, 615, 3, 122, 61,
		0, 613, 615, 3, 124, 62, 0, 614, 612, 1, 0, 0, 0, 614, 613, 1, 0, 0, 0,
		615, 616, 1, 0, 0, 0, 616, 619, 5, 2, 0, 0, 617, 620, 3, 114, 57, 0, 618,
		620, 3, 110, 55, 0, 619, 617, 1, 0, 0, 0, 619, 618, 1, 0, 0, 0, 620, 621,
		1, 0, 0, 0, 621, 622, 5, 2, 0, 0, 622, 624, 1, 0, 0, 0, 623, 607, 1, 0,
		0, 0, 623, 611, 1, 0, 0, 0, 624, 79, 1, 0, 0, 0, 625, 626, 5, 4, 0, 0,
		626, 627, 3, 80, 40, 0, 627, 628, 5, 6, 0, 0, 628, 643, 1, 0, 0, 0, 629,
		636, 5, 58, 0, 0, 630, 637, 3, 122, 61, 0, 631, 637, 3, 124, 62, 0, 632,
		637, 3, 126, 63, 0, 633, 637, 3, 130, 65, 0, 634, 637, 3, 128, 64, 0, 635,
		637, 3, 132, 66, 0, 636, 630, 1, 0, 0, 0, 636, 631, 1, 0, 0, 0, 636, 632,
		1, 0, 0, 0, 636, 633, 1, 0, 0, 0, 636, 634, 1, 0, 0, 0, 636, 635, 1, 0,
		0, 0, 637, 638, 1, 0, 0, 0, 638, 639, 5, 2, 0, 0, 639, 640, 5, 92, 0, 0,
		640, 641, 5, 2, 0, 0, 641, 643, 1, 0, 0, 0, 642, 625, 1, 0, 0, 0, 642,
		629, 1, 0, 0, 0, 643, 81, 1, 0, 0, 0, 644, 645, 5, 4, 0, 0, 645, 646, 3,
		82, 41, 0, 646, 647, 5, 6, 0, 0, 647, 662, 1, 0, 0, 0, 648, 655, 5, 62,
		0, 0, 649, 656, 3, 122, 61, 0, 650, 656, 3, 124, 62, 0, 651, 656, 3, 126,
		63, 0, 652, 656, 3, 130, 65, 0, 653, 656, 3, 128, 64, 0, 654, 656, 3, 132,
		66, 0, 655, 649, 1, 0, 0, 0, 655, 650, 1, 0, 0, 0, 655, 651, 1, 0, 0, 0,
		655, 652, 1, 0, 0, 0, 655, 653, 1, 0, 0, 0, 655, 654, 1, 0, 0, 0, 656,
		657, 1, 0, 0, 0, 657, 658, 5, 2, 0, 0, 658, 659, 5, 92, 0, 0, 659, 660,
		5, 2, 0, 0, 660, 662, 1, 0, 0, 0, 661, 644, 1, 0, 0, 0, 661, 648, 1, 0,
		0, 0, 662, 83, 1, 0, 0, 0, 663, 664, 5, 4, 0, 0, 664, 665, 3, 84, 42, 0,
		665, 666, 5, 6, 0, 0, 666, 677, 1, 0, 0, 0, 667, 670, 5, 60, 0, 0, 668,
		671, 3, 122, 61, 0, 669, 671, 3, 124, 62, 0, 670, 668, 1, 0, 0, 0, 670,
		669, 1, 0, 0, 0, 671, 672, 1, 0, 0, 0, 672, 673, 5, 2, 0, 0, 673, 674,
		3, 88, 44, 0, 674, 675, 5, 2, 0, 0, 675, 677, 1, 0, 0, 0, 676, 663, 1,
		0, 0, 0, 676, 667, 1, 0, 0, 0, 677, 85, 1, 0, 0, 0, 678, 679, 5, 4, 0,
		0, 679, 680, 3, 86, 43, 0, 680, 681, 5, 6, 0, 0, 681, 692, 1, 0, 0, 0,
		682, 685, 5, 59, 0, 0, 683, 686, 3, 122, 61, 0, 684, 686, 3, 124, 62, 0,
		685, 683, 1, 0, 0, 0, 685, 684, 1, 0, 0, 0, 686, 687, 1, 0, 0, 0, 687,
		688, 5, 2, 0, 0, 688, 689, 3, 96, 48, 0, 689, 690, 5, 2, 0, 0, 690, 692,
		1, 0, 0, 0, 691, 678, 1, 0, 0, 0, 691, 682, 1, 0, 0, 0, 692, 87, 1, 0,
		0, 0, 693, 698, 3, 90, 45, 0, 694, 695, 5, 27, 0, 0, 695, 697, 3, 90, 45,
		0, 696, 694, 1, 0, 0, 0, 697, 700, 1, 0, 0, 0, 698, 696, 1, 0, 0, 0, 698,
		699, 1, 0, 0, 0, 699, 702, 1, 0, 0, 0, 700, 698, 1, 0, 0, 0, 701, 693,
		1, 0, 0, 0, 702, 703, 1, 0, 0, 0, 703, 704, 1, 0, 0, 0, 703, 701, 1, 0,
		0, 0, 704, 89, 1, 0, 0, 0, 705, 708, 3, 92, 46, 0, 706, 708, 3, 94, 47,
		0, 707, 705, 1, 0, 0, 0, 707, 706, 1, 0, 0, 0, 708, 91, 1, 0, 0, 0, 709,
		710, 5, 92, 0, 0, 710, 714, 5, 7, 0, 0, 711, 713, 7, 2, 0, 0, 712, 711,
		1, 0, 0, 0, 713, 716, 1, 0, 0, 0, 714, 712, 1, 0, 0, 0, 714, 715, 1, 0,
		0, 0, 715, 93, 1, 0, 0, 0, 716, 714, 1, 0, 0, 0, 717, 720, 3, 118, 59,
		0, 718, 719, 5, 8, 0, 0, 719, 721, 3, 118, 59, 0, 720, 718, 1, 0, 0, 0,
		721, 722, 1, 0, 0, 0, 722, 720, 1, 0, 0, 0, 722, 723, 1, 0, 0, 0, 723,
		725, 1, 0, 0, 0, 724, 726, 5, 8, 0, 0, 725, 724, 1, 0, 0, 0, 725, 726,
		1, 0, 0, 0, 726, 95, 1, 0, 0, 0, 727, 730, 3, 118, 59, 0, 728, 730, 5,
		29, 0, 0, 729, 727, 1, 0, 0, 0, 729, 728, 1, 0, 0, 0, 730, 736, 1, 0, 0,
		0, 731, 734, 5, 7, 0, 0, 732, 735, 3, 118, 59, 0, 733, 735, 5, 29, 0, 0,
		734, 732, 1, 0, 0, 0, 734, 733, 1, 0, 0, 0, 735, 737, 1, 0, 0, 0, 736,
		731, 1, 0, 0, 0, 737, 738, 1, 0, 0, 0, 738, 736, 1, 0, 0, 0, 738, 739,
		1, 0, 0, 0, 739, 97, 1, 0, 0, 0, 740, 741, 5, 2, 0, 0, 741, 747, 3, 100,
		50, 0, 742, 743, 3, 144, 72, 0, 743, 744, 3, 100, 50, 0, 744, 746, 1, 0,
		0, 0, 745, 742, 1, 0, 0, 0, 746, 749, 1, 0, 0, 0, 747, 745, 1, 0, 0, 0,
		747, 748, 1, 0, 0, 0, 748, 750, 1, 0, 0, 0, 749, 747, 1, 0, 0, 0, 750,
		751, 5, 2, 0, 0, 751, 766, 1, 0, 0, 0, 752, 753, 5, 2, 0, 0, 753, 754,
		3, 100, 50, 0, 754, 762, 5, 2, 0, 0, 755, 756, 3, 144, 72, 0, 756, 757,
		5, 2, 0, 0, 757, 758, 3, 100, 50, 0, 758, 759, 5, 2, 0, 0, 759, 761, 1,
		0, 0, 0, 760, 755, 1, 0, 0, 0, 761, 764, 1, 0, 0, 0, 762, 760, 1, 0, 0,
		0, 762, 763, 1, 0, 0, 0, 763, 766, 1, 0, 0, 0, 764, 762, 1, 0, 0, 0, 765,
		740, 1, 0, 0, 0, 765, 752, 1, 0, 0, 0, 766, 99, 1, 0, 0, 0, 767, 768, 5,
		30, 0, 0, 768, 776, 3, 108, 54, 0, 769, 772, 5, 27, 0, 0, 770, 773, 3,
		108, 54, 0, 771, 773, 3, 102, 51, 0, 772, 770, 1, 0, 0, 0, 772, 771, 1,
		0, 0, 0, 773, 775, 1, 0, 0, 0, 774, 769, 1, 0, 0, 0, 775, 778, 1, 0, 0,
		0, 776, 774, 1, 0, 0, 0, 776, 777, 1, 0, 0, 0, 777, 101, 1, 0, 0, 0, 778,
		776, 1, 0, 0, 0, 779, 780, 5, 87, 0, 0, 780, 103, 1, 0, 0, 0, 781, 782,
		5, 4, 0, 0, 782, 783, 3, 106, 53, 0, 783, 784, 5, 6, 0, 0, 784, 792, 1,
		0, 0, 0, 785, 787, 3, 106, 53, 0, 786, 785, 1, 0, 0, 0, 787, 790, 1, 0,
		0, 0, 788, 786, 1, 0, 0, 0, 788, 789, 1, 0, 0, 0, 789, 792, 1, 0, 0, 0,
		790, 788, 1, 0, 0, 0, 791, 781, 1, 0, 0, 0, 791, 788, 1, 0, 0, 0, 792,
		105, 1, 0, 0, 0, 793, 795, 5, 4, 0, 0, 794, 796, 7, 3, 0, 0, 795, 794,
		1, 0, 0, 0, 795, 796, 1, 0, 0, 0, 796, 797, 1, 0, 0, 0, 797, 798, 3, 106,
		53, 0, 798, 799, 5, 6, 0, 0, 799, 801, 1, 0, 0, 0, 800, 793, 1, 0, 0, 0,
		801, 802, 1, 0, 0, 0, 802, 803, 1, 0, 0, 0, 802, 800, 1, 0, 0, 0, 803,
		808, 1, 0, 0, 0, 804, 805, 5, 25, 0, 0, 805, 808, 3, 106, 53, 0, 806, 808,
		3, 108, 54, 0, 807, 800, 1, 0, 0, 0, 807, 804, 1, 0, 0, 0, 807, 806, 1,
		0, 0, 0, 808, 107, 1, 0, 0, 0, 809, 810, 3, 118, 59, 0, 810, 811, 3, 120,
		60, 0, 811, 812, 3, 118, 59, 0, 812, 109, 1, 0, 0, 0, 813, 814, 5, 31,
		0, 0, 814, 815, 3, 112, 56, 0, 815, 816, 5, 7, 0, 0, 816, 817, 3, 114,
		57, 0, 817, 111, 1, 0, 0, 0, 818, 827, 5, 3, 0, 0, 819, 824, 5, 92, 0,
		0, 820, 821, 5, 27, 0, 0, 821, 823, 5, 92, 0, 0, 822, 820, 1, 0, 0, 0,
		823, 826, 1, 0, 0, 0, 824, 822, 1, 0, 0, 0, 824, 825, 1, 0, 0, 0, 825,
		828, 1, 0, 0, 0, 826, 824, 1, 0, 0, 0, 827, 819, 1, 0, 0, 0, 828, 829,
		1, 0, 0, 0, 829, 830, 1, 0, 0, 0, 829, 827, 1, 0, 0, 0, 830, 831, 1, 0,
		0, 0, 831, 832, 5, 5, 0, 0, 832, 113, 1, 0, 0, 0, 833, 834, 3, 118, 59,
		0, 834, 837, 5, 20, 0, 0, 835, 838, 3, 116, 58, 0, 836, 838, 3, 118, 59,
		0, 837, 835, 1, 0, 0, 0, 837, 836, 1, 0, 0, 0, 838, 115, 1, 0, 0, 0, 839,
		845, 5, 64, 0, 0, 840, 845, 5, 65, 0, 0, 841, 845, 5, 66, 0, 0, 842, 845,
		5, 67, 0, 0, 843, 845, 5, 68, 0, 0, 844, 839, 1, 0, 0, 0, 844, 840, 1,
		0, 0, 0, 844, 841, 1, 0, 0, 0, 844, 842, 1, 0, 0, 0, 844, 843, 1, 0, 0,
		0, 845, 117, 1, 0, 0, 0, 846, 847, 5, 93, 0, 0, 847, 119, 1, 0, 0, 0, 848,
		858, 3, 122, 61, 0, 849, 858, 3, 124, 62, 0, 850, 858, 3, 130, 65, 0, 851,
		858, 3, 132, 66, 0, 852, 858, 3, 134, 67, 0, 853, 858, 3, 136, 68, 0, 854,
		858, 3, 140, 70, 0, 855, 858, 3, 142, 71, 0, 856, 858, 3, 138, 69, 0, 857,
		848, 1, 0, 0, 0, 857, 849, 1, 0, 0, 0, 857, 850, 1, 0, 0, 0, 857, 851,
		1, 0, 0, 0, 857, 852, 1, 0, 0, 0, 857, 853, 1, 0, 0, 0, 857, 854, 1, 0,
		0, 0, 857, 855, 1, 0, 0, 0, 857, 856, 1, 0, 0, 0, 858, 121, 1, 0, 0, 0,
		859, 860, 5, 10, 0, 0, 860, 123, 1, 0, 0, 0, 861, 862, 5, 11, 0, 0, 862,
		125, 1, 0, 0, 0, 863, 864, 5, 12, 0, 0, 864, 127, 1, 0, 0, 0, 865, 866,
		5, 13, 0, 0, 866, 129, 1, 0, 0, 0, 867, 868, 5, 15, 0, 0, 868, 131, 1,
		0, 0, 0, 869, 870, 5, 16, 0, 0, 870, 133, 1, 0, 0, 0, 871, 872, 5, 14,
		0, 0, 872, 135, 1, 0, 0, 0, 873, 874, 5, 8, 0, 0, 874, 137, 1, 0, 0, 0,
		875, 876, 5, 18, 0, 0, 876, 139, 1, 0, 0, 0, 877, 878, 5, 19, 0, 0, 878,
		141, 1, 0, 0, 0, 879, 880, 5, 17, 0, 0, 880, 143, 1, 0, 0, 0, 881, 882,
		5, 22, 0, 0, 882, 145, 1, 0, 0, 0, 883, 884, 5, 21, 0, 0, 884, 147, 1,
		0, 0, 0, 92, 160, 167, 172, 179, 185, 189, 195, 202, 211, 216, 222, 229,
		241, 246, 258, 264, 273, 284, 295, 322, 331, 340, 349, 358, 373, 376, 385,
		400, 403, 410, 417, 424, 434, 437, 441, 453, 456, 464, 476, 493, 502, 510,
		515, 524, 533, 539, 545, 554, 557, 561, 570, 574, 583, 587, 596, 601, 605,
		614, 619, 623, 636, 642, 655, 661, 670, 676, 685, 691, 698, 703, 707, 714,
		722, 725, 729, 734, 738, 747, 762, 765, 772, 776, 788, 791, 795, 802, 807,
		824, 829, 837, 844, 857,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// ACIParserInit initializes any static state used to implement ACIParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewACIParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func ACIParserInit() {
	staticData := &ACIParserParserStaticData
	staticData.once.Do(aciparserParserInit)
}

// NewACIParser produces a new parser instance for the optional input antlr.TokenStream.
func NewACIParser(input antlr.TokenStream) *ACIParser {
	ACIParserInit()
	this := new(ACIParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &ACIParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "ACIParser.g4"

	return this
}

// ACIParser tokens.
const (
	ACIParserEOF                       = antlr.TokenEOF
	ACIParserWHSP                      = 1
	ACIParserDQUOTE                    = 2
	ACIParserLBRAK                     = 3
	ACIParserLPAREN                    = 4
	ACIParserRBRAK                     = 5
	ACIParserRPAREN                    = 6
	ACIParserDOT                       = 7
	ACIParserCOLON                     = 8
	ACIParserTILDE                     = 9
	ACIParserEQ                        = 10
	ACIParserNE                        = 11
	ACIParserGT                        = 12
	ACIParserLT                        = 13
	ACIParserAPX                       = 14
	ACIParserGE                        = 15
	ACIParserLE                        = 16
	ACIParserEXA                       = 17
	ACIParserEXO                       = 18
	ACIParserEXD                       = 19
	ACIParserHASH                      = 20
	ACIParserSYMBOLIC_AND              = 21
	ACIParserSYMBOLIC_OR               = 22
	ACIParserFILTER_AND                = 23
	ACIParserFILTER_OR                 = 24
	ACIParserFILTER_NOT                = 25
	ACIParserFILTER_OPERATOR           = 26
	ACIParserCOMMA                     = 27
	ACIParserSEMI                      = 28
	ACIParserSTAR                      = 29
	ACIParserLOCAL_LDAP_SCHEME         = 30
	ACIParserINHERITANCE_PREFIX        = 31
	ACIParserANCHOR                    = 32
	ACIParserSUNDAY                    = 33
	ACIParserMONDAY                    = 34
	ACIParserTUESDAY                   = 35
	ACIParserWEDNESDAY                 = 36
	ACIParserTHURSDAY                  = 37
	ACIParserFRIDAY                    = 38
	ACIParserSATURDAY                  = 39
	ACIParserANONYMOUS                 = 40
	ACIParserSIMPLE                    = 41
	ACIParserSSL                       = 42
	ACIParserSASL                      = 43
	ACIParserTARGET                    = 44
	ACIParserTARGET_TO                 = 45
	ACIParserTARGET_FROM               = 46
	ACIParserTARGET_SCOPE              = 47
	ACIParserTARGET_ATTR               = 48
	ACIParserTARGET_FILTER             = 49
	ACIParserTARGET_ATTR_FILTERS       = 50
	ACIParserTARGET_CONTROL            = 51
	ACIParserTARGET_EXTENDED_OPERATION = 52
	ACIParserBIND_USER_DN              = 53
	ACIParserBIND_GROUP_DN             = 54
	ACIParserBIND_ROLE_DN              = 55
	ACIParserBIND_USER_ATTR            = 56
	ACIParserBIND_GROUP_ATTR           = 57
	ACIParserBIND_SSF                  = 58
	ACIParserBIND_DNS                  = 59
	ACIParserBIND_IP                   = 60
	ACIParserBIND_AUTH_METHOD          = 61
	ACIParserBIND_TIME_OF_DAY          = 62
	ACIParserBIND_DAY_OF_WEEK          = 63
	ACIParserBINDTYPE_USER_DN          = 64
	ACIParserBINDTYPE_GROUP_DN         = 65
	ACIParserBINDTYPE_ROLE_DN          = 66
	ACIParserBINDTYPE_SELF_DN          = 67
	ACIParserBINDTYPE_LDAP_URL         = 68
	ACIParserBASE_OBJECT_SCOPE         = 69
	ACIParserONE_LEVEL_SCOPE           = 70
	ACIParserONE_LEVEL_TARGET_SCOPE    = 71
	ACIParserSUB_TREE_SCOPE            = 72
	ACIParserSUB_TREE_TARGET_SCOPE     = 73
	ACIParserSUBORDINATE_TARGET_SCOPE  = 74
	ACIParserALLOW_ACCESS              = 75
	ACIParserDENY_ACCESS               = 76
	ACIParserSEARCH_PRIVILEGE          = 77
	ACIParserREAD_PRIVILEGE            = 78
	ACIParserCOMPARE_PRIVILEGE         = 79
	ACIParserADD_PRIVILEGE             = 80
	ACIParserDELETE_PRIVILEGE          = 81
	ACIParserSELFWRITE_PRIVILEGE       = 82
	ACIParserPROXY_PRIVILEGE           = 83
	ACIParserIMPORT_PRIVILEGE          = 84
	ACIParserEXPORT_PRIVILEGE          = 85
	ACIParserALL_PRIVILEGES            = 86
	ACIParserRDN_MACROS                = 87
	ACIParserBOOLEAN_AND               = 88
	ACIParserBOOLEAN_OR                = 89
	ACIParserBOOLEAN_NOT               = 90
	ACIParserWHITESPACE                = 91
	ACIParserINT                       = 92
	ACIParserKEY_OR_VALUE              = 93
)

// ACIParser rules.
const (
	ACIParserRULE_parse                       = 0
	ACIParserRULE_instruction                 = 1
	ACIParserRULE_permissionBindRules         = 2
	ACIParserRULE_permissionBindRule          = 3
	ACIParserRULE_permission                  = 4
	ACIParserRULE_permissionDisposition       = 5
	ACIParserRULE_accessPrivileges            = 6
	ACIParserRULE_targetRules                 = 7
	ACIParserRULE_targetRule                  = 8
	ACIParserRULE_target                      = 9
	ACIParserRULE_targetTo                    = 10
	ACIParserRULE_targetFrom                  = 11
	ACIParserRULE_targetFilter                = 12
	ACIParserRULE_targetAttrFilters           = 13
	ACIParserRULE_targetScope                 = 14
	ACIParserRULE_targetAttributes            = 15
	ACIParserRULE_targetControl               = 16
	ACIParserRULE_targetExtendedOperation     = 17
	ACIParserRULE_targetSearchScopes          = 18
	ACIParserRULE_objectIdentifiers           = 19
	ACIParserRULE_targetedAttributes          = 20
	ACIParserRULE_objectIdentifier            = 21
	ACIParserRULE_objectIdentifierArc         = 22
	ACIParserRULE_targetAttrFiltersValue      = 23
	ACIParserRULE_attributeFilters            = 24
	ACIParserRULE_attributeFilterSet          = 25
	ACIParserRULE_attributeFilterOperation    = 26
	ACIParserRULE_attributeFilter             = 27
	ACIParserRULE_bindRule                    = 28
	ACIParserRULE_bindRuleExprParen           = 29
	ACIParserRULE_bindRuleExpr                = 30
	ACIParserRULE_bindDayOfWeek               = 31
	ACIParserRULE_doW                         = 32
	ACIParserRULE_bindAuthMethod              = 33
	ACIParserRULE_authenticationMethods       = 34
	ACIParserRULE_bindUserDN                  = 35
	ACIParserRULE_bindRoleDN                  = 36
	ACIParserRULE_bindGroupDN                 = 37
	ACIParserRULE_bindUserAttr                = 38
	ACIParserRULE_bindGroupAttr               = 39
	ACIParserRULE_bindSecurityStrengthFactor  = 40
	ACIParserRULE_bindTimeOfDay               = 41
	ACIParserRULE_bindIP                      = 42
	ACIParserRULE_bindDNS                     = 43
	ACIParserRULE_iPAddresses                 = 44
	ACIParserRULE_iPAddress                   = 45
	ACIParserRULE_iPv4Address                 = 46
	ACIParserRULE_iPv6Address                 = 47
	ACIParserRULE_fQDN                        = 48
	ACIParserRULE_distinguishedNames          = 49
	ACIParserRULE_distinguishedName           = 50
	ACIParserRULE_rDNMacros                   = 51
	ACIParserRULE_lDAPFilter                  = 52
	ACIParserRULE_lDAPFilterExpr              = 53
	ACIParserRULE_aVAOrRDN                    = 54
	ACIParserRULE_inheritance                 = 55
	ACIParserRULE_inheritanceLevels           = 56
	ACIParserRULE_attributeBindTypeOrValue    = 57
	ACIParserRULE_bindTypes                   = 58
	ACIParserRULE_attributeTypeOrValue        = 59
	ACIParserRULE_attributeComparisonOperator = 60
	ACIParserRULE_equalTo                     = 61
	ACIParserRULE_notEqualTo                  = 62
	ACIParserRULE_greaterThan                 = 63
	ACIParserRULE_lessThan                    = 64
	ACIParserRULE_greaterThanOrEqual          = 65
	ACIParserRULE_lessThanOrEqual             = 66
	ACIParserRULE_approximate                 = 67
	ACIParserRULE_extensibleRule              = 68
	ACIParserRULE_extensibleRuleDNOID         = 69
	ACIParserRULE_extensibleRuleDN            = 70
	ACIParserRULE_extensibleRuleAttr          = 71
	ACIParserRULE_oRDelimiter                 = 72
	ACIParserRULE_aNDDelimiter                = 73
)

// IParseContext is an interface to support dynamic dispatch.
type IParseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Instruction() IInstructionContext
	EOF() antlr.TerminalNode

	// IsParseContext differentiates from other interfaces.
	IsParseContext()
}

type ParseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParseContext() *ParseContext {
	var p = new(ParseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_parse
	return p
}

func InitEmptyParseContext(p *ParseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_parse
}

func (*ParseContext) IsParseContext() {}

func NewParseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParseContext {
	var p = new(ParseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_parse

	return p
}

func (s *ParseContext) GetParser() antlr.Parser { return s.parser }

func (s *ParseContext) Instruction() IInstructionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstructionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstructionContext)
}

func (s *ParseContext) EOF() antlr.TerminalNode {
	return s.GetToken(ACIParserEOF, 0)
}

func (s *ParseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParse(s)
	}
}

func (s *ParseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParse(s)
	}
}

func (p *ACIParser) Parse() (localctx IParseContext) {
	localctx = NewParseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ACIParserRULE_parse)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(148)
		p.Instruction()
	}
	{
		p.SetState(149)
		p.Match(ACIParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInstructionContext is an interface to support dynamic dispatch.
type IInstructionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsInstructionContext differentiates from other interfaces.
	IsInstructionContext()
}

type InstructionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstructionContext() *InstructionContext {
	var p = new(InstructionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_instruction
	return p
}

func InitEmptyInstructionContext(p *InstructionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_instruction
}

func (*InstructionContext) IsInstructionContext() {}

func NewInstructionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstructionContext {
	var p = new(InstructionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_instruction

	return p
}

func (s *InstructionContext) GetParser() antlr.Parser { return s.parser }

func (s *InstructionContext) CopyAll(ctx *InstructionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *InstructionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstructionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AciContext struct {
	InstructionContext
}

func NewAciContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AciContext {
	var p = new(AciContext)

	InitEmptyInstructionContext(&p.InstructionContext)
	p.parser = parser
	p.CopyAll(ctx.(*InstructionContext))

	return p
}

func (s *AciContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AciContext) TargetRules() ITargetRulesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetRulesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetRulesContext)
}

func (s *AciContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *AciContext) ANCHOR() antlr.TerminalNode {
	return s.GetToken(ACIParserANCHOR, 0)
}

func (s *AciContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *AciContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *AciContext) AttributeTypeOrValue() IAttributeTypeOrValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeTypeOrValueContext)
}

func (s *AciContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ACIParserSEMI, 0)
}

func (s *AciContext) PermissionBindRules() IPermissionBindRulesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPermissionBindRulesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPermissionBindRulesContext)
}

func (s *AciContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *AciContext) AllWHSP() []antlr.TerminalNode {
	return s.GetTokens(ACIParserWHSP)
}

func (s *AciContext) WHSP(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserWHSP, i)
}

func (s *AciContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAci(s)
	}
}

func (s *AciContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAci(s)
	}
}

func (p *ACIParser) Instruction() (localctx IInstructionContext) {
	localctx = NewInstructionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ACIParserRULE_instruction)
	var _la int

	var _alt int

	localctx = NewAciContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(151)
		p.TargetRules()
	}
	{
		p.SetState(152)
		p.Match(ACIParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(153)
		p.Match(ACIParserANCHOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(154)
		p.Match(ACIParserDQUOTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(155)
		p.AttributeTypeOrValue()
	}
	{
		p.SetState(156)
		p.Match(ACIParserDQUOTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(160)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1+1 {
			{
				p.SetState(157)
				p.Match(ACIParserWHSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(162)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(163)
		p.Match(ACIParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(167)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1+1 {
			{
				p.SetState(164)
				p.Match(ACIParserWHSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(169)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(170)
		p.PermissionBindRules()
	}
	p.SetState(172)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ACIParserWHSP {
		{
			p.SetState(171)
			p.Match(ACIParserWHSP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(174)
		p.Match(ACIParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPermissionBindRulesContext is an interface to support dynamic dispatch.
type IPermissionBindRulesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPermissionBindRulesContext differentiates from other interfaces.
	IsPermissionBindRulesContext()
}

type PermissionBindRulesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPermissionBindRulesContext() *PermissionBindRulesContext {
	var p = new(PermissionBindRulesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_permissionBindRules
	return p
}

func InitEmptyPermissionBindRulesContext(p *PermissionBindRulesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_permissionBindRules
}

func (*PermissionBindRulesContext) IsPermissionBindRulesContext() {}

func NewPermissionBindRulesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PermissionBindRulesContext {
	var p = new(PermissionBindRulesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_permissionBindRules

	return p
}

func (s *PermissionBindRulesContext) GetParser() antlr.Parser { return s.parser }

func (s *PermissionBindRulesContext) CopyAll(ctx *PermissionBindRulesContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PermissionBindRulesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PermissionBindRulesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Permission_bind_rulesContext struct {
	PermissionBindRulesContext
}

func NewPermission_bind_rulesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Permission_bind_rulesContext {
	var p = new(Permission_bind_rulesContext)

	InitEmptyPermissionBindRulesContext(&p.PermissionBindRulesContext)
	p.parser = parser
	p.CopyAll(ctx.(*PermissionBindRulesContext))

	return p
}

func (s *Permission_bind_rulesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Permission_bind_rulesContext) AllPermissionBindRule() []IPermissionBindRuleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPermissionBindRuleContext); ok {
			len++
		}
	}

	tst := make([]IPermissionBindRuleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPermissionBindRuleContext); ok {
			tst[i] = t.(IPermissionBindRuleContext)
			i++
		}
	}

	return tst
}

func (s *Permission_bind_rulesContext) PermissionBindRule(i int) IPermissionBindRuleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPermissionBindRuleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPermissionBindRuleContext)
}

func (s *Permission_bind_rulesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterPermission_bind_rules(s)
	}
}

func (s *Permission_bind_rulesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitPermission_bind_rules(s)
	}
}

func (p *ACIParser) PermissionBindRules() (localctx IPermissionBindRulesContext) {
	localctx = NewPermissionBindRulesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ACIParserRULE_permissionBindRules)
	var _la int

	localctx = NewPermission_bind_rulesContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(179)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ACIParserALLOW_ACCESS || _la == ACIParserDENY_ACCESS {
		{
			p.SetState(176)
			p.PermissionBindRule()
		}

		p.SetState(181)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPermissionBindRuleContext is an interface to support dynamic dispatch.
type IPermissionBindRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPermissionBindRuleContext differentiates from other interfaces.
	IsPermissionBindRuleContext()
}

type PermissionBindRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPermissionBindRuleContext() *PermissionBindRuleContext {
	var p = new(PermissionBindRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_permissionBindRule
	return p
}

func InitEmptyPermissionBindRuleContext(p *PermissionBindRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_permissionBindRule
}

func (*PermissionBindRuleContext) IsPermissionBindRuleContext() {}

func NewPermissionBindRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PermissionBindRuleContext {
	var p = new(PermissionBindRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_permissionBindRule

	return p
}

func (s *PermissionBindRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *PermissionBindRuleContext) CopyAll(ctx *PermissionBindRuleContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PermissionBindRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PermissionBindRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Permission_and_bind_rule_pairContext struct {
	PermissionBindRuleContext
}

func NewPermission_and_bind_rule_pairContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Permission_and_bind_rule_pairContext {
	var p = new(Permission_and_bind_rule_pairContext)

	InitEmptyPermissionBindRuleContext(&p.PermissionBindRuleContext)
	p.parser = parser
	p.CopyAll(ctx.(*PermissionBindRuleContext))

	return p
}

func (s *Permission_and_bind_rule_pairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Permission_and_bind_rule_pairContext) Permission() IPermissionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPermissionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPermissionContext)
}

func (s *Permission_and_bind_rule_pairContext) BindRule() IBindRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindRuleContext)
}

func (s *Permission_and_bind_rule_pairContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ACIParserSEMI, 0)
}

func (s *Permission_and_bind_rule_pairContext) AllWHSP() []antlr.TerminalNode {
	return s.GetTokens(ACIParserWHSP)
}

func (s *Permission_and_bind_rule_pairContext) WHSP(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserWHSP, i)
}

func (s *Permission_and_bind_rule_pairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterPermission_and_bind_rule_pair(s)
	}
}

func (s *Permission_and_bind_rule_pairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitPermission_and_bind_rule_pair(s)
	}
}

func (p *ACIParser) PermissionBindRule() (localctx IPermissionBindRuleContext) {
	localctx = NewPermissionBindRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ACIParserRULE_permissionBindRule)
	var _la int

	localctx = NewPermission_and_bind_rule_pairContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(182)
		p.Permission()
	}
	{
		p.SetState(183)
		p.BindRule()
	}
	p.SetState(185)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ACIParserWHSP {
		{
			p.SetState(184)
			p.Match(ACIParserWHSP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(187)
		p.Match(ACIParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(189)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(188)
			p.Match(ACIParserWHSP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPermissionContext is an interface to support dynamic dispatch.
type IPermissionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPermissionContext differentiates from other interfaces.
	IsPermissionContext()
}

type PermissionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPermissionContext() *PermissionContext {
	var p = new(PermissionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_permission
	return p
}

func InitEmptyPermissionContext(p *PermissionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_permission
}

func (*PermissionContext) IsPermissionContext() {}

func NewPermissionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PermissionContext {
	var p = new(PermissionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_permission

	return p
}

func (s *PermissionContext) GetParser() antlr.Parser { return s.parser }

func (s *PermissionContext) CopyAll(ctx *PermissionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PermissionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PermissionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Permission_expressionContext struct {
	PermissionContext
}

func NewPermission_expressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Permission_expressionContext {
	var p = new(Permission_expressionContext)

	InitEmptyPermissionContext(&p.PermissionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PermissionContext))

	return p
}

func (s *Permission_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Permission_expressionContext) PermissionDisposition() IPermissionDispositionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPermissionDispositionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPermissionDispositionContext)
}

func (s *Permission_expressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Permission_expressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Permission_expressionContext) AllAccessPrivileges() []IAccessPrivilegesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAccessPrivilegesContext); ok {
			len++
		}
	}

	tst := make([]IAccessPrivilegesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAccessPrivilegesContext); ok {
			tst[i] = t.(IAccessPrivilegesContext)
			i++
		}
	}

	return tst
}

func (s *Permission_expressionContext) AccessPrivileges(i int) IAccessPrivilegesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessPrivilegesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessPrivilegesContext)
}

func (s *Permission_expressionContext) AllWHSP() []antlr.TerminalNode {
	return s.GetTokens(ACIParserWHSP)
}

func (s *Permission_expressionContext) WHSP(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserWHSP, i)
}

func (s *Permission_expressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ACIParserCOMMA)
}

func (s *Permission_expressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserCOMMA, i)
}

func (s *Permission_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterPermission_expression(s)
	}
}

func (s *Permission_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitPermission_expression(s)
	}
}

func (p *ACIParser) Permission() (localctx IPermissionContext) {
	localctx = NewPermissionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ACIParserRULE_permission)
	var _la int

	var _alt int

	localctx = NewPermission_expressionContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(191)
		p.PermissionDisposition()
	}
	p.SetState(195)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1+1 {
			{
				p.SetState(192)
				p.Match(ACIParserWHSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(197)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(198)
		p.Match(ACIParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	p.SetState(202)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1+1 {
			{
				p.SetState(199)
				p.Match(ACIParserWHSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(204)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(205)
		p.AccessPrivileges()
	}
	p.SetState(216)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ACIParserCOMMA {
		{
			p.SetState(206)
			p.Match(ACIParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(207)
			p.AccessPrivileges()
		}
		p.SetState(211)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1+1 {
				{
					p.SetState(208)
					p.Match(ACIParserWHSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(213)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

		p.SetState(218)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

	p.SetState(222)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1+1 {
			{
				p.SetState(219)
				p.Match(ACIParserWHSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(224)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(225)
		p.Match(ACIParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPermissionDispositionContext is an interface to support dynamic dispatch.
type IPermissionDispositionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPermissionDispositionContext differentiates from other interfaces.
	IsPermissionDispositionContext()
}

type PermissionDispositionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPermissionDispositionContext() *PermissionDispositionContext {
	var p = new(PermissionDispositionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_permissionDisposition
	return p
}

func InitEmptyPermissionDispositionContext(p *PermissionDispositionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_permissionDisposition
}

func (*PermissionDispositionContext) IsPermissionDispositionContext() {}

func NewPermissionDispositionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PermissionDispositionContext {
	var p = new(PermissionDispositionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_permissionDisposition

	return p
}

func (s *PermissionDispositionContext) GetParser() antlr.Parser { return s.parser }

func (s *PermissionDispositionContext) CopyAll(ctx *PermissionDispositionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PermissionDispositionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PermissionDispositionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Deny_accessContext struct {
	PermissionDispositionContext
}

func NewDeny_accessContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Deny_accessContext {
	var p = new(Deny_accessContext)

	InitEmptyPermissionDispositionContext(&p.PermissionDispositionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PermissionDispositionContext))

	return p
}

func (s *Deny_accessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Deny_accessContext) DENY_ACCESS() antlr.TerminalNode {
	return s.GetToken(ACIParserDENY_ACCESS, 0)
}

func (s *Deny_accessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterDeny_access(s)
	}
}

func (s *Deny_accessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitDeny_access(s)
	}
}

type Allow_accessContext struct {
	PermissionDispositionContext
}

func NewAllow_accessContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Allow_accessContext {
	var p = new(Allow_accessContext)

	InitEmptyPermissionDispositionContext(&p.PermissionDispositionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PermissionDispositionContext))

	return p
}

func (s *Allow_accessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Allow_accessContext) ALLOW_ACCESS() antlr.TerminalNode {
	return s.GetToken(ACIParserALLOW_ACCESS, 0)
}

func (s *Allow_accessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAllow_access(s)
	}
}

func (s *Allow_accessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAllow_access(s)
	}
}

func (p *ACIParser) PermissionDisposition() (localctx IPermissionDispositionContext) {
	localctx = NewPermissionDispositionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ACIParserRULE_permissionDisposition)
	p.SetState(229)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserALLOW_ACCESS:
		localctx = NewAllow_accessContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(227)
			p.Match(ACIParserALLOW_ACCESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserDENY_ACCESS:
		localctx = NewDeny_accessContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(228)
			p.Match(ACIParserDENY_ACCESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAccessPrivilegesContext is an interface to support dynamic dispatch.
type IAccessPrivilegesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAccessPrivilegesContext differentiates from other interfaces.
	IsAccessPrivilegesContext()
}

type AccessPrivilegesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccessPrivilegesContext() *AccessPrivilegesContext {
	var p = new(AccessPrivilegesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_accessPrivileges
	return p
}

func InitEmptyAccessPrivilegesContext(p *AccessPrivilegesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_accessPrivileges
}

func (*AccessPrivilegesContext) IsAccessPrivilegesContext() {}

func NewAccessPrivilegesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AccessPrivilegesContext {
	var p = new(AccessPrivilegesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_accessPrivileges

	return p
}

func (s *AccessPrivilegesContext) GetParser() antlr.Parser { return s.parser }

func (s *AccessPrivilegesContext) CopyAll(ctx *AccessPrivilegesContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AccessPrivilegesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AccessPrivilegesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Selfwrite_privilegeContext struct {
	AccessPrivilegesContext
}

func NewSelfwrite_privilegeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Selfwrite_privilegeContext {
	var p = new(Selfwrite_privilegeContext)

	InitEmptyAccessPrivilegesContext(&p.AccessPrivilegesContext)
	p.parser = parser
	p.CopyAll(ctx.(*AccessPrivilegesContext))

	return p
}

func (s *Selfwrite_privilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Selfwrite_privilegeContext) SELFWRITE_PRIVILEGE() antlr.TerminalNode {
	return s.GetToken(ACIParserSELFWRITE_PRIVILEGE, 0)
}

func (s *Selfwrite_privilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSelfwrite_privilege(s)
	}
}

func (s *Selfwrite_privilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSelfwrite_privilege(s)
	}
}

type Export_privilegeContext struct {
	AccessPrivilegesContext
}

func NewExport_privilegeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Export_privilegeContext {
	var p = new(Export_privilegeContext)

	InitEmptyAccessPrivilegesContext(&p.AccessPrivilegesContext)
	p.parser = parser
	p.CopyAll(ctx.(*AccessPrivilegesContext))

	return p
}

func (s *Export_privilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Export_privilegeContext) EXPORT_PRIVILEGE() antlr.TerminalNode {
	return s.GetToken(ACIParserEXPORT_PRIVILEGE, 0)
}

func (s *Export_privilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterExport_privilege(s)
	}
}

func (s *Export_privilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitExport_privilege(s)
	}
}

type All_privilegesContext struct {
	AccessPrivilegesContext
}

func NewAll_privilegesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *All_privilegesContext {
	var p = new(All_privilegesContext)

	InitEmptyAccessPrivilegesContext(&p.AccessPrivilegesContext)
	p.parser = parser
	p.CopyAll(ctx.(*AccessPrivilegesContext))

	return p
}

func (s *All_privilegesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *All_privilegesContext) ALL_PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(ACIParserALL_PRIVILEGES, 0)
}

func (s *All_privilegesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAll_privileges(s)
	}
}

func (s *All_privilegesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAll_privileges(s)
	}
}

type Import_privilegeContext struct {
	AccessPrivilegesContext
}

func NewImport_privilegeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Import_privilegeContext {
	var p = new(Import_privilegeContext)

	InitEmptyAccessPrivilegesContext(&p.AccessPrivilegesContext)
	p.parser = parser
	p.CopyAll(ctx.(*AccessPrivilegesContext))

	return p
}

func (s *Import_privilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_privilegeContext) IMPORT_PRIVILEGE() antlr.TerminalNode {
	return s.GetToken(ACIParserIMPORT_PRIVILEGE, 0)
}

func (s *Import_privilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterImport_privilege(s)
	}
}

func (s *Import_privilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitImport_privilege(s)
	}
}

type Add_privilegeContext struct {
	AccessPrivilegesContext
}

func NewAdd_privilegeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Add_privilegeContext {
	var p = new(Add_privilegeContext)

	InitEmptyAccessPrivilegesContext(&p.AccessPrivilegesContext)
	p.parser = parser
	p.CopyAll(ctx.(*AccessPrivilegesContext))

	return p
}

func (s *Add_privilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Add_privilegeContext) ADD_PRIVILEGE() antlr.TerminalNode {
	return s.GetToken(ACIParserADD_PRIVILEGE, 0)
}

func (s *Add_privilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAdd_privilege(s)
	}
}

func (s *Add_privilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAdd_privilege(s)
	}
}

type Search_privilegeContext struct {
	AccessPrivilegesContext
}

func NewSearch_privilegeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Search_privilegeContext {
	var p = new(Search_privilegeContext)

	InitEmptyAccessPrivilegesContext(&p.AccessPrivilegesContext)
	p.parser = parser
	p.CopyAll(ctx.(*AccessPrivilegesContext))

	return p
}

func (s *Search_privilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Search_privilegeContext) SEARCH_PRIVILEGE() antlr.TerminalNode {
	return s.GetToken(ACIParserSEARCH_PRIVILEGE, 0)
}

func (s *Search_privilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSearch_privilege(s)
	}
}

func (s *Search_privilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSearch_privilege(s)
	}
}

type Compare_privilegeContext struct {
	AccessPrivilegesContext
}

func NewCompare_privilegeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Compare_privilegeContext {
	var p = new(Compare_privilegeContext)

	InitEmptyAccessPrivilegesContext(&p.AccessPrivilegesContext)
	p.parser = parser
	p.CopyAll(ctx.(*AccessPrivilegesContext))

	return p
}

func (s *Compare_privilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Compare_privilegeContext) COMPARE_PRIVILEGE() antlr.TerminalNode {
	return s.GetToken(ACIParserCOMPARE_PRIVILEGE, 0)
}

func (s *Compare_privilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterCompare_privilege(s)
	}
}

func (s *Compare_privilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitCompare_privilege(s)
	}
}

type Proxy_privilegeContext struct {
	AccessPrivilegesContext
}

func NewProxy_privilegeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Proxy_privilegeContext {
	var p = new(Proxy_privilegeContext)

	InitEmptyAccessPrivilegesContext(&p.AccessPrivilegesContext)
	p.parser = parser
	p.CopyAll(ctx.(*AccessPrivilegesContext))

	return p
}

func (s *Proxy_privilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Proxy_privilegeContext) PROXY_PRIVILEGE() antlr.TerminalNode {
	return s.GetToken(ACIParserPROXY_PRIVILEGE, 0)
}

func (s *Proxy_privilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterProxy_privilege(s)
	}
}

func (s *Proxy_privilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitProxy_privilege(s)
	}
}

type Read_privilegeContext struct {
	AccessPrivilegesContext
}

func NewRead_privilegeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Read_privilegeContext {
	var p = new(Read_privilegeContext)

	InitEmptyAccessPrivilegesContext(&p.AccessPrivilegesContext)
	p.parser = parser
	p.CopyAll(ctx.(*AccessPrivilegesContext))

	return p
}

func (s *Read_privilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Read_privilegeContext) READ_PRIVILEGE() antlr.TerminalNode {
	return s.GetToken(ACIParserREAD_PRIVILEGE, 0)
}

func (s *Read_privilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterRead_privilege(s)
	}
}

func (s *Read_privilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitRead_privilege(s)
	}
}

type Delete_privilegeContext struct {
	AccessPrivilegesContext
}

func NewDelete_privilegeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Delete_privilegeContext {
	var p = new(Delete_privilegeContext)

	InitEmptyAccessPrivilegesContext(&p.AccessPrivilegesContext)
	p.parser = parser
	p.CopyAll(ctx.(*AccessPrivilegesContext))

	return p
}

func (s *Delete_privilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delete_privilegeContext) DELETE_PRIVILEGE() antlr.TerminalNode {
	return s.GetToken(ACIParserDELETE_PRIVILEGE, 0)
}

func (s *Delete_privilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterDelete_privilege(s)
	}
}

func (s *Delete_privilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitDelete_privilege(s)
	}
}

func (p *ACIParser) AccessPrivileges() (localctx IAccessPrivilegesContext) {
	localctx = NewAccessPrivilegesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ACIParserRULE_accessPrivileges)
	p.SetState(241)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserSEARCH_PRIVILEGE:
		localctx = NewSearch_privilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(231)
			p.Match(ACIParserSEARCH_PRIVILEGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserREAD_PRIVILEGE:
		localctx = NewRead_privilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(232)
			p.Match(ACIParserREAD_PRIVILEGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserCOMPARE_PRIVILEGE:
		localctx = NewCompare_privilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(233)
			p.Match(ACIParserCOMPARE_PRIVILEGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserADD_PRIVILEGE:
		localctx = NewAdd_privilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(234)
			p.Match(ACIParserADD_PRIVILEGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserDELETE_PRIVILEGE:
		localctx = NewDelete_privilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(235)
			p.Match(ACIParserDELETE_PRIVILEGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserSELFWRITE_PRIVILEGE:
		localctx = NewSelfwrite_privilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(236)
			p.Match(ACIParserSELFWRITE_PRIVILEGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserPROXY_PRIVILEGE:
		localctx = NewProxy_privilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(237)
			p.Match(ACIParserPROXY_PRIVILEGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserIMPORT_PRIVILEGE:
		localctx = NewImport_privilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(238)
			p.Match(ACIParserIMPORT_PRIVILEGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserEXPORT_PRIVILEGE:
		localctx = NewExport_privilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(239)
			p.Match(ACIParserEXPORT_PRIVILEGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserALL_PRIVILEGES:
		localctx = NewAll_privilegesContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(240)
			p.Match(ACIParserALL_PRIVILEGES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetRulesContext is an interface to support dynamic dispatch.
type ITargetRulesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTargetRulesContext differentiates from other interfaces.
	IsTargetRulesContext()
}

type TargetRulesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetRulesContext() *TargetRulesContext {
	var p = new(TargetRulesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetRules
	return p
}

func InitEmptyTargetRulesContext(p *TargetRulesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetRules
}

func (*TargetRulesContext) IsTargetRulesContext() {}

func NewTargetRulesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetRulesContext {
	var p = new(TargetRulesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_targetRules

	return p
}

func (s *TargetRulesContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetRulesContext) CopyAll(ctx *TargetRulesContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TargetRulesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetRulesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Target_rulesContext struct {
	TargetRulesContext
}

func NewTarget_rulesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Target_rulesContext {
	var p = new(Target_rulesContext)

	InitEmptyTargetRulesContext(&p.TargetRulesContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetRulesContext))

	return p
}

func (s *Target_rulesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Target_rulesContext) AllTargetRule() []ITargetRuleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITargetRuleContext); ok {
			len++
		}
	}

	tst := make([]ITargetRuleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITargetRuleContext); ok {
			tst[i] = t.(ITargetRuleContext)
			i++
		}
	}

	return tst
}

func (s *Target_rulesContext) TargetRule(i int) ITargetRuleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetRuleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetRuleContext)
}

func (s *Target_rulesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterTarget_rules(s)
	}
}

func (s *Target_rulesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitTarget_rules(s)
	}
}

func (p *ACIParser) TargetRules() (localctx ITargetRulesContext) {
	localctx = NewTargetRulesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ACIParserRULE_targetRules)
	var _alt int

	localctx = NewTarget_rulesContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(246)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(243)
				p.TargetRule()
			}

		}
		p.SetState(248)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetRuleContext is an interface to support dynamic dispatch.
type ITargetRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TargetControl() ITargetControlContext
	TargetExtendedOperation() ITargetExtendedOperationContext
	TargetFilter() ITargetFilterContext
	TargetAttrFilters() ITargetAttrFiltersContext
	TargetScope() ITargetScopeContext
	TargetAttributes() ITargetAttributesContext
	Target() ITargetContext
	TargetTo() ITargetToContext
	TargetFrom() ITargetFromContext

	// IsTargetRuleContext differentiates from other interfaces.
	IsTargetRuleContext()
}

type TargetRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetRuleContext() *TargetRuleContext {
	var p = new(TargetRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetRule
	return p
}

func InitEmptyTargetRuleContext(p *TargetRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetRule
}

func (*TargetRuleContext) IsTargetRuleContext() {}

func NewTargetRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetRuleContext {
	var p = new(TargetRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_targetRule

	return p
}

func (s *TargetRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetRuleContext) TargetControl() ITargetControlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetControlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetControlContext)
}

func (s *TargetRuleContext) TargetExtendedOperation() ITargetExtendedOperationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetExtendedOperationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetExtendedOperationContext)
}

func (s *TargetRuleContext) TargetFilter() ITargetFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetFilterContext)
}

func (s *TargetRuleContext) TargetAttrFilters() ITargetAttrFiltersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetAttrFiltersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetAttrFiltersContext)
}

func (s *TargetRuleContext) TargetScope() ITargetScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetScopeContext)
}

func (s *TargetRuleContext) TargetAttributes() ITargetAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetAttributesContext)
}

func (s *TargetRuleContext) Target() ITargetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetContext)
}

func (s *TargetRuleContext) TargetTo() ITargetToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetToContext)
}

func (s *TargetRuleContext) TargetFrom() ITargetFromContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetFromContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetFromContext)
}

func (s *TargetRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TargetRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterTargetRule(s)
	}
}

func (s *TargetRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitTargetRule(s)
	}
}

func (p *ACIParser) TargetRule() (localctx ITargetRuleContext) {
	localctx = NewTargetRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ACIParserRULE_targetRule)
	p.SetState(258)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(249)
			p.TargetControl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(250)
			p.TargetExtendedOperation()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(251)
			p.TargetFilter()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(252)
			p.TargetAttrFilters()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(253)
			p.TargetScope()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(254)
			p.TargetAttributes()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(255)
			p.Target()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(256)
			p.TargetTo()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(257)
			p.TargetFrom()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetContext is an interface to support dynamic dispatch.
type ITargetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTargetContext differentiates from other interfaces.
	IsTargetContext()
}

type TargetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetContext() *TargetContext {
	var p = new(TargetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_target
	return p
}

func InitEmptyTargetContext(p *TargetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_target
}

func (*TargetContext) IsTargetContext() {}

func NewTargetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetContext {
	var p = new(TargetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_target

	return p
}

func (s *TargetContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetContext) CopyAll(ctx *TargetContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TargetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Target_dn_ruleContext struct {
	TargetContext
}

func NewTarget_dn_ruleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Target_dn_ruleContext {
	var p = new(Target_dn_ruleContext)

	InitEmptyTargetContext(&p.TargetContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetContext))

	return p
}

func (s *Target_dn_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Target_dn_ruleContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Target_dn_ruleContext) TARGET() antlr.TerminalNode {
	return s.GetToken(ACIParserTARGET, 0)
}

func (s *Target_dn_ruleContext) DistinguishedNames() IDistinguishedNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistinguishedNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistinguishedNamesContext)
}

func (s *Target_dn_ruleContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Target_dn_ruleContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Target_dn_ruleContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Target_dn_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterTarget_dn_rule(s)
	}
}

func (s *Target_dn_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitTarget_dn_rule(s)
	}
}

func (p *ACIParser) Target() (localctx ITargetContext) {
	localctx = NewTargetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ACIParserRULE_target)
	localctx = NewTarget_dn_ruleContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(260)
		p.Match(ACIParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(261)
		p.Match(ACIParserTARGET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(264)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserEQ:
		{
			p.SetState(262)
			p.EqualTo()
		}

	case ACIParserNE:
		{
			p.SetState(263)
			p.NotEqualTo()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(266)
		p.DistinguishedNames()
	}
	{
		p.SetState(267)
		p.Match(ACIParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetToContext is an interface to support dynamic dispatch.
type ITargetToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTargetToContext differentiates from other interfaces.
	IsTargetToContext()
}

type TargetToContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetToContext() *TargetToContext {
	var p = new(TargetToContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetTo
	return p
}

func InitEmptyTargetToContext(p *TargetToContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetTo
}

func (*TargetToContext) IsTargetToContext() {}

func NewTargetToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetToContext {
	var p = new(TargetToContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_targetTo

	return p
}

func (s *TargetToContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetToContext) CopyAll(ctx *TargetToContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TargetToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Target_to_ruleContext struct {
	TargetToContext
}

func NewTarget_to_ruleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Target_to_ruleContext {
	var p = new(Target_to_ruleContext)

	InitEmptyTargetToContext(&p.TargetToContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetToContext))

	return p
}

func (s *Target_to_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Target_to_ruleContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Target_to_ruleContext) TARGET_TO() antlr.TerminalNode {
	return s.GetToken(ACIParserTARGET_TO, 0)
}

func (s *Target_to_ruleContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Target_to_ruleContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Target_to_ruleContext) DistinguishedName() IDistinguishedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistinguishedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistinguishedNameContext)
}

func (s *Target_to_ruleContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Target_to_ruleContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Target_to_ruleContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Target_to_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterTarget_to_rule(s)
	}
}

func (s *Target_to_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitTarget_to_rule(s)
	}
}

func (p *ACIParser) TargetTo() (localctx ITargetToContext) {
	localctx = NewTargetToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ACIParserRULE_targetTo)
	localctx = NewTarget_to_ruleContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(269)
		p.Match(ACIParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(270)
		p.Match(ACIParserTARGET_TO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(273)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserEQ:
		{
			p.SetState(271)
			p.EqualTo()
		}

	case ACIParserNE:
		{
			p.SetState(272)
			p.NotEqualTo()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(275)
		p.Match(ACIParserDQUOTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(276)
		p.DistinguishedName()
	}
	{
		p.SetState(277)
		p.Match(ACIParserDQUOTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(278)
		p.Match(ACIParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetFromContext is an interface to support dynamic dispatch.
type ITargetFromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTargetFromContext differentiates from other interfaces.
	IsTargetFromContext()
}

type TargetFromContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetFromContext() *TargetFromContext {
	var p = new(TargetFromContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetFrom
	return p
}

func InitEmptyTargetFromContext(p *TargetFromContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetFrom
}

func (*TargetFromContext) IsTargetFromContext() {}

func NewTargetFromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetFromContext {
	var p = new(TargetFromContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_targetFrom

	return p
}

func (s *TargetFromContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetFromContext) CopyAll(ctx *TargetFromContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TargetFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetFromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Target_from_ruleContext struct {
	TargetFromContext
}

func NewTarget_from_ruleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Target_from_ruleContext {
	var p = new(Target_from_ruleContext)

	InitEmptyTargetFromContext(&p.TargetFromContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetFromContext))

	return p
}

func (s *Target_from_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Target_from_ruleContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Target_from_ruleContext) TARGET_FROM() antlr.TerminalNode {
	return s.GetToken(ACIParserTARGET_FROM, 0)
}

func (s *Target_from_ruleContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Target_from_ruleContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Target_from_ruleContext) DistinguishedName() IDistinguishedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistinguishedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistinguishedNameContext)
}

func (s *Target_from_ruleContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Target_from_ruleContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Target_from_ruleContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Target_from_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterTarget_from_rule(s)
	}
}

func (s *Target_from_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitTarget_from_rule(s)
	}
}

func (p *ACIParser) TargetFrom() (localctx ITargetFromContext) {
	localctx = NewTargetFromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ACIParserRULE_targetFrom)
	localctx = NewTarget_from_ruleContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(280)
		p.Match(ACIParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(281)
		p.Match(ACIParserTARGET_FROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(284)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserEQ:
		{
			p.SetState(282)
			p.EqualTo()
		}

	case ACIParserNE:
		{
			p.SetState(283)
			p.NotEqualTo()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(286)
		p.Match(ACIParserDQUOTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(287)
		p.DistinguishedName()
	}
	{
		p.SetState(288)
		p.Match(ACIParserDQUOTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(289)
		p.Match(ACIParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetFilterContext is an interface to support dynamic dispatch.
type ITargetFilterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTargetFilterContext differentiates from other interfaces.
	IsTargetFilterContext()
}

type TargetFilterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetFilterContext() *TargetFilterContext {
	var p = new(TargetFilterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetFilter
	return p
}

func InitEmptyTargetFilterContext(p *TargetFilterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetFilter
}

func (*TargetFilterContext) IsTargetFilterContext() {}

func NewTargetFilterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetFilterContext {
	var p = new(TargetFilterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_targetFilter

	return p
}

func (s *TargetFilterContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetFilterContext) CopyAll(ctx *TargetFilterContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TargetFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetFilterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Targetfilter_ruleContext struct {
	TargetFilterContext
}

func NewTargetfilter_ruleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Targetfilter_ruleContext {
	var p = new(Targetfilter_ruleContext)

	InitEmptyTargetFilterContext(&p.TargetFilterContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetFilterContext))

	return p
}

func (s *Targetfilter_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Targetfilter_ruleContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Targetfilter_ruleContext) TARGET_FILTER() antlr.TerminalNode {
	return s.GetToken(ACIParserTARGET_FILTER, 0)
}

func (s *Targetfilter_ruleContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Targetfilter_ruleContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Targetfilter_ruleContext) LDAPFilter() ILDAPFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILDAPFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILDAPFilterContext)
}

func (s *Targetfilter_ruleContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Targetfilter_ruleContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Targetfilter_ruleContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Targetfilter_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterTargetfilter_rule(s)
	}
}

func (s *Targetfilter_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitTargetfilter_rule(s)
	}
}

func (p *ACIParser) TargetFilter() (localctx ITargetFilterContext) {
	localctx = NewTargetFilterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ACIParserRULE_targetFilter)
	localctx = NewTargetfilter_ruleContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(291)
		p.Match(ACIParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(292)
		p.Match(ACIParserTARGET_FILTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(295)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserEQ:
		{
			p.SetState(293)
			p.EqualTo()
		}

	case ACIParserNE:
		{
			p.SetState(294)
			p.NotEqualTo()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(297)
		p.Match(ACIParserDQUOTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(298)
		p.LDAPFilter()
	}
	{
		p.SetState(299)
		p.Match(ACIParserDQUOTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(300)
		p.Match(ACIParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetAttrFiltersContext is an interface to support dynamic dispatch.
type ITargetAttrFiltersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTargetAttrFiltersContext differentiates from other interfaces.
	IsTargetAttrFiltersContext()
}

type TargetAttrFiltersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetAttrFiltersContext() *TargetAttrFiltersContext {
	var p = new(TargetAttrFiltersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetAttrFilters
	return p
}

func InitEmptyTargetAttrFiltersContext(p *TargetAttrFiltersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetAttrFilters
}

func (*TargetAttrFiltersContext) IsTargetAttrFiltersContext() {}

func NewTargetAttrFiltersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetAttrFiltersContext {
	var p = new(TargetAttrFiltersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_targetAttrFilters

	return p
}

func (s *TargetAttrFiltersContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetAttrFiltersContext) CopyAll(ctx *TargetAttrFiltersContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TargetAttrFiltersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetAttrFiltersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Targattrfilters_ruleContext struct {
	TargetAttrFiltersContext
}

func NewTargattrfilters_ruleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Targattrfilters_ruleContext {
	var p = new(Targattrfilters_ruleContext)

	InitEmptyTargetAttrFiltersContext(&p.TargetAttrFiltersContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetAttrFiltersContext))

	return p
}

func (s *Targattrfilters_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Targattrfilters_ruleContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Targattrfilters_ruleContext) TARGET_ATTR_FILTERS() antlr.TerminalNode {
	return s.GetToken(ACIParserTARGET_ATTR_FILTERS, 0)
}

func (s *Targattrfilters_ruleContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Targattrfilters_ruleContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Targattrfilters_ruleContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Targattrfilters_ruleContext) TargetAttrFiltersValue() ITargetAttrFiltersValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetAttrFiltersValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetAttrFiltersValueContext)
}

func (s *Targattrfilters_ruleContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Targattrfilters_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterTargattrfilters_rule(s)
	}
}

func (s *Targattrfilters_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitTargattrfilters_rule(s)
	}
}

func (p *ACIParser) TargetAttrFilters() (localctx ITargetAttrFiltersContext) {
	localctx = NewTargetAttrFiltersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ACIParserRULE_targetAttrFilters)
	localctx = NewTargattrfilters_ruleContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(302)
		p.Match(ACIParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(303)
		p.Match(ACIParserTARGET_ATTR_FILTERS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(304)
		p.EqualTo()
	}
	{
		p.SetState(305)
		p.Match(ACIParserDQUOTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(306)
		p.TargetAttrFiltersValue()
	}
	{
		p.SetState(307)
		p.Match(ACIParserDQUOTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(308)
		p.Match(ACIParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetScopeContext is an interface to support dynamic dispatch.
type ITargetScopeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTargetScopeContext differentiates from other interfaces.
	IsTargetScopeContext()
}

type TargetScopeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetScopeContext() *TargetScopeContext {
	var p = new(TargetScopeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetScope
	return p
}

func InitEmptyTargetScopeContext(p *TargetScopeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetScope
}

func (*TargetScopeContext) IsTargetScopeContext() {}

func NewTargetScopeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetScopeContext {
	var p = new(TargetScopeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_targetScope

	return p
}

func (s *TargetScopeContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetScopeContext) CopyAll(ctx *TargetScopeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TargetScopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetScopeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Targetscope_ruleContext struct {
	TargetScopeContext
}

func NewTargetscope_ruleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Targetscope_ruleContext {
	var p = new(Targetscope_ruleContext)

	InitEmptyTargetScopeContext(&p.TargetScopeContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetScopeContext))

	return p
}

func (s *Targetscope_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Targetscope_ruleContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Targetscope_ruleContext) TARGET_SCOPE() antlr.TerminalNode {
	return s.GetToken(ACIParserTARGET_SCOPE, 0)
}

func (s *Targetscope_ruleContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Targetscope_ruleContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Targetscope_ruleContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Targetscope_ruleContext) TargetSearchScopes() ITargetSearchScopesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetSearchScopesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetSearchScopesContext)
}

func (s *Targetscope_ruleContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Targetscope_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterTargetscope_rule(s)
	}
}

func (s *Targetscope_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitTargetscope_rule(s)
	}
}

func (p *ACIParser) TargetScope() (localctx ITargetScopeContext) {
	localctx = NewTargetScopeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ACIParserRULE_targetScope)
	localctx = NewTargetscope_ruleContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(310)
		p.Match(ACIParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(311)
		p.Match(ACIParserTARGET_SCOPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(312)
		p.EqualTo()
	}
	{
		p.SetState(313)
		p.Match(ACIParserDQUOTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(314)
		p.TargetSearchScopes()
	}
	{
		p.SetState(315)
		p.Match(ACIParserDQUOTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(316)
		p.Match(ACIParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetAttributesContext is an interface to support dynamic dispatch.
type ITargetAttributesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTargetAttributesContext differentiates from other interfaces.
	IsTargetAttributesContext()
}

type TargetAttributesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetAttributesContext() *TargetAttributesContext {
	var p = new(TargetAttributesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetAttributes
	return p
}

func InitEmptyTargetAttributesContext(p *TargetAttributesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetAttributes
}

func (*TargetAttributesContext) IsTargetAttributesContext() {}

func NewTargetAttributesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetAttributesContext {
	var p = new(TargetAttributesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_targetAttributes

	return p
}

func (s *TargetAttributesContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetAttributesContext) CopyAll(ctx *TargetAttributesContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TargetAttributesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetAttributesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Targetattr_ruleContext struct {
	TargetAttributesContext
}

func NewTargetattr_ruleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Targetattr_ruleContext {
	var p = new(Targetattr_ruleContext)

	InitEmptyTargetAttributesContext(&p.TargetAttributesContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetAttributesContext))

	return p
}

func (s *Targetattr_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Targetattr_ruleContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Targetattr_ruleContext) TARGET_ATTR() antlr.TerminalNode {
	return s.GetToken(ACIParserTARGET_ATTR, 0)
}

func (s *Targetattr_ruleContext) TargetedAttributes() ITargetedAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetedAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetedAttributesContext)
}

func (s *Targetattr_ruleContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Targetattr_ruleContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Targetattr_ruleContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Targetattr_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterTargetattr_rule(s)
	}
}

func (s *Targetattr_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitTargetattr_rule(s)
	}
}

func (p *ACIParser) TargetAttributes() (localctx ITargetAttributesContext) {
	localctx = NewTargetAttributesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ACIParserRULE_targetAttributes)
	localctx = NewTargetattr_ruleContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(318)
		p.Match(ACIParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(319)
		p.Match(ACIParserTARGET_ATTR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(322)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserEQ:
		{
			p.SetState(320)
			p.EqualTo()
		}

	case ACIParserNE:
		{
			p.SetState(321)
			p.NotEqualTo()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(324)
		p.TargetedAttributes()
	}
	{
		p.SetState(325)
		p.Match(ACIParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetControlContext is an interface to support dynamic dispatch.
type ITargetControlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTargetControlContext differentiates from other interfaces.
	IsTargetControlContext()
}

type TargetControlContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetControlContext() *TargetControlContext {
	var p = new(TargetControlContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetControl
	return p
}

func InitEmptyTargetControlContext(p *TargetControlContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetControl
}

func (*TargetControlContext) IsTargetControlContext() {}

func NewTargetControlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetControlContext {
	var p = new(TargetControlContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_targetControl

	return p
}

func (s *TargetControlContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetControlContext) CopyAll(ctx *TargetControlContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TargetControlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetControlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Targetcontrol_ruleContext struct {
	TargetControlContext
}

func NewTargetcontrol_ruleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Targetcontrol_ruleContext {
	var p = new(Targetcontrol_ruleContext)

	InitEmptyTargetControlContext(&p.TargetControlContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetControlContext))

	return p
}

func (s *Targetcontrol_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Targetcontrol_ruleContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Targetcontrol_ruleContext) TARGET_CONTROL() antlr.TerminalNode {
	return s.GetToken(ACIParserTARGET_CONTROL, 0)
}

func (s *Targetcontrol_ruleContext) ObjectIdentifiers() IObjectIdentifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectIdentifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectIdentifiersContext)
}

func (s *Targetcontrol_ruleContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Targetcontrol_ruleContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Targetcontrol_ruleContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Targetcontrol_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterTargetcontrol_rule(s)
	}
}

func (s *Targetcontrol_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitTargetcontrol_rule(s)
	}
}

func (p *ACIParser) TargetControl() (localctx ITargetControlContext) {
	localctx = NewTargetControlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ACIParserRULE_targetControl)
	localctx = NewTargetcontrol_ruleContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(327)
		p.Match(ACIParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(328)
		p.Match(ACIParserTARGET_CONTROL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(331)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserEQ:
		{
			p.SetState(329)
			p.EqualTo()
		}

	case ACIParserNE:
		{
			p.SetState(330)
			p.NotEqualTo()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(333)
		p.ObjectIdentifiers()
	}
	{
		p.SetState(334)
		p.Match(ACIParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetExtendedOperationContext is an interface to support dynamic dispatch.
type ITargetExtendedOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTargetExtendedOperationContext differentiates from other interfaces.
	IsTargetExtendedOperationContext()
}

type TargetExtendedOperationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetExtendedOperationContext() *TargetExtendedOperationContext {
	var p = new(TargetExtendedOperationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetExtendedOperation
	return p
}

func InitEmptyTargetExtendedOperationContext(p *TargetExtendedOperationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetExtendedOperation
}

func (*TargetExtendedOperationContext) IsTargetExtendedOperationContext() {}

func NewTargetExtendedOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetExtendedOperationContext {
	var p = new(TargetExtendedOperationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_targetExtendedOperation

	return p
}

func (s *TargetExtendedOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetExtendedOperationContext) CopyAll(ctx *TargetExtendedOperationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TargetExtendedOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetExtendedOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Targetextop_ruleContext struct {
	TargetExtendedOperationContext
}

func NewTargetextop_ruleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Targetextop_ruleContext {
	var p = new(Targetextop_ruleContext)

	InitEmptyTargetExtendedOperationContext(&p.TargetExtendedOperationContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetExtendedOperationContext))

	return p
}

func (s *Targetextop_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Targetextop_ruleContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Targetextop_ruleContext) TARGET_EXTENDED_OPERATION() antlr.TerminalNode {
	return s.GetToken(ACIParserTARGET_EXTENDED_OPERATION, 0)
}

func (s *Targetextop_ruleContext) ObjectIdentifiers() IObjectIdentifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectIdentifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectIdentifiersContext)
}

func (s *Targetextop_ruleContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Targetextop_ruleContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Targetextop_ruleContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Targetextop_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterTargetextop_rule(s)
	}
}

func (s *Targetextop_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitTargetextop_rule(s)
	}
}

func (p *ACIParser) TargetExtendedOperation() (localctx ITargetExtendedOperationContext) {
	localctx = NewTargetExtendedOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ACIParserRULE_targetExtendedOperation)
	localctx = NewTargetextop_ruleContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(336)
		p.Match(ACIParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(337)
		p.Match(ACIParserTARGET_EXTENDED_OPERATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(340)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserEQ:
		{
			p.SetState(338)
			p.EqualTo()
		}

	case ACIParserNE:
		{
			p.SetState(339)
			p.NotEqualTo()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(342)
		p.ObjectIdentifiers()
	}
	{
		p.SetState(343)
		p.Match(ACIParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetSearchScopesContext is an interface to support dynamic dispatch.
type ITargetSearchScopesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTargetSearchScopesContext differentiates from other interfaces.
	IsTargetSearchScopesContext()
}

type TargetSearchScopesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetSearchScopesContext() *TargetSearchScopesContext {
	var p = new(TargetSearchScopesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetSearchScopes
	return p
}

func InitEmptyTargetSearchScopesContext(p *TargetSearchScopesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetSearchScopes
}

func (*TargetSearchScopesContext) IsTargetSearchScopesContext() {}

func NewTargetSearchScopesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetSearchScopesContext {
	var p = new(TargetSearchScopesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_targetSearchScopes

	return p
}

func (s *TargetSearchScopesContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetSearchScopesContext) CopyAll(ctx *TargetSearchScopesContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TargetSearchScopesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetSearchScopesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Base_object_targetscopeContext struct {
	TargetSearchScopesContext
}

func NewBase_object_targetscopeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Base_object_targetscopeContext {
	var p = new(Base_object_targetscopeContext)

	InitEmptyTargetSearchScopesContext(&p.TargetSearchScopesContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetSearchScopesContext))

	return p
}

func (s *Base_object_targetscopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Base_object_targetscopeContext) BASE_OBJECT_SCOPE() antlr.TerminalNode {
	return s.GetToken(ACIParserBASE_OBJECT_SCOPE, 0)
}

func (s *Base_object_targetscopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterBase_object_targetscope(s)
	}
}

func (s *Base_object_targetscopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitBase_object_targetscope(s)
	}
}

type Sub_tree_targetscopeContext struct {
	TargetSearchScopesContext
}

func NewSub_tree_targetscopeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Sub_tree_targetscopeContext {
	var p = new(Sub_tree_targetscopeContext)

	InitEmptyTargetSearchScopesContext(&p.TargetSearchScopesContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetSearchScopesContext))

	return p
}

func (s *Sub_tree_targetscopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sub_tree_targetscopeContext) SUB_TREE_TARGET_SCOPE() antlr.TerminalNode {
	return s.GetToken(ACIParserSUB_TREE_TARGET_SCOPE, 0)
}

func (s *Sub_tree_targetscopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSub_tree_targetscope(s)
	}
}

func (s *Sub_tree_targetscopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSub_tree_targetscope(s)
	}
}

type Subordinate_targetscopeContext struct {
	TargetSearchScopesContext
}

func NewSubordinate_targetscopeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Subordinate_targetscopeContext {
	var p = new(Subordinate_targetscopeContext)

	InitEmptyTargetSearchScopesContext(&p.TargetSearchScopesContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetSearchScopesContext))

	return p
}

func (s *Subordinate_targetscopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subordinate_targetscopeContext) SUBORDINATE_TARGET_SCOPE() antlr.TerminalNode {
	return s.GetToken(ACIParserSUBORDINATE_TARGET_SCOPE, 0)
}

func (s *Subordinate_targetscopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSubordinate_targetscope(s)
	}
}

func (s *Subordinate_targetscopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSubordinate_targetscope(s)
	}
}

type One_level_targetscopeContext struct {
	TargetSearchScopesContext
}

func NewOne_level_targetscopeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *One_level_targetscopeContext {
	var p = new(One_level_targetscopeContext)

	InitEmptyTargetSearchScopesContext(&p.TargetSearchScopesContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetSearchScopesContext))

	return p
}

func (s *One_level_targetscopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *One_level_targetscopeContext) ONE_LEVEL_TARGET_SCOPE() antlr.TerminalNode {
	return s.GetToken(ACIParserONE_LEVEL_TARGET_SCOPE, 0)
}

func (s *One_level_targetscopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterOne_level_targetscope(s)
	}
}

func (s *One_level_targetscopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitOne_level_targetscope(s)
	}
}

func (p *ACIParser) TargetSearchScopes() (localctx ITargetSearchScopesContext) {
	localctx = NewTargetSearchScopesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ACIParserRULE_targetSearchScopes)
	p.SetState(349)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserBASE_OBJECT_SCOPE:
		localctx = NewBase_object_targetscopeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(345)
			p.Match(ACIParserBASE_OBJECT_SCOPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserONE_LEVEL_TARGET_SCOPE:
		localctx = NewOne_level_targetscopeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(346)
			p.Match(ACIParserONE_LEVEL_TARGET_SCOPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserSUB_TREE_TARGET_SCOPE:
		localctx = NewSub_tree_targetscopeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(347)
			p.Match(ACIParserSUB_TREE_TARGET_SCOPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserSUBORDINATE_TARGET_SCOPE:
		localctx = NewSubordinate_targetscopeContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(348)
			p.Match(ACIParserSUBORDINATE_TARGET_SCOPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectIdentifiersContext is an interface to support dynamic dispatch.
type IObjectIdentifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsObjectIdentifiersContext differentiates from other interfaces.
	IsObjectIdentifiersContext()
}

type ObjectIdentifiersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectIdentifiersContext() *ObjectIdentifiersContext {
	var p = new(ObjectIdentifiersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_objectIdentifiers
	return p
}

func InitEmptyObjectIdentifiersContext(p *ObjectIdentifiersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_objectIdentifiers
}

func (*ObjectIdentifiersContext) IsObjectIdentifiersContext() {}

func NewObjectIdentifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectIdentifiersContext {
	var p = new(ObjectIdentifiersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_objectIdentifiers

	return p
}

func (s *ObjectIdentifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectIdentifiersContext) CopyAll(ctx *ObjectIdentifiersContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ObjectIdentifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectIdentifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Quoted_object_identifier_listContext struct {
	ObjectIdentifiersContext
}

func NewQuoted_object_identifier_listContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Quoted_object_identifier_listContext {
	var p = new(Quoted_object_identifier_listContext)

	InitEmptyObjectIdentifiersContext(&p.ObjectIdentifiersContext)
	p.parser = parser
	p.CopyAll(ctx.(*ObjectIdentifiersContext))

	return p
}

func (s *Quoted_object_identifier_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Quoted_object_identifier_listContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Quoted_object_identifier_listContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Quoted_object_identifier_listContext) AllObjectIdentifier() []IObjectIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IObjectIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IObjectIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IObjectIdentifierContext); ok {
			tst[i] = t.(IObjectIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *Quoted_object_identifier_listContext) ObjectIdentifier(i int) IObjectIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectIdentifierContext)
}

func (s *Quoted_object_identifier_listContext) AllORDelimiter() []IORDelimiterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IORDelimiterContext); ok {
			len++
		}
	}

	tst := make([]IORDelimiterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IORDelimiterContext); ok {
			tst[i] = t.(IORDelimiterContext)
			i++
		}
	}

	return tst
}

func (s *Quoted_object_identifier_listContext) ORDelimiter(i int) IORDelimiterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IORDelimiterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IORDelimiterContext)
}

func (s *Quoted_object_identifier_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterQuoted_object_identifier_list(s)
	}
}

func (s *Quoted_object_identifier_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitQuoted_object_identifier_list(s)
	}
}

type List_of_quoted_object_identifiersContext struct {
	ObjectIdentifiersContext
}

func NewList_of_quoted_object_identifiersContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *List_of_quoted_object_identifiersContext {
	var p = new(List_of_quoted_object_identifiersContext)

	InitEmptyObjectIdentifiersContext(&p.ObjectIdentifiersContext)
	p.parser = parser
	p.CopyAll(ctx.(*ObjectIdentifiersContext))

	return p
}

func (s *List_of_quoted_object_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_quoted_object_identifiersContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *List_of_quoted_object_identifiersContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *List_of_quoted_object_identifiersContext) AllObjectIdentifier() []IObjectIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IObjectIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IObjectIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IObjectIdentifierContext); ok {
			tst[i] = t.(IObjectIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *List_of_quoted_object_identifiersContext) ObjectIdentifier(i int) IObjectIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectIdentifierContext)
}

func (s *List_of_quoted_object_identifiersContext) AllORDelimiter() []IORDelimiterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IORDelimiterContext); ok {
			len++
		}
	}

	tst := make([]IORDelimiterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IORDelimiterContext); ok {
			tst[i] = t.(IORDelimiterContext)
			i++
		}
	}

	return tst
}

func (s *List_of_quoted_object_identifiersContext) ORDelimiter(i int) IORDelimiterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IORDelimiterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IORDelimiterContext)
}

func (s *List_of_quoted_object_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterList_of_quoted_object_identifiers(s)
	}
}

func (s *List_of_quoted_object_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitList_of_quoted_object_identifiers(s)
	}
}

func (p *ACIParser) ObjectIdentifiers() (localctx IObjectIdentifiersContext) {
	localctx = NewObjectIdentifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ACIParserRULE_objectIdentifiers)
	var _la int

	p.SetState(376)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) {
	case 1:
		localctx = NewQuoted_object_identifier_listContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(351)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(352)
			p.ObjectIdentifier()
		}
		p.SetState(358)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ACIParserSYMBOLIC_OR {
			{
				p.SetState(353)
				p.ORDelimiter()
			}
			{
				p.SetState(354)
				p.ObjectIdentifier()
			}

			p.SetState(360)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

		{
			p.SetState(361)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewList_of_quoted_object_identifiersContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(363)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(364)
			p.ObjectIdentifier()
		}
		{
			p.SetState(365)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(373)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ACIParserSYMBOLIC_OR {
			{
				p.SetState(366)
				p.ORDelimiter()
			}

			{
				p.SetState(367)
				p.Match(ACIParserDQUOTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(368)
				p.ObjectIdentifier()
			}
			{
				p.SetState(369)
				p.Match(ACIParserDQUOTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(375)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetedAttributesContext is an interface to support dynamic dispatch.
type ITargetedAttributesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTargetedAttributesContext differentiates from other interfaces.
	IsTargetedAttributesContext()
}

type TargetedAttributesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetedAttributesContext() *TargetedAttributesContext {
	var p = new(TargetedAttributesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetedAttributes
	return p
}

func InitEmptyTargetedAttributesContext(p *TargetedAttributesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetedAttributes
}

func (*TargetedAttributesContext) IsTargetedAttributesContext() {}

func NewTargetedAttributesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetedAttributesContext {
	var p = new(TargetedAttributesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_targetedAttributes

	return p
}

func (s *TargetedAttributesContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetedAttributesContext) CopyAll(ctx *TargetedAttributesContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TargetedAttributesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetedAttributesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type List_of_quoted_attributesContext struct {
	TargetedAttributesContext
}

func NewList_of_quoted_attributesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *List_of_quoted_attributesContext {
	var p = new(List_of_quoted_attributesContext)

	InitEmptyTargetedAttributesContext(&p.TargetedAttributesContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetedAttributesContext))

	return p
}

func (s *List_of_quoted_attributesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_quoted_attributesContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *List_of_quoted_attributesContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *List_of_quoted_attributesContext) AllAttributeTypeOrValue() []IAttributeTypeOrValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			len++
		}
	}

	tst := make([]IAttributeTypeOrValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeTypeOrValueContext); ok {
			tst[i] = t.(IAttributeTypeOrValueContext)
			i++
		}
	}

	return tst
}

func (s *List_of_quoted_attributesContext) AttributeTypeOrValue(i int) IAttributeTypeOrValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeTypeOrValueContext)
}

func (s *List_of_quoted_attributesContext) AllORDelimiter() []IORDelimiterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IORDelimiterContext); ok {
			len++
		}
	}

	tst := make([]IORDelimiterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IORDelimiterContext); ok {
			tst[i] = t.(IORDelimiterContext)
			i++
		}
	}

	return tst
}

func (s *List_of_quoted_attributesContext) ORDelimiter(i int) IORDelimiterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IORDelimiterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IORDelimiterContext)
}

func (s *List_of_quoted_attributesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterList_of_quoted_attributes(s)
	}
}

func (s *List_of_quoted_attributesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitList_of_quoted_attributes(s)
	}
}

type Quoted_targeted_attributes_listContext struct {
	TargetedAttributesContext
}

func NewQuoted_targeted_attributes_listContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Quoted_targeted_attributes_listContext {
	var p = new(Quoted_targeted_attributes_listContext)

	InitEmptyTargetedAttributesContext(&p.TargetedAttributesContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetedAttributesContext))

	return p
}

func (s *Quoted_targeted_attributes_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Quoted_targeted_attributes_listContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Quoted_targeted_attributes_listContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Quoted_targeted_attributes_listContext) AllAttributeTypeOrValue() []IAttributeTypeOrValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			len++
		}
	}

	tst := make([]IAttributeTypeOrValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeTypeOrValueContext); ok {
			tst[i] = t.(IAttributeTypeOrValueContext)
			i++
		}
	}

	return tst
}

func (s *Quoted_targeted_attributes_listContext) AttributeTypeOrValue(i int) IAttributeTypeOrValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeTypeOrValueContext)
}

func (s *Quoted_targeted_attributes_listContext) AllORDelimiter() []IORDelimiterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IORDelimiterContext); ok {
			len++
		}
	}

	tst := make([]IORDelimiterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IORDelimiterContext); ok {
			tst[i] = t.(IORDelimiterContext)
			i++
		}
	}

	return tst
}

func (s *Quoted_targeted_attributes_listContext) ORDelimiter(i int) IORDelimiterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IORDelimiterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IORDelimiterContext)
}

func (s *Quoted_targeted_attributes_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterQuoted_targeted_attributes_list(s)
	}
}

func (s *Quoted_targeted_attributes_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitQuoted_targeted_attributes_list(s)
	}
}

func (p *ACIParser) TargetedAttributes() (localctx ITargetedAttributesContext) {
	localctx = NewTargetedAttributesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ACIParserRULE_targetedAttributes)
	var _la int

	p.SetState(403)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext()) {
	case 1:
		localctx = NewQuoted_targeted_attributes_listContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(378)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(379)
			p.AttributeTypeOrValue()
		}
		p.SetState(385)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ACIParserSYMBOLIC_OR {
			{
				p.SetState(380)
				p.ORDelimiter()
			}
			{
				p.SetState(381)
				p.AttributeTypeOrValue()
			}

			p.SetState(387)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

		{
			p.SetState(388)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewList_of_quoted_attributesContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(390)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(391)
			p.AttributeTypeOrValue()
		}
		{
			p.SetState(392)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(400)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ACIParserSYMBOLIC_OR {
			{
				p.SetState(393)
				p.ORDelimiter()
			}

			{
				p.SetState(394)
				p.Match(ACIParserDQUOTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(395)
				p.AttributeTypeOrValue()
			}
			{
				p.SetState(396)
				p.Match(ACIParserDQUOTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(402)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectIdentifierContext is an interface to support dynamic dispatch.
type IObjectIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsObjectIdentifierContext differentiates from other interfaces.
	IsObjectIdentifierContext()
}

type ObjectIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectIdentifierContext() *ObjectIdentifierContext {
	var p = new(ObjectIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_objectIdentifier
	return p
}

func InitEmptyObjectIdentifierContext(p *ObjectIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_objectIdentifier
}

func (*ObjectIdentifierContext) IsObjectIdentifierContext() {}

func NewObjectIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectIdentifierContext {
	var p = new(ObjectIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_objectIdentifier

	return p
}

func (s *ObjectIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectIdentifierContext) CopyAll(ctx *ObjectIdentifierContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ObjectIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Object_identifierContext struct {
	ObjectIdentifierContext
}

func NewObject_identifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Object_identifierContext {
	var p = new(Object_identifierContext)

	InitEmptyObjectIdentifierContext(&p.ObjectIdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*ObjectIdentifierContext))

	return p
}

func (s *Object_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Object_identifierContext) AllObjectIdentifierArc() []IObjectIdentifierArcContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IObjectIdentifierArcContext); ok {
			len++
		}
	}

	tst := make([]IObjectIdentifierArcContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IObjectIdentifierArcContext); ok {
			tst[i] = t.(IObjectIdentifierArcContext)
			i++
		}
	}

	return tst
}

func (s *Object_identifierContext) ObjectIdentifierArc(i int) IObjectIdentifierArcContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectIdentifierArcContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectIdentifierArcContext)
}

func (s *Object_identifierContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDOT)
}

func (s *Object_identifierContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDOT, i)
}

func (s *Object_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterObject_identifier(s)
	}
}

func (s *Object_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitObject_identifier(s)
	}
}

func (p *ACIParser) ObjectIdentifier() (localctx IObjectIdentifierContext) {
	localctx = NewObjectIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ACIParserRULE_objectIdentifier)
	var _la int

	localctx = NewObject_identifierContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(405)
		p.ObjectIdentifierArc()
	}
	p.SetState(408)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ACIParserDOT {
		{
			p.SetState(406)
			p.Match(ACIParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(407)
			p.ObjectIdentifierArc()
		}

		p.SetState(410)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectIdentifierArcContext is an interface to support dynamic dispatch.
type IObjectIdentifierArcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsObjectIdentifierArcContext differentiates from other interfaces.
	IsObjectIdentifierArcContext()
}

type ObjectIdentifierArcContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectIdentifierArcContext() *ObjectIdentifierArcContext {
	var p = new(ObjectIdentifierArcContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_objectIdentifierArc
	return p
}

func InitEmptyObjectIdentifierArcContext(p *ObjectIdentifierArcContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_objectIdentifierArc
}

func (*ObjectIdentifierArcContext) IsObjectIdentifierArcContext() {}

func NewObjectIdentifierArcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectIdentifierArcContext {
	var p = new(ObjectIdentifierArcContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_objectIdentifierArc

	return p
}

func (s *ObjectIdentifierArcContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectIdentifierArcContext) CopyAll(ctx *ObjectIdentifierArcContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ObjectIdentifierArcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectIdentifierArcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Number_formContext struct {
	ObjectIdentifierArcContext
}

func NewNumber_formContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Number_formContext {
	var p = new(Number_formContext)

	InitEmptyObjectIdentifierArcContext(&p.ObjectIdentifierArcContext)
	p.parser = parser
	p.CopyAll(ctx.(*ObjectIdentifierArcContext))

	return p
}

func (s *Number_formContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Number_formContext) INT() antlr.TerminalNode {
	return s.GetToken(ACIParserINT, 0)
}

func (s *Number_formContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterNumber_form(s)
	}
}

func (s *Number_formContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitNumber_form(s)
	}
}

func (p *ACIParser) ObjectIdentifierArc() (localctx IObjectIdentifierArcContext) {
	localctx = NewObjectIdentifierArcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ACIParserRULE_objectIdentifierArc)
	localctx = NewNumber_formContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(412)
		p.Match(ACIParserINT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetAttrFiltersValueContext is an interface to support dynamic dispatch.
type ITargetAttrFiltersValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTargetAttrFiltersValueContext differentiates from other interfaces.
	IsTargetAttrFiltersValueContext()
}

type TargetAttrFiltersValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetAttrFiltersValueContext() *TargetAttrFiltersValueContext {
	var p = new(TargetAttrFiltersValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetAttrFiltersValue
	return p
}

func InitEmptyTargetAttrFiltersValueContext(p *TargetAttrFiltersValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetAttrFiltersValue
}

func (*TargetAttrFiltersValueContext) IsTargetAttrFiltersValueContext() {}

func NewTargetAttrFiltersValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetAttrFiltersValueContext {
	var p = new(TargetAttrFiltersValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_targetAttrFiltersValue

	return p
}

func (s *TargetAttrFiltersValueContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetAttrFiltersValueContext) CopyAll(ctx *TargetAttrFiltersValueContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TargetAttrFiltersValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetAttrFiltersValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Attribute_filter_singleContext struct {
	TargetAttrFiltersValueContext
}

func NewAttribute_filter_singleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Attribute_filter_singleContext {
	var p = new(Attribute_filter_singleContext)

	InitEmptyTargetAttrFiltersValueContext(&p.TargetAttrFiltersValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetAttrFiltersValueContext))

	return p
}

func (s *Attribute_filter_singleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_filter_singleContext) AttributeFilter() IAttributeFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeFilterContext)
}

func (s *Attribute_filter_singleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAttribute_filter_single(s)
	}
}

func (s *Attribute_filter_singleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAttribute_filter_single(s)
	}
}

type Attribute_filters_setsContext struct {
	TargetAttrFiltersValueContext
}

func NewAttribute_filters_setsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Attribute_filters_setsContext {
	var p = new(Attribute_filters_setsContext)

	InitEmptyTargetAttrFiltersValueContext(&p.TargetAttrFiltersValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetAttrFiltersValueContext))

	return p
}

func (s *Attribute_filters_setsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_filters_setsContext) AttributeFilters() IAttributeFiltersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeFiltersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeFiltersContext)
}

func (s *Attribute_filters_setsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAttribute_filters_sets(s)
	}
}

func (s *Attribute_filters_setsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAttribute_filters_sets(s)
	}
}

type Attribute_filters_setContext struct {
	TargetAttrFiltersValueContext
}

func NewAttribute_filters_setContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Attribute_filters_setContext {
	var p = new(Attribute_filters_setContext)

	InitEmptyTargetAttrFiltersValueContext(&p.TargetAttrFiltersValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetAttrFiltersValueContext))

	return p
}

func (s *Attribute_filters_setContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_filters_setContext) AttributeFilterSet() IAttributeFilterSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeFilterSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeFilterSetContext)
}

func (s *Attribute_filters_setContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAttribute_filters_set(s)
	}
}

func (s *Attribute_filters_setContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAttribute_filters_set(s)
	}
}

func (p *ACIParser) TargetAttrFiltersValue() (localctx ITargetAttrFiltersValueContext) {
	localctx = NewTargetAttrFiltersValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ACIParserRULE_targetAttrFiltersValue)
	p.SetState(417)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAttribute_filters_setsContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(414)
			p.AttributeFilters()
		}

	case 2:
		localctx = NewAttribute_filters_setContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(415)
			p.AttributeFilterSet()
		}

	case 3:
		localctx = NewAttribute_filter_singleContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(416)
			p.AttributeFilter()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeFiltersContext is an interface to support dynamic dispatch.
type IAttributeFiltersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAttributeFiltersContext differentiates from other interfaces.
	IsAttributeFiltersContext()
}

type AttributeFiltersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeFiltersContext() *AttributeFiltersContext {
	var p = new(AttributeFiltersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_attributeFilters
	return p
}

func InitEmptyAttributeFiltersContext(p *AttributeFiltersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_attributeFilters
}

func (*AttributeFiltersContext) IsAttributeFiltersContext() {}

func NewAttributeFiltersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeFiltersContext {
	var p = new(AttributeFiltersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_attributeFilters

	return p
}

func (s *AttributeFiltersContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeFiltersContext) CopyAll(ctx *AttributeFiltersContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AttributeFiltersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeFiltersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Attribute_filtersContext struct {
	AttributeFiltersContext
}

func NewAttribute_filtersContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Attribute_filtersContext {
	var p = new(Attribute_filtersContext)

	InitEmptyAttributeFiltersContext(&p.AttributeFiltersContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeFiltersContext))

	return p
}

func (s *Attribute_filtersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_filtersContext) AllAttributeFilterSet() []IAttributeFilterSetContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeFilterSetContext); ok {
			len++
		}
	}

	tst := make([]IAttributeFilterSetContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeFilterSetContext); ok {
			tst[i] = t.(IAttributeFilterSetContext)
			i++
		}
	}

	return tst
}

func (s *Attribute_filtersContext) AttributeFilterSet(i int) IAttributeFilterSetContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeFilterSetContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeFilterSetContext)
}

func (s *Attribute_filtersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ACIParserCOMMA)
}

func (s *Attribute_filtersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserCOMMA, i)
}

func (s *Attribute_filtersContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(ACIParserSEMI)
}

func (s *Attribute_filtersContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserSEMI, i)
}

func (s *Attribute_filtersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAttribute_filters(s)
	}
}

func (s *Attribute_filtersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAttribute_filters(s)
	}
}

func (p *ACIParser) AttributeFilters() (localctx IAttributeFiltersContext) {
	localctx = NewAttributeFiltersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ACIParserRULE_attributeFilters)
	var _la int

	var _alt int

	localctx = NewAttribute_filtersContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(419)
		p.AttributeFilterSet()
	}
	p.SetState(422)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1 + 1
	for ok := true; ok; ok = _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1 + 1:
			{
				p.SetState(420)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ACIParserCOMMA || _la == ACIParserSEMI) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(421)
				p.AttributeFilterSet()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(424)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeFilterSetContext is an interface to support dynamic dispatch.
type IAttributeFilterSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAttributeFilterSetContext differentiates from other interfaces.
	IsAttributeFilterSetContext()
}

type AttributeFilterSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeFilterSetContext() *AttributeFilterSetContext {
	var p = new(AttributeFilterSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_attributeFilterSet
	return p
}

func InitEmptyAttributeFilterSetContext(p *AttributeFilterSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_attributeFilterSet
}

func (*AttributeFilterSetContext) IsAttributeFilterSetContext() {}

func NewAttributeFilterSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeFilterSetContext {
	var p = new(AttributeFilterSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_attributeFilterSet

	return p
}

func (s *AttributeFilterSetContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeFilterSetContext) CopyAll(ctx *AttributeFilterSetContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AttributeFilterSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeFilterSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Attribute_filter_setContext struct {
	AttributeFilterSetContext
}

func NewAttribute_filter_setContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Attribute_filter_setContext {
	var p = new(Attribute_filter_setContext)

	InitEmptyAttributeFilterSetContext(&p.AttributeFilterSetContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeFilterSetContext))

	return p
}

func (s *Attribute_filter_setContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_filter_setContext) AttributeFilterOperation() IAttributeFilterOperationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeFilterOperationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeFilterOperationContext)
}

func (s *Attribute_filter_setContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Attribute_filter_setContext) AllAttributeFilter() []IAttributeFilterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeFilterContext); ok {
			len++
		}
	}

	tst := make([]IAttributeFilterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeFilterContext); ok {
			tst[i] = t.(IAttributeFilterContext)
			i++
		}
	}

	return tst
}

func (s *Attribute_filter_setContext) AttributeFilter(i int) IAttributeFilterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeFilterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeFilterContext)
}

func (s *Attribute_filter_setContext) AllANDDelimiter() []IANDDelimiterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IANDDelimiterContext); ok {
			len++
		}
	}

	tst := make([]IANDDelimiterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IANDDelimiterContext); ok {
			tst[i] = t.(IANDDelimiterContext)
			i++
		}
	}

	return tst
}

func (s *Attribute_filter_setContext) ANDDelimiter(i int) IANDDelimiterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IANDDelimiterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IANDDelimiterContext)
}

func (s *Attribute_filter_setContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAttribute_filter_set(s)
	}
}

func (s *Attribute_filter_setContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAttribute_filter_set(s)
	}
}

func (p *ACIParser) AttributeFilterSet() (localctx IAttributeFilterSetContext) {
	localctx = NewAttributeFilterSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ACIParserRULE_attributeFilterSet)
	var _la int

	localctx = NewAttribute_filter_setContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(426)
		p.AttributeFilterOperation()
	}
	{
		p.SetState(427)
		p.EqualTo()
	}
	p.SetState(437)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ACIParserKEY_OR_VALUE {
		{
			p.SetState(428)
			p.AttributeFilter()
		}
		p.SetState(434)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ACIParserSYMBOLIC_AND {
			{
				p.SetState(429)
				p.ANDDelimiter()
			}
			{
				p.SetState(430)
				p.AttributeFilter()
			}

			p.SetState(436)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeFilterOperationContext is an interface to support dynamic dispatch.
type IAttributeFilterOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAttributeFilterOperationContext differentiates from other interfaces.
	IsAttributeFilterOperationContext()
}

type AttributeFilterOperationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeFilterOperationContext() *AttributeFilterOperationContext {
	var p = new(AttributeFilterOperationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_attributeFilterOperation
	return p
}

func InitEmptyAttributeFilterOperationContext(p *AttributeFilterOperationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_attributeFilterOperation
}

func (*AttributeFilterOperationContext) IsAttributeFilterOperationContext() {}

func NewAttributeFilterOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeFilterOperationContext {
	var p = new(AttributeFilterOperationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_attributeFilterOperation

	return p
}

func (s *AttributeFilterOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeFilterOperationContext) CopyAll(ctx *AttributeFilterOperationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AttributeFilterOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeFilterOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Add_filter_operationContext struct {
	AttributeFilterOperationContext
}

func NewAdd_filter_operationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Add_filter_operationContext {
	var p = new(Add_filter_operationContext)

	InitEmptyAttributeFilterOperationContext(&p.AttributeFilterOperationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeFilterOperationContext))

	return p
}

func (s *Add_filter_operationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Add_filter_operationContext) ADD_PRIVILEGE() antlr.TerminalNode {
	return s.GetToken(ACIParserADD_PRIVILEGE, 0)
}

func (s *Add_filter_operationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAdd_filter_operation(s)
	}
}

func (s *Add_filter_operationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAdd_filter_operation(s)
	}
}

type Delete_filter_operationContext struct {
	AttributeFilterOperationContext
}

func NewDelete_filter_operationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Delete_filter_operationContext {
	var p = new(Delete_filter_operationContext)

	InitEmptyAttributeFilterOperationContext(&p.AttributeFilterOperationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeFilterOperationContext))

	return p
}

func (s *Delete_filter_operationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delete_filter_operationContext) DELETE_PRIVILEGE() antlr.TerminalNode {
	return s.GetToken(ACIParserDELETE_PRIVILEGE, 0)
}

func (s *Delete_filter_operationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterDelete_filter_operation(s)
	}
}

func (s *Delete_filter_operationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitDelete_filter_operation(s)
	}
}

func (p *ACIParser) AttributeFilterOperation() (localctx IAttributeFilterOperationContext) {
	localctx = NewAttributeFilterOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ACIParserRULE_attributeFilterOperation)
	p.SetState(441)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserADD_PRIVILEGE:
		localctx = NewAdd_filter_operationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(439)
			p.Match(ACIParserADD_PRIVILEGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserDELETE_PRIVILEGE:
		localctx = NewDelete_filter_operationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(440)
			p.Match(ACIParserDELETE_PRIVILEGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeFilterContext is an interface to support dynamic dispatch.
type IAttributeFilterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAttributeFilterContext differentiates from other interfaces.
	IsAttributeFilterContext()
}

type AttributeFilterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeFilterContext() *AttributeFilterContext {
	var p = new(AttributeFilterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_attributeFilter
	return p
}

func InitEmptyAttributeFilterContext(p *AttributeFilterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_attributeFilter
}

func (*AttributeFilterContext) IsAttributeFilterContext() {}

func NewAttributeFilterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeFilterContext {
	var p = new(AttributeFilterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_attributeFilter

	return p
}

func (s *AttributeFilterContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeFilterContext) CopyAll(ctx *AttributeFilterContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AttributeFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeFilterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Attribute_filterContext struct {
	AttributeFilterContext
}

func NewAttribute_filterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Attribute_filterContext {
	var p = new(Attribute_filterContext)

	InitEmptyAttributeFilterContext(&p.AttributeFilterContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeFilterContext))

	return p
}

func (s *Attribute_filterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_filterContext) AttributeTypeOrValue() IAttributeTypeOrValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeTypeOrValueContext)
}

func (s *Attribute_filterContext) COLON() antlr.TerminalNode {
	return s.GetToken(ACIParserCOLON, 0)
}

func (s *Attribute_filterContext) LDAPFilter() ILDAPFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILDAPFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILDAPFilterContext)
}

func (s *Attribute_filterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAttribute_filter(s)
	}
}

func (s *Attribute_filterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAttribute_filter(s)
	}
}

func (p *ACIParser) AttributeFilter() (localctx IAttributeFilterContext) {
	localctx = NewAttributeFilterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, ACIParserRULE_attributeFilter)
	localctx = NewAttribute_filterContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(443)
		p.AttributeTypeOrValue()
	}
	{
		p.SetState(444)
		p.Match(ACIParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(445)
		p.LDAPFilter()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindRuleContext is an interface to support dynamic dispatch.
type IBindRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBindRuleContext differentiates from other interfaces.
	IsBindRuleContext()
}

type BindRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindRuleContext() *BindRuleContext {
	var p = new(BindRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindRule
	return p
}

func InitEmptyBindRuleContext(p *BindRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindRule
}

func (*BindRuleContext) IsBindRuleContext() {}

func NewBindRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindRuleContext {
	var p = new(BindRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_bindRule

	return p
}

func (s *BindRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *BindRuleContext) CopyAll(ctx *BindRuleContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BindRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Parenthetical_bind_ruleContext struct {
	BindRuleContext
}

func NewParenthetical_bind_ruleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_bind_ruleContext {
	var p = new(Parenthetical_bind_ruleContext)

	InitEmptyBindRuleContext(&p.BindRuleContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleContext))

	return p
}

func (s *Parenthetical_bind_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_bind_ruleContext) AllBindRuleExprParen() []IBindRuleExprParenContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBindRuleExprParenContext); ok {
			len++
		}
	}

	tst := make([]IBindRuleExprParenContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBindRuleExprParenContext); ok {
			tst[i] = t.(IBindRuleExprParenContext)
			i++
		}
	}

	return tst
}

func (s *Parenthetical_bind_ruleContext) BindRuleExprParen(i int) IBindRuleExprParenContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindRuleExprParenContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindRuleExprParenContext)
}

func (s *Parenthetical_bind_ruleContext) AllBOOLEAN_AND() []antlr.TerminalNode {
	return s.GetTokens(ACIParserBOOLEAN_AND)
}

func (s *Parenthetical_bind_ruleContext) BOOLEAN_AND(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserBOOLEAN_AND, i)
}

func (s *Parenthetical_bind_ruleContext) AllBOOLEAN_OR() []antlr.TerminalNode {
	return s.GetTokens(ACIParserBOOLEAN_OR)
}

func (s *Parenthetical_bind_ruleContext) BOOLEAN_OR(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserBOOLEAN_OR, i)
}

func (s *Parenthetical_bind_ruleContext) AllBOOLEAN_NOT() []antlr.TerminalNode {
	return s.GetTokens(ACIParserBOOLEAN_NOT)
}

func (s *Parenthetical_bind_ruleContext) BOOLEAN_NOT(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserBOOLEAN_NOT, i)
}

func (s *Parenthetical_bind_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_bind_rule(s)
	}
}

func (s *Parenthetical_bind_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_bind_rule(s)
	}
}

type Bind_ruleContext struct {
	BindRuleContext
}

func NewBind_ruleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Bind_ruleContext {
	var p = new(Bind_ruleContext)

	InitEmptyBindRuleContext(&p.BindRuleContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleContext))

	return p
}

func (s *Bind_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_ruleContext) BindRuleExpr() IBindRuleExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindRuleExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindRuleExprContext)
}

func (s *Bind_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterBind_rule(s)
	}
}

func (s *Bind_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitBind_rule(s)
	}
}

func (p *ACIParser) BindRule() (localctx IBindRuleContext) {
	localctx = NewBindRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ACIParserRULE_bindRule)
	var _la int

	p.SetState(456)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext()) {
	case 1:
		localctx = NewBind_ruleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(447)
			p.BindRuleExpr()
		}

	case 2:
		localctx = NewParenthetical_bind_ruleContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(448)
			p.BindRuleExprParen()
		}
		p.SetState(453)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for (int64((_la-88)) & ^0x3f) == 0 && ((int64(1)<<(_la-88))&7) != 0 {
			{
				p.SetState(449)
				_la = p.GetTokenStream().LA(1)

				if !((int64((_la-88)) & ^0x3f) == 0 && ((int64(1)<<(_la-88))&7) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(450)
				p.BindRuleExprParen()
			}

			p.SetState(455)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindRuleExprParenContext is an interface to support dynamic dispatch.
type IBindRuleExprParenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBindRuleExprParenContext differentiates from other interfaces.
	IsBindRuleExprParenContext()
}

type BindRuleExprParenContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindRuleExprParenContext() *BindRuleExprParenContext {
	var p = new(BindRuleExprParenContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindRuleExprParen
	return p
}

func InitEmptyBindRuleExprParenContext(p *BindRuleExprParenContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindRuleExprParen
}

func (*BindRuleExprParenContext) IsBindRuleExprParenContext() {}

func NewBindRuleExprParenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindRuleExprParenContext {
	var p = new(BindRuleExprParenContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_bindRuleExprParen

	return p
}

func (s *BindRuleExprParenContext) GetParser() antlr.Parser { return s.parser }

func (s *BindRuleExprParenContext) CopyAll(ctx *BindRuleExprParenContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BindRuleExprParenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindRuleExprParenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Bind_rule_expression_recursionContext struct {
	BindRuleExprParenContext
}

func NewBind_rule_expression_recursionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Bind_rule_expression_recursionContext {
	var p = new(Bind_rule_expression_recursionContext)

	InitEmptyBindRuleExprParenContext(&p.BindRuleExprParenContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprParenContext))

	return p
}

func (s *Bind_rule_expression_recursionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_rule_expression_recursionContext) BindRuleExpr() IBindRuleExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindRuleExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindRuleExprContext)
}

func (s *Bind_rule_expression_recursionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterBind_rule_expression_recursion(s)
	}
}

func (s *Bind_rule_expression_recursionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitBind_rule_expression_recursion(s)
	}
}

type Parenthetical_bind_rule_req_bool_opContext struct {
	BindRuleExprParenContext
}

func NewParenthetical_bind_rule_req_bool_opContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_bind_rule_req_bool_opContext {
	var p = new(Parenthetical_bind_rule_req_bool_opContext)

	InitEmptyBindRuleExprParenContext(&p.BindRuleExprParenContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprParenContext))

	return p
}

func (s *Parenthetical_bind_rule_req_bool_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_bind_rule_req_bool_opContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Parenthetical_bind_rule_req_bool_opContext) AllBindRuleExpr() []IBindRuleExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBindRuleExprContext); ok {
			len++
		}
	}

	tst := make([]IBindRuleExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBindRuleExprContext); ok {
			tst[i] = t.(IBindRuleExprContext)
			i++
		}
	}

	return tst
}

func (s *Parenthetical_bind_rule_req_bool_opContext) BindRuleExpr(i int) IBindRuleExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindRuleExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindRuleExprContext)
}

func (s *Parenthetical_bind_rule_req_bool_opContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Parenthetical_bind_rule_req_bool_opContext) AllBOOLEAN_AND() []antlr.TerminalNode {
	return s.GetTokens(ACIParserBOOLEAN_AND)
}

func (s *Parenthetical_bind_rule_req_bool_opContext) BOOLEAN_AND(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserBOOLEAN_AND, i)
}

func (s *Parenthetical_bind_rule_req_bool_opContext) AllBOOLEAN_OR() []antlr.TerminalNode {
	return s.GetTokens(ACIParserBOOLEAN_OR)
}

func (s *Parenthetical_bind_rule_req_bool_opContext) BOOLEAN_OR(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserBOOLEAN_OR, i)
}

func (s *Parenthetical_bind_rule_req_bool_opContext) AllBOOLEAN_NOT() []antlr.TerminalNode {
	return s.GetTokens(ACIParserBOOLEAN_NOT)
}

func (s *Parenthetical_bind_rule_req_bool_opContext) BOOLEAN_NOT(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserBOOLEAN_NOT, i)
}

func (s *Parenthetical_bind_rule_req_bool_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_bind_rule_req_bool_op(s)
	}
}

func (s *Parenthetical_bind_rule_req_bool_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_bind_rule_req_bool_op(s)
	}
}

type Parenthetical_bind_rule_expressionContext struct {
	BindRuleExprParenContext
}

func NewParenthetical_bind_rule_expressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_bind_rule_expressionContext {
	var p = new(Parenthetical_bind_rule_expressionContext)

	InitEmptyBindRuleExprParenContext(&p.BindRuleExprParenContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprParenContext))

	return p
}

func (s *Parenthetical_bind_rule_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_bind_rule_expressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Parenthetical_bind_rule_expressionContext) BindRuleExpr() IBindRuleExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindRuleExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindRuleExprContext)
}

func (s *Parenthetical_bind_rule_expressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Parenthetical_bind_rule_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_bind_rule_expression(s)
	}
}

func (s *Parenthetical_bind_rule_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_bind_rule_expression(s)
	}
}

type Negated_bind_rule_expressionContext struct {
	BindRuleExprParenContext
}

func NewNegated_bind_rule_expressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Negated_bind_rule_expressionContext {
	var p = new(Negated_bind_rule_expressionContext)

	InitEmptyBindRuleExprParenContext(&p.BindRuleExprParenContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprParenContext))

	return p
}

func (s *Negated_bind_rule_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Negated_bind_rule_expressionContext) BOOLEAN_NOT() antlr.TerminalNode {
	return s.GetToken(ACIParserBOOLEAN_NOT, 0)
}

func (s *Negated_bind_rule_expressionContext) BindRuleExpr() IBindRuleExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindRuleExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindRuleExprContext)
}

func (s *Negated_bind_rule_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterNegated_bind_rule_expression(s)
	}
}

func (s *Negated_bind_rule_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitNegated_bind_rule_expression(s)
	}
}

func (p *ACIParser) BindRuleExprParen() (localctx IBindRuleExprParenContext) {
	localctx = NewBindRuleExprParenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ACIParserRULE_bindRuleExprParen)
	var _la int

	p.SetState(476)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext()) {
	case 1:
		localctx = NewParenthetical_bind_rule_req_bool_opContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(458)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(459)
			p.BindRuleExpr()
		}
		p.SetState(464)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for (int64((_la-88)) & ^0x3f) == 0 && ((int64(1)<<(_la-88))&7) != 0 {
			{
				p.SetState(460)
				_la = p.GetTokenStream().LA(1)

				if !((int64((_la-88)) & ^0x3f) == 0 && ((int64(1)<<(_la-88))&7) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(461)
				p.BindRuleExpr()
			}

			p.SetState(466)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(467)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewNegated_bind_rule_expressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(469)
			p.Match(ACIParserBOOLEAN_NOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(470)
			p.BindRuleExpr()
		}

	case 3:
		localctx = NewParenthetical_bind_rule_expressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(471)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(472)
			p.BindRuleExpr()
		}
		{
			p.SetState(473)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewBind_rule_expression_recursionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(475)
			p.BindRuleExpr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindRuleExprContext is an interface to support dynamic dispatch.
type IBindRuleExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBindRuleExprContext differentiates from other interfaces.
	IsBindRuleExprContext()
}

type BindRuleExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindRuleExprContext() *BindRuleExprContext {
	var p = new(BindRuleExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindRuleExpr
	return p
}

func InitEmptyBindRuleExprContext(p *BindRuleExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindRuleExpr
}

func (*BindRuleExprContext) IsBindRuleExprContext() {}

func NewBindRuleExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindRuleExprContext {
	var p = new(BindRuleExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_bindRuleExpr

	return p
}

func (s *BindRuleExprContext) GetParser() antlr.Parser { return s.parser }

func (s *BindRuleExprContext) CopyAll(ctx *BindRuleExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BindRuleExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindRuleExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Timeofday_expressionContext struct {
	BindRuleExprContext
}

func NewTimeofday_expressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Timeofday_expressionContext {
	var p = new(Timeofday_expressionContext)

	InitEmptyBindRuleExprContext(&p.BindRuleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprContext))

	return p
}

func (s *Timeofday_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Timeofday_expressionContext) BindTimeOfDay() IBindTimeOfDayContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindTimeOfDayContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindTimeOfDayContext)
}

func (s *Timeofday_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterTimeofday_expression(s)
	}
}

func (s *Timeofday_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitTimeofday_expression(s)
	}
}

type Bind_rule_expressionContext struct {
	BindRuleExprContext
}

func NewBind_rule_expressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Bind_rule_expressionContext {
	var p = new(Bind_rule_expressionContext)

	InitEmptyBindRuleExprContext(&p.BindRuleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprContext))

	return p
}

func (s *Bind_rule_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_rule_expressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Bind_rule_expressionContext) BindRuleExpr() IBindRuleExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindRuleExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindRuleExprContext)
}

func (s *Bind_rule_expressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Bind_rule_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterBind_rule_expression(s)
	}
}

func (s *Bind_rule_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitBind_rule_expression(s)
	}
}

type Roledn_expressionContext struct {
	BindRuleExprContext
}

func NewRoledn_expressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Roledn_expressionContext {
	var p = new(Roledn_expressionContext)

	InitEmptyBindRuleExprContext(&p.BindRuleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprContext))

	return p
}

func (s *Roledn_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Roledn_expressionContext) BindRoleDN() IBindRoleDNContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindRoleDNContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindRoleDNContext)
}

func (s *Roledn_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterRoledn_expression(s)
	}
}

func (s *Roledn_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitRoledn_expression(s)
	}
}

type Authmethod_expressionContext struct {
	BindRuleExprContext
}

func NewAuthmethod_expressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Authmethod_expressionContext {
	var p = new(Authmethod_expressionContext)

	InitEmptyBindRuleExprContext(&p.BindRuleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprContext))

	return p
}

func (s *Authmethod_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Authmethod_expressionContext) BindAuthMethod() IBindAuthMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindAuthMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindAuthMethodContext)
}

func (s *Authmethod_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAuthmethod_expression(s)
	}
}

func (s *Authmethod_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAuthmethod_expression(s)
	}
}

type Dns_expressionContext struct {
	BindRuleExprContext
}

func NewDns_expressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Dns_expressionContext {
	var p = new(Dns_expressionContext)

	InitEmptyBindRuleExprContext(&p.BindRuleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprContext))

	return p
}

func (s *Dns_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dns_expressionContext) BindDNS() IBindDNSContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindDNSContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindDNSContext)
}

func (s *Dns_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterDns_expression(s)
	}
}

func (s *Dns_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitDns_expression(s)
	}
}

type Userdn_expressionContext struct {
	BindRuleExprContext
}

func NewUserdn_expressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Userdn_expressionContext {
	var p = new(Userdn_expressionContext)

	InitEmptyBindRuleExprContext(&p.BindRuleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprContext))

	return p
}

func (s *Userdn_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Userdn_expressionContext) BindUserDN() IBindUserDNContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindUserDNContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindUserDNContext)
}

func (s *Userdn_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterUserdn_expression(s)
	}
}

func (s *Userdn_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitUserdn_expression(s)
	}
}

type Dayofweek_expressionContext struct {
	BindRuleExprContext
}

func NewDayofweek_expressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Dayofweek_expressionContext {
	var p = new(Dayofweek_expressionContext)

	InitEmptyBindRuleExprContext(&p.BindRuleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprContext))

	return p
}

func (s *Dayofweek_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dayofweek_expressionContext) BindDayOfWeek() IBindDayOfWeekContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindDayOfWeekContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindDayOfWeekContext)
}

func (s *Dayofweek_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterDayofweek_expression(s)
	}
}

func (s *Dayofweek_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitDayofweek_expression(s)
	}
}

type Userattr_expressionContext struct {
	BindRuleExprContext
}

func NewUserattr_expressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Userattr_expressionContext {
	var p = new(Userattr_expressionContext)

	InitEmptyBindRuleExprContext(&p.BindRuleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprContext))

	return p
}

func (s *Userattr_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Userattr_expressionContext) BindUserAttr() IBindUserAttrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindUserAttrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindUserAttrContext)
}

func (s *Userattr_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterUserattr_expression(s)
	}
}

func (s *Userattr_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitUserattr_expression(s)
	}
}

type Groupdn_expressionContext struct {
	BindRuleExprContext
}

func NewGroupdn_expressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Groupdn_expressionContext {
	var p = new(Groupdn_expressionContext)

	InitEmptyBindRuleExprContext(&p.BindRuleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprContext))

	return p
}

func (s *Groupdn_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Groupdn_expressionContext) BindGroupDN() IBindGroupDNContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindGroupDNContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindGroupDNContext)
}

func (s *Groupdn_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterGroupdn_expression(s)
	}
}

func (s *Groupdn_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitGroupdn_expression(s)
	}
}

type Ssf_expressionContext struct {
	BindRuleExprContext
}

func NewSsf_expressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Ssf_expressionContext {
	var p = new(Ssf_expressionContext)

	InitEmptyBindRuleExprContext(&p.BindRuleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprContext))

	return p
}

func (s *Ssf_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ssf_expressionContext) BindSecurityStrengthFactor() IBindSecurityStrengthFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindSecurityStrengthFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindSecurityStrengthFactorContext)
}

func (s *Ssf_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSsf_expression(s)
	}
}

func (s *Ssf_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSsf_expression(s)
	}
}

type Groupattr_expressionContext struct {
	BindRuleExprContext
}

func NewGroupattr_expressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Groupattr_expressionContext {
	var p = new(Groupattr_expressionContext)

	InitEmptyBindRuleExprContext(&p.BindRuleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprContext))

	return p
}

func (s *Groupattr_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Groupattr_expressionContext) BindGroupAttr() IBindGroupAttrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindGroupAttrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindGroupAttrContext)
}

func (s *Groupattr_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterGroupattr_expression(s)
	}
}

func (s *Groupattr_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitGroupattr_expression(s)
	}
}

type Ip_expressionContext struct {
	BindRuleExprContext
}

func NewIp_expressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Ip_expressionContext {
	var p = new(Ip_expressionContext)

	InitEmptyBindRuleExprContext(&p.BindRuleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprContext))

	return p
}

func (s *Ip_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ip_expressionContext) BindIP() IBindIPContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindIPContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindIPContext)
}

func (s *Ip_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterIp_expression(s)
	}
}

func (s *Ip_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitIp_expression(s)
	}
}

func (p *ACIParser) BindRuleExpr() (localctx IBindRuleExprContext) {
	localctx = NewBindRuleExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ACIParserRULE_bindRuleExpr)
	p.SetState(493)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) {
	case 1:
		localctx = NewBind_rule_expressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(478)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(479)
			p.BindRuleExpr()
		}
		{
			p.SetState(480)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewUserdn_expressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(482)
			p.BindUserDN()
		}

	case 3:
		localctx = NewUserattr_expressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(483)
			p.BindUserAttr()
		}

	case 4:
		localctx = NewGroupdn_expressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(484)
			p.BindGroupDN()
		}

	case 5:
		localctx = NewGroupattr_expressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(485)
			p.BindGroupAttr()
		}

	case 6:
		localctx = NewRoledn_expressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(486)
			p.BindRoleDN()
		}

	case 7:
		localctx = NewDns_expressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(487)
			p.BindDNS()
		}

	case 8:
		localctx = NewIp_expressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(488)
			p.BindIP()
		}

	case 9:
		localctx = NewTimeofday_expressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(489)
			p.BindTimeOfDay()
		}

	case 10:
		localctx = NewDayofweek_expressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(490)
			p.BindDayOfWeek()
		}

	case 11:
		localctx = NewSsf_expressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(491)
			p.BindSecurityStrengthFactor()
		}

	case 12:
		localctx = NewAuthmethod_expressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(492)
			p.BindAuthMethod()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindDayOfWeekContext is an interface to support dynamic dispatch.
type IBindDayOfWeekContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBindDayOfWeekContext differentiates from other interfaces.
	IsBindDayOfWeekContext()
}

type BindDayOfWeekContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindDayOfWeekContext() *BindDayOfWeekContext {
	var p = new(BindDayOfWeekContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindDayOfWeek
	return p
}

func InitEmptyBindDayOfWeekContext(p *BindDayOfWeekContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindDayOfWeek
}

func (*BindDayOfWeekContext) IsBindDayOfWeekContext() {}

func NewBindDayOfWeekContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindDayOfWeekContext {
	var p = new(BindDayOfWeekContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_bindDayOfWeek

	return p
}

func (s *BindDayOfWeekContext) GetParser() antlr.Parser { return s.parser }

func (s *BindDayOfWeekContext) CopyAll(ctx *BindDayOfWeekContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BindDayOfWeekContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindDayOfWeekContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Dayofweek_bind_ruleContext struct {
	BindDayOfWeekContext
}

func NewDayofweek_bind_ruleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Dayofweek_bind_ruleContext {
	var p = new(Dayofweek_bind_ruleContext)

	InitEmptyBindDayOfWeekContext(&p.BindDayOfWeekContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindDayOfWeekContext))

	return p
}

func (s *Dayofweek_bind_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dayofweek_bind_ruleContext) BIND_DAY_OF_WEEK() antlr.TerminalNode {
	return s.GetToken(ACIParserBIND_DAY_OF_WEEK, 0)
}

func (s *Dayofweek_bind_ruleContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Dayofweek_bind_ruleContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Dayofweek_bind_ruleContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Dayofweek_bind_ruleContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Dayofweek_bind_ruleContext) AllDoW() []IDoWContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDoWContext); ok {
			len++
		}
	}

	tst := make([]IDoWContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDoWContext); ok {
			tst[i] = t.(IDoWContext)
			i++
		}
	}

	return tst
}

func (s *Dayofweek_bind_ruleContext) DoW(i int) IDoWContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoWContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoWContext)
}

func (s *Dayofweek_bind_ruleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ACIParserCOMMA)
}

func (s *Dayofweek_bind_ruleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserCOMMA, i)
}

func (s *Dayofweek_bind_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterDayofweek_bind_rule(s)
	}
}

func (s *Dayofweek_bind_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitDayofweek_bind_rule(s)
	}
}

type Parenthetical_dayofweek_bind_ruleContext struct {
	BindDayOfWeekContext
}

func NewParenthetical_dayofweek_bind_ruleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_dayofweek_bind_ruleContext {
	var p = new(Parenthetical_dayofweek_bind_ruleContext)

	InitEmptyBindDayOfWeekContext(&p.BindDayOfWeekContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindDayOfWeekContext))

	return p
}

func (s *Parenthetical_dayofweek_bind_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_dayofweek_bind_ruleContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Parenthetical_dayofweek_bind_ruleContext) BindDayOfWeek() IBindDayOfWeekContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindDayOfWeekContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindDayOfWeekContext)
}

func (s *Parenthetical_dayofweek_bind_ruleContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Parenthetical_dayofweek_bind_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_dayofweek_bind_rule(s)
	}
}

func (s *Parenthetical_dayofweek_bind_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_dayofweek_bind_rule(s)
	}
}

func (p *ACIParser) BindDayOfWeek() (localctx IBindDayOfWeekContext) {
	localctx = NewBindDayOfWeekContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ACIParserRULE_bindDayOfWeek)
	var _la int

	p.SetState(515)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserLPAREN:
		localctx = NewParenthetical_dayofweek_bind_ruleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(495)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(496)
			p.BindDayOfWeek()
		}
		{
			p.SetState(497)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserBIND_DAY_OF_WEEK:
		localctx = NewDayofweek_bind_ruleContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(499)
			p.Match(ACIParserBIND_DAY_OF_WEEK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(502)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ACIParserEQ:
			{
				p.SetState(500)
				p.EqualTo()
			}

		case ACIParserNE:
			{
				p.SetState(501)
				p.NotEqualTo()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(504)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(505)
			p.DoW()
		}
		p.SetState(510)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ACIParserCOMMA {
			{
				p.SetState(506)
				p.Match(ACIParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(507)
				p.DoW()
			}

			p.SetState(512)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

		{
			p.SetState(513)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDoWContext is an interface to support dynamic dispatch.
type IDoWContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDoWContext differentiates from other interfaces.
	IsDoWContext()
}

type DoWContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoWContext() *DoWContext {
	var p = new(DoWContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_doW
	return p
}

func InitEmptyDoWContext(p *DoWContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_doW
}

func (*DoWContext) IsDoWContext() {}

func NewDoWContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoWContext {
	var p = new(DoWContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_doW

	return p
}

func (s *DoWContext) GetParser() antlr.Parser { return s.parser }

func (s *DoWContext) CopyAll(ctx *DoWContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *DoWContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoWContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ThurContext struct {
	DoWContext
}

func NewThurContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ThurContext {
	var p = new(ThurContext)

	InitEmptyDoWContext(&p.DoWContext)
	p.parser = parser
	p.CopyAll(ctx.(*DoWContext))

	return p
}

func (s *ThurContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThurContext) THURSDAY() antlr.TerminalNode {
	return s.GetToken(ACIParserTHURSDAY, 0)
}

func (s *ThurContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterThur(s)
	}
}

func (s *ThurContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitThur(s)
	}
}

type WedContext struct {
	DoWContext
}

func NewWedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WedContext {
	var p = new(WedContext)

	InitEmptyDoWContext(&p.DoWContext)
	p.parser = parser
	p.CopyAll(ctx.(*DoWContext))

	return p
}

func (s *WedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WedContext) WEDNESDAY() antlr.TerminalNode {
	return s.GetToken(ACIParserWEDNESDAY, 0)
}

func (s *WedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterWed(s)
	}
}

func (s *WedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitWed(s)
	}
}

type SatContext struct {
	DoWContext
}

func NewSatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SatContext {
	var p = new(SatContext)

	InitEmptyDoWContext(&p.DoWContext)
	p.parser = parser
	p.CopyAll(ctx.(*DoWContext))

	return p
}

func (s *SatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SatContext) SATURDAY() antlr.TerminalNode {
	return s.GetToken(ACIParserSATURDAY, 0)
}

func (s *SatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSat(s)
	}
}

func (s *SatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSat(s)
	}
}

type TuesContext struct {
	DoWContext
}

func NewTuesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TuesContext {
	var p = new(TuesContext)

	InitEmptyDoWContext(&p.DoWContext)
	p.parser = parser
	p.CopyAll(ctx.(*DoWContext))

	return p
}

func (s *TuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TuesContext) TUESDAY() antlr.TerminalNode {
	return s.GetToken(ACIParserTUESDAY, 0)
}

func (s *TuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterTues(s)
	}
}

func (s *TuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitTues(s)
	}
}

type FriContext struct {
	DoWContext
}

func NewFriContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FriContext {
	var p = new(FriContext)

	InitEmptyDoWContext(&p.DoWContext)
	p.parser = parser
	p.CopyAll(ctx.(*DoWContext))

	return p
}

func (s *FriContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FriContext) FRIDAY() antlr.TerminalNode {
	return s.GetToken(ACIParserFRIDAY, 0)
}

func (s *FriContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterFri(s)
	}
}

func (s *FriContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitFri(s)
	}
}

type SunContext struct {
	DoWContext
}

func NewSunContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SunContext {
	var p = new(SunContext)

	InitEmptyDoWContext(&p.DoWContext)
	p.parser = parser
	p.CopyAll(ctx.(*DoWContext))

	return p
}

func (s *SunContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SunContext) SUNDAY() antlr.TerminalNode {
	return s.GetToken(ACIParserSUNDAY, 0)
}

func (s *SunContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSun(s)
	}
}

func (s *SunContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSun(s)
	}
}

type MonContext struct {
	DoWContext
}

func NewMonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MonContext {
	var p = new(MonContext)

	InitEmptyDoWContext(&p.DoWContext)
	p.parser = parser
	p.CopyAll(ctx.(*DoWContext))

	return p
}

func (s *MonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MonContext) MONDAY() antlr.TerminalNode {
	return s.GetToken(ACIParserMONDAY, 0)
}

func (s *MonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterMon(s)
	}
}

func (s *MonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitMon(s)
	}
}

func (p *ACIParser) DoW() (localctx IDoWContext) {
	localctx = NewDoWContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ACIParserRULE_doW)
	p.SetState(524)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserSUNDAY:
		localctx = NewSunContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(517)
			p.Match(ACIParserSUNDAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserMONDAY:
		localctx = NewMonContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(518)
			p.Match(ACIParserMONDAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserTUESDAY:
		localctx = NewTuesContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(519)
			p.Match(ACIParserTUESDAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserWEDNESDAY:
		localctx = NewWedContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(520)
			p.Match(ACIParserWEDNESDAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserTHURSDAY:
		localctx = NewThurContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(521)
			p.Match(ACIParserTHURSDAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserFRIDAY:
		localctx = NewFriContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(522)
			p.Match(ACIParserFRIDAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserSATURDAY:
		localctx = NewSatContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(523)
			p.Match(ACIParserSATURDAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindAuthMethodContext is an interface to support dynamic dispatch.
type IBindAuthMethodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBindAuthMethodContext differentiates from other interfaces.
	IsBindAuthMethodContext()
}

type BindAuthMethodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindAuthMethodContext() *BindAuthMethodContext {
	var p = new(BindAuthMethodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindAuthMethod
	return p
}

func InitEmptyBindAuthMethodContext(p *BindAuthMethodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindAuthMethod
}

func (*BindAuthMethodContext) IsBindAuthMethodContext() {}

func NewBindAuthMethodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindAuthMethodContext {
	var p = new(BindAuthMethodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_bindAuthMethod

	return p
}

func (s *BindAuthMethodContext) GetParser() antlr.Parser { return s.parser }

func (s *BindAuthMethodContext) CopyAll(ctx *BindAuthMethodContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BindAuthMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindAuthMethodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Authentication_methodContext struct {
	BindAuthMethodContext
}

func NewAuthentication_methodContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Authentication_methodContext {
	var p = new(Authentication_methodContext)

	InitEmptyBindAuthMethodContext(&p.BindAuthMethodContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindAuthMethodContext))

	return p
}

func (s *Authentication_methodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Authentication_methodContext) BIND_AUTH_METHOD() antlr.TerminalNode {
	return s.GetToken(ACIParserBIND_AUTH_METHOD, 0)
}

func (s *Authentication_methodContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Authentication_methodContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Authentication_methodContext) AuthenticationMethods() IAuthenticationMethodsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuthenticationMethodsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuthenticationMethodsContext)
}

func (s *Authentication_methodContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Authentication_methodContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Authentication_methodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAuthentication_method(s)
	}
}

func (s *Authentication_methodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAuthentication_method(s)
	}
}

type ParentheticalAuthenticationMethodContext struct {
	BindAuthMethodContext
}

func NewParentheticalAuthenticationMethodContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParentheticalAuthenticationMethodContext {
	var p = new(ParentheticalAuthenticationMethodContext)

	InitEmptyBindAuthMethodContext(&p.BindAuthMethodContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindAuthMethodContext))

	return p
}

func (s *ParentheticalAuthenticationMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParentheticalAuthenticationMethodContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *ParentheticalAuthenticationMethodContext) BindAuthMethod() IBindAuthMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindAuthMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindAuthMethodContext)
}

func (s *ParentheticalAuthenticationMethodContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *ParentheticalAuthenticationMethodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParentheticalAuthenticationMethod(s)
	}
}

func (s *ParentheticalAuthenticationMethodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParentheticalAuthenticationMethod(s)
	}
}

func (p *ACIParser) BindAuthMethod() (localctx IBindAuthMethodContext) {
	localctx = NewBindAuthMethodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ACIParserRULE_bindAuthMethod)
	p.SetState(539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserLPAREN:
		localctx = NewParentheticalAuthenticationMethodContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(526)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(527)
			p.BindAuthMethod()
		}
		{
			p.SetState(528)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserBIND_AUTH_METHOD:
		localctx = NewAuthentication_methodContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(530)
			p.Match(ACIParserBIND_AUTH_METHOD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(533)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ACIParserEQ:
			{
				p.SetState(531)
				p.EqualTo()
			}

		case ACIParserNE:
			{
				p.SetState(532)
				p.NotEqualTo()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(535)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(536)
			p.AuthenticationMethods()
		}
		{
			p.SetState(537)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAuthenticationMethodsContext is an interface to support dynamic dispatch.
type IAuthenticationMethodsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAuthenticationMethodsContext differentiates from other interfaces.
	IsAuthenticationMethodsContext()
}

type AuthenticationMethodsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAuthenticationMethodsContext() *AuthenticationMethodsContext {
	var p = new(AuthenticationMethodsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_authenticationMethods
	return p
}

func InitEmptyAuthenticationMethodsContext(p *AuthenticationMethodsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_authenticationMethods
}

func (*AuthenticationMethodsContext) IsAuthenticationMethodsContext() {}

func NewAuthenticationMethodsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AuthenticationMethodsContext {
	var p = new(AuthenticationMethodsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_authenticationMethods

	return p
}

func (s *AuthenticationMethodsContext) GetParser() antlr.Parser { return s.parser }

func (s *AuthenticationMethodsContext) CopyAll(ctx *AuthenticationMethodsContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AuthenticationMethodsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AuthenticationMethodsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SaslContext struct {
	AuthenticationMethodsContext
}

func NewSaslContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SaslContext {
	var p = new(SaslContext)

	InitEmptyAuthenticationMethodsContext(&p.AuthenticationMethodsContext)
	p.parser = parser
	p.CopyAll(ctx.(*AuthenticationMethodsContext))

	return p
}

func (s *SaslContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SaslContext) SASL() antlr.TerminalNode {
	return s.GetToken(ACIParserSASL, 0)
}

func (s *SaslContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSasl(s)
	}
}

func (s *SaslContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSasl(s)
	}
}

type SimpleContext struct {
	AuthenticationMethodsContext
}

func NewSimpleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleContext {
	var p = new(SimpleContext)

	InitEmptyAuthenticationMethodsContext(&p.AuthenticationMethodsContext)
	p.parser = parser
	p.CopyAll(ctx.(*AuthenticationMethodsContext))

	return p
}

func (s *SimpleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleContext) SIMPLE() antlr.TerminalNode {
	return s.GetToken(ACIParserSIMPLE, 0)
}

func (s *SimpleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSimple(s)
	}
}

func (s *SimpleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSimple(s)
	}
}

type NoneContext struct {
	AuthenticationMethodsContext
}

func NewNoneContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NoneContext {
	var p = new(NoneContext)

	InitEmptyAuthenticationMethodsContext(&p.AuthenticationMethodsContext)
	p.parser = parser
	p.CopyAll(ctx.(*AuthenticationMethodsContext))

	return p
}

func (s *NoneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NoneContext) ANONYMOUS() antlr.TerminalNode {
	return s.GetToken(ACIParserANONYMOUS, 0)
}

func (s *NoneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterNone(s)
	}
}

func (s *NoneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitNone(s)
	}
}

type SslContext struct {
	AuthenticationMethodsContext
}

func NewSslContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SslContext {
	var p = new(SslContext)

	InitEmptyAuthenticationMethodsContext(&p.AuthenticationMethodsContext)
	p.parser = parser
	p.CopyAll(ctx.(*AuthenticationMethodsContext))

	return p
}

func (s *SslContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SslContext) SSL() antlr.TerminalNode {
	return s.GetToken(ACIParserSSL, 0)
}

func (s *SslContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSsl(s)
	}
}

func (s *SslContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSsl(s)
	}
}

func (p *ACIParser) AuthenticationMethods() (localctx IAuthenticationMethodsContext) {
	localctx = NewAuthenticationMethodsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ACIParserRULE_authenticationMethods)
	p.SetState(545)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserANONYMOUS:
		localctx = NewNoneContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(541)
			p.Match(ACIParserANONYMOUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserSIMPLE:
		localctx = NewSimpleContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(542)
			p.Match(ACIParserSIMPLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserSSL:
		localctx = NewSslContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(543)
			p.Match(ACIParserSSL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserSASL:
		localctx = NewSaslContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(544)
			p.Match(ACIParserSASL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindUserDNContext is an interface to support dynamic dispatch.
type IBindUserDNContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBindUserDNContext differentiates from other interfaces.
	IsBindUserDNContext()
}

type BindUserDNContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindUserDNContext() *BindUserDNContext {
	var p = new(BindUserDNContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindUserDN
	return p
}

func InitEmptyBindUserDNContext(p *BindUserDNContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindUserDN
}

func (*BindUserDNContext) IsBindUserDNContext() {}

func NewBindUserDNContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindUserDNContext {
	var p = new(BindUserDNContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_bindUserDN

	return p
}

func (s *BindUserDNContext) GetParser() antlr.Parser { return s.parser }

func (s *BindUserDNContext) CopyAll(ctx *BindUserDNContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BindUserDNContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindUserDNContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Bind_userdnContext struct {
	BindUserDNContext
}

func NewBind_userdnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Bind_userdnContext {
	var p = new(Bind_userdnContext)

	InitEmptyBindUserDNContext(&p.BindUserDNContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindUserDNContext))

	return p
}

func (s *Bind_userdnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_userdnContext) BIND_USER_DN() antlr.TerminalNode {
	return s.GetToken(ACIParserBIND_USER_DN, 0)
}

func (s *Bind_userdnContext) DistinguishedNames() IDistinguishedNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistinguishedNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistinguishedNamesContext)
}

func (s *Bind_userdnContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Bind_userdnContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Bind_userdnContext) WHSP() antlr.TerminalNode {
	return s.GetToken(ACIParserWHSP, 0)
}

func (s *Bind_userdnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterBind_userdn(s)
	}
}

func (s *Bind_userdnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitBind_userdn(s)
	}
}

type Parenthetical_bind_userdnContext struct {
	BindUserDNContext
}

func NewParenthetical_bind_userdnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_bind_userdnContext {
	var p = new(Parenthetical_bind_userdnContext)

	InitEmptyBindUserDNContext(&p.BindUserDNContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindUserDNContext))

	return p
}

func (s *Parenthetical_bind_userdnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_bind_userdnContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Parenthetical_bind_userdnContext) BindUserDN() IBindUserDNContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindUserDNContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindUserDNContext)
}

func (s *Parenthetical_bind_userdnContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Parenthetical_bind_userdnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_bind_userdn(s)
	}
}

func (s *Parenthetical_bind_userdnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_bind_userdn(s)
	}
}

func (p *ACIParser) BindUserDN() (localctx IBindUserDNContext) {
	localctx = NewBindUserDNContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ACIParserRULE_bindUserDN)
	var _la int

	p.SetState(561)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserLPAREN:
		localctx = NewParenthetical_bind_userdnContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(547)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(548)
			p.BindUserDN()
		}
		{
			p.SetState(549)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserBIND_USER_DN:
		localctx = NewBind_userdnContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(551)
			p.Match(ACIParserBIND_USER_DN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(554)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ACIParserEQ:
			{
				p.SetState(552)
				p.EqualTo()
			}

		case ACIParserNE:
			{
				p.SetState(553)
				p.NotEqualTo()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(557)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ACIParserWHSP {
			{
				p.SetState(556)
				p.Match(ACIParserWHSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(559)
			p.DistinguishedNames()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindRoleDNContext is an interface to support dynamic dispatch.
type IBindRoleDNContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBindRoleDNContext differentiates from other interfaces.
	IsBindRoleDNContext()
}

type BindRoleDNContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindRoleDNContext() *BindRoleDNContext {
	var p = new(BindRoleDNContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindRoleDN
	return p
}

func InitEmptyBindRoleDNContext(p *BindRoleDNContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindRoleDN
}

func (*BindRoleDNContext) IsBindRoleDNContext() {}

func NewBindRoleDNContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindRoleDNContext {
	var p = new(BindRoleDNContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_bindRoleDN

	return p
}

func (s *BindRoleDNContext) GetParser() antlr.Parser { return s.parser }

func (s *BindRoleDNContext) CopyAll(ctx *BindRoleDNContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BindRoleDNContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindRoleDNContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Bind_rolednContext struct {
	BindRoleDNContext
}

func NewBind_rolednContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Bind_rolednContext {
	var p = new(Bind_rolednContext)

	InitEmptyBindRoleDNContext(&p.BindRoleDNContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRoleDNContext))

	return p
}

func (s *Bind_rolednContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_rolednContext) BIND_ROLE_DN() antlr.TerminalNode {
	return s.GetToken(ACIParserBIND_ROLE_DN, 0)
}

func (s *Bind_rolednContext) DistinguishedNames() IDistinguishedNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistinguishedNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistinguishedNamesContext)
}

func (s *Bind_rolednContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Bind_rolednContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Bind_rolednContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterBind_roledn(s)
	}
}

func (s *Bind_rolednContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitBind_roledn(s)
	}
}

type Parenthetical_bind_rolednContext struct {
	BindRoleDNContext
}

func NewParenthetical_bind_rolednContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_bind_rolednContext {
	var p = new(Parenthetical_bind_rolednContext)

	InitEmptyBindRoleDNContext(&p.BindRoleDNContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRoleDNContext))

	return p
}

func (s *Parenthetical_bind_rolednContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_bind_rolednContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Parenthetical_bind_rolednContext) BindRoleDN() IBindRoleDNContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindRoleDNContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindRoleDNContext)
}

func (s *Parenthetical_bind_rolednContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Parenthetical_bind_rolednContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_bind_roledn(s)
	}
}

func (s *Parenthetical_bind_rolednContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_bind_roledn(s)
	}
}

func (p *ACIParser) BindRoleDN() (localctx IBindRoleDNContext) {
	localctx = NewBindRoleDNContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ACIParserRULE_bindRoleDN)
	p.SetState(574)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserLPAREN:
		localctx = NewParenthetical_bind_rolednContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(563)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(564)
			p.BindRoleDN()
		}
		{
			p.SetState(565)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserBIND_ROLE_DN:
		localctx = NewBind_rolednContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(567)
			p.Match(ACIParserBIND_ROLE_DN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(570)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ACIParserEQ:
			{
				p.SetState(568)
				p.EqualTo()
			}

		case ACIParserNE:
			{
				p.SetState(569)
				p.NotEqualTo()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(572)
			p.DistinguishedNames()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindGroupDNContext is an interface to support dynamic dispatch.
type IBindGroupDNContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBindGroupDNContext differentiates from other interfaces.
	IsBindGroupDNContext()
}

type BindGroupDNContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindGroupDNContext() *BindGroupDNContext {
	var p = new(BindGroupDNContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindGroupDN
	return p
}

func InitEmptyBindGroupDNContext(p *BindGroupDNContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindGroupDN
}

func (*BindGroupDNContext) IsBindGroupDNContext() {}

func NewBindGroupDNContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindGroupDNContext {
	var p = new(BindGroupDNContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_bindGroupDN

	return p
}

func (s *BindGroupDNContext) GetParser() antlr.Parser { return s.parser }

func (s *BindGroupDNContext) CopyAll(ctx *BindGroupDNContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BindGroupDNContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindGroupDNContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Bind_groupdnContext struct {
	BindGroupDNContext
}

func NewBind_groupdnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Bind_groupdnContext {
	var p = new(Bind_groupdnContext)

	InitEmptyBindGroupDNContext(&p.BindGroupDNContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindGroupDNContext))

	return p
}

func (s *Bind_groupdnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_groupdnContext) BIND_GROUP_DN() antlr.TerminalNode {
	return s.GetToken(ACIParserBIND_GROUP_DN, 0)
}

func (s *Bind_groupdnContext) DistinguishedNames() IDistinguishedNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistinguishedNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistinguishedNamesContext)
}

func (s *Bind_groupdnContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Bind_groupdnContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Bind_groupdnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterBind_groupdn(s)
	}
}

func (s *Bind_groupdnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitBind_groupdn(s)
	}
}

type Parenthetical_bind_groupdnContext struct {
	BindGroupDNContext
}

func NewParenthetical_bind_groupdnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_bind_groupdnContext {
	var p = new(Parenthetical_bind_groupdnContext)

	InitEmptyBindGroupDNContext(&p.BindGroupDNContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindGroupDNContext))

	return p
}

func (s *Parenthetical_bind_groupdnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_bind_groupdnContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Parenthetical_bind_groupdnContext) BindGroupDN() IBindGroupDNContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindGroupDNContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindGroupDNContext)
}

func (s *Parenthetical_bind_groupdnContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Parenthetical_bind_groupdnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_bind_groupdn(s)
	}
}

func (s *Parenthetical_bind_groupdnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_bind_groupdn(s)
	}
}

func (p *ACIParser) BindGroupDN() (localctx IBindGroupDNContext) {
	localctx = NewBindGroupDNContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ACIParserRULE_bindGroupDN)
	p.SetState(587)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserLPAREN:
		localctx = NewParenthetical_bind_groupdnContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(576)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(577)
			p.BindGroupDN()
		}
		{
			p.SetState(578)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserBIND_GROUP_DN:
		localctx = NewBind_groupdnContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(580)
			p.Match(ACIParserBIND_GROUP_DN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(583)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ACIParserEQ:
			{
				p.SetState(581)
				p.EqualTo()
			}

		case ACIParserNE:
			{
				p.SetState(582)
				p.NotEqualTo()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(585)
			p.DistinguishedNames()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindUserAttrContext is an interface to support dynamic dispatch.
type IBindUserAttrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBindUserAttrContext differentiates from other interfaces.
	IsBindUserAttrContext()
}

type BindUserAttrContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindUserAttrContext() *BindUserAttrContext {
	var p = new(BindUserAttrContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindUserAttr
	return p
}

func InitEmptyBindUserAttrContext(p *BindUserAttrContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindUserAttr
}

func (*BindUserAttrContext) IsBindUserAttrContext() {}

func NewBindUserAttrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindUserAttrContext {
	var p = new(BindUserAttrContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_bindUserAttr

	return p
}

func (s *BindUserAttrContext) GetParser() antlr.Parser { return s.parser }

func (s *BindUserAttrContext) CopyAll(ctx *BindUserAttrContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BindUserAttrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindUserAttrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Parenthetical_bind_userattrContext struct {
	BindUserAttrContext
}

func NewParenthetical_bind_userattrContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_bind_userattrContext {
	var p = new(Parenthetical_bind_userattrContext)

	InitEmptyBindUserAttrContext(&p.BindUserAttrContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindUserAttrContext))

	return p
}

func (s *Parenthetical_bind_userattrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_bind_userattrContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Parenthetical_bind_userattrContext) BindUserAttr() IBindUserAttrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindUserAttrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindUserAttrContext)
}

func (s *Parenthetical_bind_userattrContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Parenthetical_bind_userattrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_bind_userattr(s)
	}
}

func (s *Parenthetical_bind_userattrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_bind_userattr(s)
	}
}

type Bind_userattrContext struct {
	BindUserAttrContext
}

func NewBind_userattrContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Bind_userattrContext {
	var p = new(Bind_userattrContext)

	InitEmptyBindUserAttrContext(&p.BindUserAttrContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindUserAttrContext))

	return p
}

func (s *Bind_userattrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_userattrContext) BIND_USER_ATTR() antlr.TerminalNode {
	return s.GetToken(ACIParserBIND_USER_ATTR, 0)
}

func (s *Bind_userattrContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Bind_userattrContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Bind_userattrContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Bind_userattrContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Bind_userattrContext) AttributeBindTypeOrValue() IAttributeBindTypeOrValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeBindTypeOrValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeBindTypeOrValueContext)
}

func (s *Bind_userattrContext) Inheritance() IInheritanceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInheritanceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInheritanceContext)
}

func (s *Bind_userattrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterBind_userattr(s)
	}
}

func (s *Bind_userattrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitBind_userattr(s)
	}
}

func (p *ACIParser) BindUserAttr() (localctx IBindUserAttrContext) {
	localctx = NewBindUserAttrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ACIParserRULE_bindUserAttr)
	p.SetState(605)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserLPAREN:
		localctx = NewParenthetical_bind_userattrContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(589)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(590)
			p.BindUserAttr()
		}
		{
			p.SetState(591)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserBIND_USER_ATTR:
		localctx = NewBind_userattrContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(593)
			p.Match(ACIParserBIND_USER_ATTR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(596)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ACIParserEQ:
			{
				p.SetState(594)
				p.EqualTo()
			}

		case ACIParserNE:
			{
				p.SetState(595)
				p.NotEqualTo()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(598)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(601)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ACIParserKEY_OR_VALUE:
			{
				p.SetState(599)
				p.AttributeBindTypeOrValue()
			}

		case ACIParserINHERITANCE_PREFIX:
			{
				p.SetState(600)
				p.Inheritance()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(603)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindGroupAttrContext is an interface to support dynamic dispatch.
type IBindGroupAttrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBindGroupAttrContext differentiates from other interfaces.
	IsBindGroupAttrContext()
}

type BindGroupAttrContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindGroupAttrContext() *BindGroupAttrContext {
	var p = new(BindGroupAttrContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindGroupAttr
	return p
}

func InitEmptyBindGroupAttrContext(p *BindGroupAttrContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindGroupAttr
}

func (*BindGroupAttrContext) IsBindGroupAttrContext() {}

func NewBindGroupAttrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindGroupAttrContext {
	var p = new(BindGroupAttrContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_bindGroupAttr

	return p
}

func (s *BindGroupAttrContext) GetParser() antlr.Parser { return s.parser }

func (s *BindGroupAttrContext) CopyAll(ctx *BindGroupAttrContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BindGroupAttrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindGroupAttrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Parenthetical_bind_groupattrContext struct {
	BindGroupAttrContext
}

func NewParenthetical_bind_groupattrContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_bind_groupattrContext {
	var p = new(Parenthetical_bind_groupattrContext)

	InitEmptyBindGroupAttrContext(&p.BindGroupAttrContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindGroupAttrContext))

	return p
}

func (s *Parenthetical_bind_groupattrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_bind_groupattrContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Parenthetical_bind_groupattrContext) BindGroupAttr() IBindGroupAttrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindGroupAttrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindGroupAttrContext)
}

func (s *Parenthetical_bind_groupattrContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Parenthetical_bind_groupattrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_bind_groupattr(s)
	}
}

func (s *Parenthetical_bind_groupattrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_bind_groupattr(s)
	}
}

type Bind_groupattrContext struct {
	BindGroupAttrContext
}

func NewBind_groupattrContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Bind_groupattrContext {
	var p = new(Bind_groupattrContext)

	InitEmptyBindGroupAttrContext(&p.BindGroupAttrContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindGroupAttrContext))

	return p
}

func (s *Bind_groupattrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_groupattrContext) BIND_GROUP_ATTR() antlr.TerminalNode {
	return s.GetToken(ACIParserBIND_GROUP_ATTR, 0)
}

func (s *Bind_groupattrContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Bind_groupattrContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Bind_groupattrContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Bind_groupattrContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Bind_groupattrContext) AttributeBindTypeOrValue() IAttributeBindTypeOrValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeBindTypeOrValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeBindTypeOrValueContext)
}

func (s *Bind_groupattrContext) Inheritance() IInheritanceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInheritanceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInheritanceContext)
}

func (s *Bind_groupattrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterBind_groupattr(s)
	}
}

func (s *Bind_groupattrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitBind_groupattr(s)
	}
}

func (p *ACIParser) BindGroupAttr() (localctx IBindGroupAttrContext) {
	localctx = NewBindGroupAttrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ACIParserRULE_bindGroupAttr)
	p.SetState(623)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserLPAREN:
		localctx = NewParenthetical_bind_groupattrContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(607)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(608)
			p.BindGroupAttr()
		}
		{
			p.SetState(609)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserBIND_GROUP_ATTR:
		localctx = NewBind_groupattrContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(611)
			p.Match(ACIParserBIND_GROUP_ATTR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(614)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ACIParserEQ:
			{
				p.SetState(612)
				p.EqualTo()
			}

		case ACIParserNE:
			{
				p.SetState(613)
				p.NotEqualTo()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(616)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(619)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ACIParserKEY_OR_VALUE:
			{
				p.SetState(617)
				p.AttributeBindTypeOrValue()
			}

		case ACIParserINHERITANCE_PREFIX:
			{
				p.SetState(618)
				p.Inheritance()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(621)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindSecurityStrengthFactorContext is an interface to support dynamic dispatch.
type IBindSecurityStrengthFactorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBindSecurityStrengthFactorContext differentiates from other interfaces.
	IsBindSecurityStrengthFactorContext()
}

type BindSecurityStrengthFactorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindSecurityStrengthFactorContext() *BindSecurityStrengthFactorContext {
	var p = new(BindSecurityStrengthFactorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindSecurityStrengthFactor
	return p
}

func InitEmptyBindSecurityStrengthFactorContext(p *BindSecurityStrengthFactorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindSecurityStrengthFactor
}

func (*BindSecurityStrengthFactorContext) IsBindSecurityStrengthFactorContext() {}

func NewBindSecurityStrengthFactorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindSecurityStrengthFactorContext {
	var p = new(BindSecurityStrengthFactorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_bindSecurityStrengthFactor

	return p
}

func (s *BindSecurityStrengthFactorContext) GetParser() antlr.Parser { return s.parser }

func (s *BindSecurityStrengthFactorContext) CopyAll(ctx *BindSecurityStrengthFactorContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BindSecurityStrengthFactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindSecurityStrengthFactorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Bind_ssfContext struct {
	BindSecurityStrengthFactorContext
}

func NewBind_ssfContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Bind_ssfContext {
	var p = new(Bind_ssfContext)

	InitEmptyBindSecurityStrengthFactorContext(&p.BindSecurityStrengthFactorContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindSecurityStrengthFactorContext))

	return p
}

func (s *Bind_ssfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_ssfContext) BIND_SSF() antlr.TerminalNode {
	return s.GetToken(ACIParserBIND_SSF, 0)
}

func (s *Bind_ssfContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Bind_ssfContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Bind_ssfContext) INT() antlr.TerminalNode {
	return s.GetToken(ACIParserINT, 0)
}

func (s *Bind_ssfContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Bind_ssfContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Bind_ssfContext) GreaterThan() IGreaterThanContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGreaterThanContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGreaterThanContext)
}

func (s *Bind_ssfContext) GreaterThanOrEqual() IGreaterThanOrEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGreaterThanOrEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGreaterThanOrEqualContext)
}

func (s *Bind_ssfContext) LessThan() ILessThanContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILessThanContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILessThanContext)
}

func (s *Bind_ssfContext) LessThanOrEqual() ILessThanOrEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILessThanOrEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILessThanOrEqualContext)
}

func (s *Bind_ssfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterBind_ssf(s)
	}
}

func (s *Bind_ssfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitBind_ssf(s)
	}
}

type Parenthetical_ssfContext struct {
	BindSecurityStrengthFactorContext
}

func NewParenthetical_ssfContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_ssfContext {
	var p = new(Parenthetical_ssfContext)

	InitEmptyBindSecurityStrengthFactorContext(&p.BindSecurityStrengthFactorContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindSecurityStrengthFactorContext))

	return p
}

func (s *Parenthetical_ssfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_ssfContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Parenthetical_ssfContext) BindSecurityStrengthFactor() IBindSecurityStrengthFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindSecurityStrengthFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindSecurityStrengthFactorContext)
}

func (s *Parenthetical_ssfContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Parenthetical_ssfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_ssf(s)
	}
}

func (s *Parenthetical_ssfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_ssf(s)
	}
}

func (p *ACIParser) BindSecurityStrengthFactor() (localctx IBindSecurityStrengthFactorContext) {
	localctx = NewBindSecurityStrengthFactorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ACIParserRULE_bindSecurityStrengthFactor)
	p.SetState(642)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserLPAREN:
		localctx = NewParenthetical_ssfContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(625)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(626)
			p.BindSecurityStrengthFactor()
		}
		{
			p.SetState(627)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserBIND_SSF:
		localctx = NewBind_ssfContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(629)
			p.Match(ACIParserBIND_SSF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(636)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ACIParserEQ:
			{
				p.SetState(630)
				p.EqualTo()
			}

		case ACIParserNE:
			{
				p.SetState(631)
				p.NotEqualTo()
			}

		case ACIParserGT:
			{
				p.SetState(632)
				p.GreaterThan()
			}

		case ACIParserGE:
			{
				p.SetState(633)
				p.GreaterThanOrEqual()
			}

		case ACIParserLT:
			{
				p.SetState(634)
				p.LessThan()
			}

		case ACIParserLE:
			{
				p.SetState(635)
				p.LessThanOrEqual()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(638)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(639)
			p.Match(ACIParserINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(640)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindTimeOfDayContext is an interface to support dynamic dispatch.
type IBindTimeOfDayContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBindTimeOfDayContext differentiates from other interfaces.
	IsBindTimeOfDayContext()
}

type BindTimeOfDayContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindTimeOfDayContext() *BindTimeOfDayContext {
	var p = new(BindTimeOfDayContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindTimeOfDay
	return p
}

func InitEmptyBindTimeOfDayContext(p *BindTimeOfDayContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindTimeOfDay
}

func (*BindTimeOfDayContext) IsBindTimeOfDayContext() {}

func NewBindTimeOfDayContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindTimeOfDayContext {
	var p = new(BindTimeOfDayContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_bindTimeOfDay

	return p
}

func (s *BindTimeOfDayContext) GetParser() antlr.Parser { return s.parser }

func (s *BindTimeOfDayContext) CopyAll(ctx *BindTimeOfDayContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BindTimeOfDayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindTimeOfDayContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Parenthetical_bind_timeofdayContext struct {
	BindTimeOfDayContext
}

func NewParenthetical_bind_timeofdayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_bind_timeofdayContext {
	var p = new(Parenthetical_bind_timeofdayContext)

	InitEmptyBindTimeOfDayContext(&p.BindTimeOfDayContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindTimeOfDayContext))

	return p
}

func (s *Parenthetical_bind_timeofdayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_bind_timeofdayContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Parenthetical_bind_timeofdayContext) BindTimeOfDay() IBindTimeOfDayContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindTimeOfDayContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindTimeOfDayContext)
}

func (s *Parenthetical_bind_timeofdayContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Parenthetical_bind_timeofdayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_bind_timeofday(s)
	}
}

func (s *Parenthetical_bind_timeofdayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_bind_timeofday(s)
	}
}

type Bind_timeofdayContext struct {
	BindTimeOfDayContext
}

func NewBind_timeofdayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Bind_timeofdayContext {
	var p = new(Bind_timeofdayContext)

	InitEmptyBindTimeOfDayContext(&p.BindTimeOfDayContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindTimeOfDayContext))

	return p
}

func (s *Bind_timeofdayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_timeofdayContext) BIND_TIME_OF_DAY() antlr.TerminalNode {
	return s.GetToken(ACIParserBIND_TIME_OF_DAY, 0)
}

func (s *Bind_timeofdayContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Bind_timeofdayContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Bind_timeofdayContext) INT() antlr.TerminalNode {
	return s.GetToken(ACIParserINT, 0)
}

func (s *Bind_timeofdayContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Bind_timeofdayContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Bind_timeofdayContext) GreaterThan() IGreaterThanContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGreaterThanContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGreaterThanContext)
}

func (s *Bind_timeofdayContext) GreaterThanOrEqual() IGreaterThanOrEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGreaterThanOrEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGreaterThanOrEqualContext)
}

func (s *Bind_timeofdayContext) LessThan() ILessThanContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILessThanContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILessThanContext)
}

func (s *Bind_timeofdayContext) LessThanOrEqual() ILessThanOrEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILessThanOrEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILessThanOrEqualContext)
}

func (s *Bind_timeofdayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterBind_timeofday(s)
	}
}

func (s *Bind_timeofdayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitBind_timeofday(s)
	}
}

func (p *ACIParser) BindTimeOfDay() (localctx IBindTimeOfDayContext) {
	localctx = NewBindTimeOfDayContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ACIParserRULE_bindTimeOfDay)
	p.SetState(661)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserLPAREN:
		localctx = NewParenthetical_bind_timeofdayContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(644)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(645)
			p.BindTimeOfDay()
		}
		{
			p.SetState(646)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserBIND_TIME_OF_DAY:
		localctx = NewBind_timeofdayContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(648)
			p.Match(ACIParserBIND_TIME_OF_DAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(655)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ACIParserEQ:
			{
				p.SetState(649)
				p.EqualTo()
			}

		case ACIParserNE:
			{
				p.SetState(650)
				p.NotEqualTo()
			}

		case ACIParserGT:
			{
				p.SetState(651)
				p.GreaterThan()
			}

		case ACIParserGE:
			{
				p.SetState(652)
				p.GreaterThanOrEqual()
			}

		case ACIParserLT:
			{
				p.SetState(653)
				p.LessThan()
			}

		case ACIParserLE:
			{
				p.SetState(654)
				p.LessThanOrEqual()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(657)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(658)
			p.Match(ACIParserINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(659)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindIPContext is an interface to support dynamic dispatch.
type IBindIPContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBindIPContext differentiates from other interfaces.
	IsBindIPContext()
}

type BindIPContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindIPContext() *BindIPContext {
	var p = new(BindIPContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindIP
	return p
}

func InitEmptyBindIPContext(p *BindIPContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindIP
}

func (*BindIPContext) IsBindIPContext() {}

func NewBindIPContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindIPContext {
	var p = new(BindIPContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_bindIP

	return p
}

func (s *BindIPContext) GetParser() antlr.Parser { return s.parser }

func (s *BindIPContext) CopyAll(ctx *BindIPContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BindIPContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindIPContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Bind_ipContext struct {
	BindIPContext
}

func NewBind_ipContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Bind_ipContext {
	var p = new(Bind_ipContext)

	InitEmptyBindIPContext(&p.BindIPContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindIPContext))

	return p
}

func (s *Bind_ipContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_ipContext) BIND_IP() antlr.TerminalNode {
	return s.GetToken(ACIParserBIND_IP, 0)
}

func (s *Bind_ipContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Bind_ipContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Bind_ipContext) IPAddresses() IIPAddressesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIPAddressesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIPAddressesContext)
}

func (s *Bind_ipContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Bind_ipContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Bind_ipContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterBind_ip(s)
	}
}

func (s *Bind_ipContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitBind_ip(s)
	}
}

type Parenthetical_bind_ipContext struct {
	BindIPContext
}

func NewParenthetical_bind_ipContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_bind_ipContext {
	var p = new(Parenthetical_bind_ipContext)

	InitEmptyBindIPContext(&p.BindIPContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindIPContext))

	return p
}

func (s *Parenthetical_bind_ipContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_bind_ipContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Parenthetical_bind_ipContext) BindIP() IBindIPContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindIPContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindIPContext)
}

func (s *Parenthetical_bind_ipContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Parenthetical_bind_ipContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_bind_ip(s)
	}
}

func (s *Parenthetical_bind_ipContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_bind_ip(s)
	}
}

func (p *ACIParser) BindIP() (localctx IBindIPContext) {
	localctx = NewBindIPContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ACIParserRULE_bindIP)
	p.SetState(676)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserLPAREN:
		localctx = NewParenthetical_bind_ipContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(663)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(664)
			p.BindIP()
		}
		{
			p.SetState(665)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserBIND_IP:
		localctx = NewBind_ipContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(667)
			p.Match(ACIParserBIND_IP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(670)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ACIParserEQ:
			{
				p.SetState(668)
				p.EqualTo()
			}

		case ACIParserNE:
			{
				p.SetState(669)
				p.NotEqualTo()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(672)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(673)
			p.IPAddresses()
		}
		{
			p.SetState(674)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindDNSContext is an interface to support dynamic dispatch.
type IBindDNSContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBindDNSContext differentiates from other interfaces.
	IsBindDNSContext()
}

type BindDNSContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindDNSContext() *BindDNSContext {
	var p = new(BindDNSContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindDNS
	return p
}

func InitEmptyBindDNSContext(p *BindDNSContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindDNS
}

func (*BindDNSContext) IsBindDNSContext() {}

func NewBindDNSContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindDNSContext {
	var p = new(BindDNSContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_bindDNS

	return p
}

func (s *BindDNSContext) GetParser() antlr.Parser { return s.parser }

func (s *BindDNSContext) CopyAll(ctx *BindDNSContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BindDNSContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindDNSContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Dns_bind_ruleContext struct {
	BindDNSContext
}

func NewDns_bind_ruleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Dns_bind_ruleContext {
	var p = new(Dns_bind_ruleContext)

	InitEmptyBindDNSContext(&p.BindDNSContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindDNSContext))

	return p
}

func (s *Dns_bind_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dns_bind_ruleContext) BIND_DNS() antlr.TerminalNode {
	return s.GetToken(ACIParserBIND_DNS, 0)
}

func (s *Dns_bind_ruleContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Dns_bind_ruleContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Dns_bind_ruleContext) FQDN() IFQDNContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFQDNContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFQDNContext)
}

func (s *Dns_bind_ruleContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Dns_bind_ruleContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Dns_bind_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterDns_bind_rule(s)
	}
}

func (s *Dns_bind_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitDns_bind_rule(s)
	}
}

type Parenthetical_bind_dnsContext struct {
	BindDNSContext
}

func NewParenthetical_bind_dnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_bind_dnsContext {
	var p = new(Parenthetical_bind_dnsContext)

	InitEmptyBindDNSContext(&p.BindDNSContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindDNSContext))

	return p
}

func (s *Parenthetical_bind_dnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_bind_dnsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Parenthetical_bind_dnsContext) BindDNS() IBindDNSContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindDNSContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindDNSContext)
}

func (s *Parenthetical_bind_dnsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Parenthetical_bind_dnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_bind_dns(s)
	}
}

func (s *Parenthetical_bind_dnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_bind_dns(s)
	}
}

func (p *ACIParser) BindDNS() (localctx IBindDNSContext) {
	localctx = NewBindDNSContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ACIParserRULE_bindDNS)
	p.SetState(691)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserLPAREN:
		localctx = NewParenthetical_bind_dnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(678)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(679)
			p.BindDNS()
		}
		{
			p.SetState(680)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserBIND_DNS:
		localctx = NewDns_bind_ruleContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(682)
			p.Match(ACIParserBIND_DNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(685)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ACIParserEQ:
			{
				p.SetState(683)
				p.EqualTo()
			}

		case ACIParserNE:
			{
				p.SetState(684)
				p.NotEqualTo()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(687)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(688)
			p.FQDN()
		}
		{
			p.SetState(689)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIPAddressesContext is an interface to support dynamic dispatch.
type IIPAddressesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIPAddressesContext differentiates from other interfaces.
	IsIPAddressesContext()
}

type IPAddressesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIPAddressesContext() *IPAddressesContext {
	var p = new(IPAddressesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_iPAddresses
	return p
}

func InitEmptyIPAddressesContext(p *IPAddressesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_iPAddresses
}

func (*IPAddressesContext) IsIPAddressesContext() {}

func NewIPAddressesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IPAddressesContext {
	var p = new(IPAddressesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_iPAddresses

	return p
}

func (s *IPAddressesContext) GetParser() antlr.Parser { return s.parser }

func (s *IPAddressesContext) CopyAll(ctx *IPAddressesContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *IPAddressesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IPAddressesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type IpsContext struct {
	IPAddressesContext
}

func NewIpsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IpsContext {
	var p = new(IpsContext)

	InitEmptyIPAddressesContext(&p.IPAddressesContext)
	p.parser = parser
	p.CopyAll(ctx.(*IPAddressesContext))

	return p
}

func (s *IpsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IpsContext) AllIPAddress() []IIPAddressContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIPAddressContext); ok {
			len++
		}
	}

	tst := make([]IIPAddressContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIPAddressContext); ok {
			tst[i] = t.(IIPAddressContext)
			i++
		}
	}

	return tst
}

func (s *IpsContext) IPAddress(i int) IIPAddressContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIPAddressContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIPAddressContext)
}

func (s *IpsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ACIParserCOMMA)
}

func (s *IpsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserCOMMA, i)
}

func (s *IpsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterIps(s)
	}
}

func (s *IpsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitIps(s)
	}
}

func (p *ACIParser) IPAddresses() (localctx IIPAddressesContext) {
	localctx = NewIPAddressesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ACIParserRULE_iPAddresses)
	var _la int

	var _alt int

	localctx = NewIpsContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(701)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1 + 1
	for ok := true; ok; ok = _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1 + 1:
			{
				p.SetState(693)
				p.IPAddress()
			}
			p.SetState(698)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == ACIParserCOMMA {
				{
					p.SetState(694)
					p.Match(ACIParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(695)
					p.IPAddress()
				}

				p.SetState(700)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(703)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIPAddressContext is an interface to support dynamic dispatch.
type IIPAddressContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIPAddressContext differentiates from other interfaces.
	IsIPAddressContext()
}

type IPAddressContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIPAddressContext() *IPAddressContext {
	var p = new(IPAddressContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_iPAddress
	return p
}

func InitEmptyIPAddressContext(p *IPAddressContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_iPAddress
}

func (*IPAddressContext) IsIPAddressContext() {}

func NewIPAddressContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IPAddressContext {
	var p = new(IPAddressContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_iPAddress

	return p
}

func (s *IPAddressContext) GetParser() antlr.Parser { return s.parser }

func (s *IPAddressContext) CopyAll(ctx *IPAddressContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *IPAddressContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IPAddressContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Ipv6_addressContext struct {
	IPAddressContext
}

func NewIpv6_addressContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Ipv6_addressContext {
	var p = new(Ipv6_addressContext)

	InitEmptyIPAddressContext(&p.IPAddressContext)
	p.parser = parser
	p.CopyAll(ctx.(*IPAddressContext))

	return p
}

func (s *Ipv6_addressContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ipv6_addressContext) IPv6Address() IIPv6AddressContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIPv6AddressContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIPv6AddressContext)
}

func (s *Ipv6_addressContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterIpv6_address(s)
	}
}

func (s *Ipv6_addressContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitIpv6_address(s)
	}
}

type Ipv4_addressContext struct {
	IPAddressContext
}

func NewIpv4_addressContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Ipv4_addressContext {
	var p = new(Ipv4_addressContext)

	InitEmptyIPAddressContext(&p.IPAddressContext)
	p.parser = parser
	p.CopyAll(ctx.(*IPAddressContext))

	return p
}

func (s *Ipv4_addressContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ipv4_addressContext) IPv4Address() IIPv4AddressContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIPv4AddressContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIPv4AddressContext)
}

func (s *Ipv4_addressContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterIpv4_address(s)
	}
}

func (s *Ipv4_addressContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitIpv4_address(s)
	}
}

func (p *ACIParser) IPAddress() (localctx IIPAddressContext) {
	localctx = NewIPAddressContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ACIParserRULE_iPAddress)
	p.SetState(707)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserINT:
		localctx = NewIpv4_addressContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(705)
			p.IPv4Address()
		}

	case ACIParserKEY_OR_VALUE:
		localctx = NewIpv6_addressContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(706)
			p.IPv6Address()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIPv4AddressContext is an interface to support dynamic dispatch.
type IIPv4AddressContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIPv4AddressContext differentiates from other interfaces.
	IsIPv4AddressContext()
}

type IPv4AddressContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIPv4AddressContext() *IPv4AddressContext {
	var p = new(IPv4AddressContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_iPv4Address
	return p
}

func InitEmptyIPv4AddressContext(p *IPv4AddressContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_iPv4Address
}

func (*IPv4AddressContext) IsIPv4AddressContext() {}

func NewIPv4AddressContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IPv4AddressContext {
	var p = new(IPv4AddressContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_iPv4Address

	return p
}

func (s *IPv4AddressContext) GetParser() antlr.Parser { return s.parser }

func (s *IPv4AddressContext) CopyAll(ctx *IPv4AddressContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *IPv4AddressContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IPv4AddressContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Ipv4Context struct {
	IPv4AddressContext
}

func NewIpv4Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *Ipv4Context {
	var p = new(Ipv4Context)

	InitEmptyIPv4AddressContext(&p.IPv4AddressContext)
	p.parser = parser
	p.CopyAll(ctx.(*IPv4AddressContext))

	return p
}

func (s *Ipv4Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ipv4Context) AllINT() []antlr.TerminalNode {
	return s.GetTokens(ACIParserINT)
}

func (s *Ipv4Context) INT(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserINT, i)
}

func (s *Ipv4Context) DOT() antlr.TerminalNode {
	return s.GetToken(ACIParserDOT, 0)
}

func (s *Ipv4Context) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(ACIParserSTAR)
}

func (s *Ipv4Context) STAR(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserSTAR, i)
}

func (s *Ipv4Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterIpv4(s)
	}
}

func (s *Ipv4Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitIpv4(s)
	}
}

func (p *ACIParser) IPv4Address() (localctx IIPv4AddressContext) {
	localctx = NewIPv4AddressContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ACIParserRULE_iPv4Address)
	var _la int

	var _alt int

	localctx = NewIpv4Context(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(709)
		p.Match(ACIParserINT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	{
		p.SetState(710)
		p.Match(ACIParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(714)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(711)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ACIParserSTAR || _la == ACIParserINT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(716)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIPv6AddressContext is an interface to support dynamic dispatch.
type IIPv6AddressContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIPv6AddressContext differentiates from other interfaces.
	IsIPv6AddressContext()
}

type IPv6AddressContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIPv6AddressContext() *IPv6AddressContext {
	var p = new(IPv6AddressContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_iPv6Address
	return p
}

func InitEmptyIPv6AddressContext(p *IPv6AddressContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_iPv6Address
}

func (*IPv6AddressContext) IsIPv6AddressContext() {}

func NewIPv6AddressContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IPv6AddressContext {
	var p = new(IPv6AddressContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_iPv6Address

	return p
}

func (s *IPv6AddressContext) GetParser() antlr.Parser { return s.parser }

func (s *IPv6AddressContext) CopyAll(ctx *IPv6AddressContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *IPv6AddressContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IPv6AddressContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Ipv6Context struct {
	IPv6AddressContext
}

func NewIpv6Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *Ipv6Context {
	var p = new(Ipv6Context)

	InitEmptyIPv6AddressContext(&p.IPv6AddressContext)
	p.parser = parser
	p.CopyAll(ctx.(*IPv6AddressContext))

	return p
}

func (s *Ipv6Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ipv6Context) AllAttributeTypeOrValue() []IAttributeTypeOrValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			len++
		}
	}

	tst := make([]IAttributeTypeOrValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeTypeOrValueContext); ok {
			tst[i] = t.(IAttributeTypeOrValueContext)
			i++
		}
	}

	return tst
}

func (s *Ipv6Context) AttributeTypeOrValue(i int) IAttributeTypeOrValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeTypeOrValueContext)
}

func (s *Ipv6Context) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(ACIParserCOLON)
}

func (s *Ipv6Context) COLON(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserCOLON, i)
}

func (s *Ipv6Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterIpv6(s)
	}
}

func (s *Ipv6Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitIpv6(s)
	}
}

func (p *ACIParser) IPv6Address() (localctx IIPv6AddressContext) {
	localctx = NewIPv6AddressContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ACIParserRULE_iPv6Address)
	var _la int

	var _alt int

	localctx = NewIpv6Context(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(717)
		p.AttributeTypeOrValue()
	}
	p.SetState(720)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(718)
				p.Match(ACIParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(719)
				p.AttributeTypeOrValue()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(722)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(725)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ACIParserCOLON {
		{
			p.SetState(724)
			p.Match(ACIParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFQDNContext is an interface to support dynamic dispatch.
type IFQDNContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFQDNContext differentiates from other interfaces.
	IsFQDNContext()
}

type FQDNContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFQDNContext() *FQDNContext {
	var p = new(FQDNContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_fQDN
	return p
}

func InitEmptyFQDNContext(p *FQDNContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_fQDN
}

func (*FQDNContext) IsFQDNContext() {}

func NewFQDNContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FQDNContext {
	var p = new(FQDNContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_fQDN

	return p
}

func (s *FQDNContext) GetParser() antlr.Parser { return s.parser }

func (s *FQDNContext) CopyAll(ctx *FQDNContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *FQDNContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FQDNContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type FqdnContext struct {
	FQDNContext
}

func NewFqdnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FqdnContext {
	var p = new(FqdnContext)

	InitEmptyFQDNContext(&p.FQDNContext)
	p.parser = parser
	p.CopyAll(ctx.(*FQDNContext))

	return p
}

func (s *FqdnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FqdnContext) AllAttributeTypeOrValue() []IAttributeTypeOrValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			len++
		}
	}

	tst := make([]IAttributeTypeOrValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeTypeOrValueContext); ok {
			tst[i] = t.(IAttributeTypeOrValueContext)
			i++
		}
	}

	return tst
}

func (s *FqdnContext) AttributeTypeOrValue(i int) IAttributeTypeOrValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeTypeOrValueContext)
}

func (s *FqdnContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(ACIParserSTAR)
}

func (s *FqdnContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserSTAR, i)
}

func (s *FqdnContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDOT)
}

func (s *FqdnContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDOT, i)
}

func (s *FqdnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterFqdn(s)
	}
}

func (s *FqdnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitFqdn(s)
	}
}

func (p *ACIParser) FQDN() (localctx IFQDNContext) {
	localctx = NewFQDNContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ACIParserRULE_fQDN)
	var _la int

	localctx = NewFqdnContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(729)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserKEY_OR_VALUE:
		{
			p.SetState(727)
			p.AttributeTypeOrValue()
		}

	case ACIParserSTAR:
		{
			p.SetState(728)
			p.Match(ACIParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(736)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ACIParserDOT {
		{
			p.SetState(731)
			p.Match(ACIParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(734)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ACIParserKEY_OR_VALUE:
			{
				p.SetState(732)
				p.AttributeTypeOrValue()
			}

		case ACIParserSTAR:
			{
				p.SetState(733)
				p.Match(ACIParserSTAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(738)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDistinguishedNamesContext is an interface to support dynamic dispatch.
type IDistinguishedNamesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDistinguishedNamesContext differentiates from other interfaces.
	IsDistinguishedNamesContext()
}

type DistinguishedNamesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistinguishedNamesContext() *DistinguishedNamesContext {
	var p = new(DistinguishedNamesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_distinguishedNames
	return p
}

func InitEmptyDistinguishedNamesContext(p *DistinguishedNamesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_distinguishedNames
}

func (*DistinguishedNamesContext) IsDistinguishedNamesContext() {}

func NewDistinguishedNamesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DistinguishedNamesContext {
	var p = new(DistinguishedNamesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_distinguishedNames

	return p
}

func (s *DistinguishedNamesContext) GetParser() antlr.Parser { return s.parser }

func (s *DistinguishedNamesContext) CopyAll(ctx *DistinguishedNamesContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *DistinguishedNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistinguishedNamesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type List_of_quoted_distinguished_namesContext struct {
	DistinguishedNamesContext
}

func NewList_of_quoted_distinguished_namesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *List_of_quoted_distinguished_namesContext {
	var p = new(List_of_quoted_distinguished_namesContext)

	InitEmptyDistinguishedNamesContext(&p.DistinguishedNamesContext)
	p.parser = parser
	p.CopyAll(ctx.(*DistinguishedNamesContext))

	return p
}

func (s *List_of_quoted_distinguished_namesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_quoted_distinguished_namesContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *List_of_quoted_distinguished_namesContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *List_of_quoted_distinguished_namesContext) AllDistinguishedName() []IDistinguishedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDistinguishedNameContext); ok {
			len++
		}
	}

	tst := make([]IDistinguishedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDistinguishedNameContext); ok {
			tst[i] = t.(IDistinguishedNameContext)
			i++
		}
	}

	return tst
}

func (s *List_of_quoted_distinguished_namesContext) DistinguishedName(i int) IDistinguishedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistinguishedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistinguishedNameContext)
}

func (s *List_of_quoted_distinguished_namesContext) AllORDelimiter() []IORDelimiterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IORDelimiterContext); ok {
			len++
		}
	}

	tst := make([]IORDelimiterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IORDelimiterContext); ok {
			tst[i] = t.(IORDelimiterContext)
			i++
		}
	}

	return tst
}

func (s *List_of_quoted_distinguished_namesContext) ORDelimiter(i int) IORDelimiterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IORDelimiterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IORDelimiterContext)
}

func (s *List_of_quoted_distinguished_namesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterList_of_quoted_distinguished_names(s)
	}
}

func (s *List_of_quoted_distinguished_namesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitList_of_quoted_distinguished_names(s)
	}
}

type Quoted_distinguished_name_listContext struct {
	DistinguishedNamesContext
}

func NewQuoted_distinguished_name_listContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Quoted_distinguished_name_listContext {
	var p = new(Quoted_distinguished_name_listContext)

	InitEmptyDistinguishedNamesContext(&p.DistinguishedNamesContext)
	p.parser = parser
	p.CopyAll(ctx.(*DistinguishedNamesContext))

	return p
}

func (s *Quoted_distinguished_name_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Quoted_distinguished_name_listContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Quoted_distinguished_name_listContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Quoted_distinguished_name_listContext) AllDistinguishedName() []IDistinguishedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDistinguishedNameContext); ok {
			len++
		}
	}

	tst := make([]IDistinguishedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDistinguishedNameContext); ok {
			tst[i] = t.(IDistinguishedNameContext)
			i++
		}
	}

	return tst
}

func (s *Quoted_distinguished_name_listContext) DistinguishedName(i int) IDistinguishedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistinguishedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistinguishedNameContext)
}

func (s *Quoted_distinguished_name_listContext) AllORDelimiter() []IORDelimiterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IORDelimiterContext); ok {
			len++
		}
	}

	tst := make([]IORDelimiterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IORDelimiterContext); ok {
			tst[i] = t.(IORDelimiterContext)
			i++
		}
	}

	return tst
}

func (s *Quoted_distinguished_name_listContext) ORDelimiter(i int) IORDelimiterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IORDelimiterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IORDelimiterContext)
}

func (s *Quoted_distinguished_name_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterQuoted_distinguished_name_list(s)
	}
}

func (s *Quoted_distinguished_name_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitQuoted_distinguished_name_list(s)
	}
}

func (p *ACIParser) DistinguishedNames() (localctx IDistinguishedNamesContext) {
	localctx = NewDistinguishedNamesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ACIParserRULE_distinguishedNames)
	var _la int

	p.SetState(765)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext()) {
	case 1:
		localctx = NewQuoted_distinguished_name_listContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(740)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(741)
			p.DistinguishedName()
		}
		p.SetState(747)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ACIParserSYMBOLIC_OR {
			{
				p.SetState(742)
				p.ORDelimiter()
			}
			{
				p.SetState(743)
				p.DistinguishedName()
			}

			p.SetState(749)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

		{
			p.SetState(750)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewList_of_quoted_distinguished_namesContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(752)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(753)
			p.DistinguishedName()
		}
		{
			p.SetState(754)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(762)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ACIParserSYMBOLIC_OR {
			{
				p.SetState(755)
				p.ORDelimiter()
			}

			{
				p.SetState(756)
				p.Match(ACIParserDQUOTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(757)
				p.DistinguishedName()
			}
			{
				p.SetState(758)
				p.Match(ACIParserDQUOTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(764)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDistinguishedNameContext is an interface to support dynamic dispatch.
type IDistinguishedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDistinguishedNameContext differentiates from other interfaces.
	IsDistinguishedNameContext()
}

type DistinguishedNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistinguishedNameContext() *DistinguishedNameContext {
	var p = new(DistinguishedNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_distinguishedName
	return p
}

func InitEmptyDistinguishedNameContext(p *DistinguishedNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_distinguishedName
}

func (*DistinguishedNameContext) IsDistinguishedNameContext() {}

func NewDistinguishedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DistinguishedNameContext {
	var p = new(DistinguishedNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_distinguishedName

	return p
}

func (s *DistinguishedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DistinguishedNameContext) CopyAll(ctx *DistinguishedNameContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *DistinguishedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistinguishedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DnContext struct {
	DistinguishedNameContext
}

func NewDnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DnContext {
	var p = new(DnContext)

	InitEmptyDistinguishedNameContext(&p.DistinguishedNameContext)
	p.parser = parser
	p.CopyAll(ctx.(*DistinguishedNameContext))

	return p
}

func (s *DnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DnContext) LOCAL_LDAP_SCHEME() antlr.TerminalNode {
	return s.GetToken(ACIParserLOCAL_LDAP_SCHEME, 0)
}

func (s *DnContext) AllAVAOrRDN() []IAVAOrRDNContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAVAOrRDNContext); ok {
			len++
		}
	}

	tst := make([]IAVAOrRDNContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAVAOrRDNContext); ok {
			tst[i] = t.(IAVAOrRDNContext)
			i++
		}
	}

	return tst
}

func (s *DnContext) AVAOrRDN(i int) IAVAOrRDNContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAVAOrRDNContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAVAOrRDNContext)
}

func (s *DnContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ACIParserCOMMA)
}

func (s *DnContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserCOMMA, i)
}

func (s *DnContext) AllRDNMacros() []IRDNMacrosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRDNMacrosContext); ok {
			len++
		}
	}

	tst := make([]IRDNMacrosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRDNMacrosContext); ok {
			tst[i] = t.(IRDNMacrosContext)
			i++
		}
	}

	return tst
}

func (s *DnContext) RDNMacros(i int) IRDNMacrosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRDNMacrosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRDNMacrosContext)
}

func (s *DnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterDn(s)
	}
}

func (s *DnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitDn(s)
	}
}

func (p *ACIParser) DistinguishedName() (localctx IDistinguishedNameContext) {
	localctx = NewDistinguishedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ACIParserRULE_distinguishedName)
	var _la int

	localctx = NewDnContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(767)
		p.Match(ACIParserLOCAL_LDAP_SCHEME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(768)
		p.AVAOrRDN()
	}
	p.SetState(776)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ACIParserCOMMA {
		{
			p.SetState(769)
			p.Match(ACIParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(772)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ACIParserKEY_OR_VALUE:
			{
				p.SetState(770)
				p.AVAOrRDN()
			}

		case ACIParserRDN_MACROS:
			{
				p.SetState(771)
				p.RDNMacros()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(778)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRDNMacrosContext is an interface to support dynamic dispatch.
type IRDNMacrosContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRDNMacrosContext differentiates from other interfaces.
	IsRDNMacrosContext()
}

type RDNMacrosContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRDNMacrosContext() *RDNMacrosContext {
	var p = new(RDNMacrosContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_rDNMacros
	return p
}

func InitEmptyRDNMacrosContext(p *RDNMacrosContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_rDNMacros
}

func (*RDNMacrosContext) IsRDNMacrosContext() {}

func NewRDNMacrosContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RDNMacrosContext {
	var p = new(RDNMacrosContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_rDNMacros

	return p
}

func (s *RDNMacrosContext) GetParser() antlr.Parser { return s.parser }

func (s *RDNMacrosContext) CopyAll(ctx *RDNMacrosContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RDNMacrosContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RDNMacrosContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Rdn_macroContext struct {
	RDNMacrosContext
}

func NewRdn_macroContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Rdn_macroContext {
	var p = new(Rdn_macroContext)

	InitEmptyRDNMacrosContext(&p.RDNMacrosContext)
	p.parser = parser
	p.CopyAll(ctx.(*RDNMacrosContext))

	return p
}

func (s *Rdn_macroContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rdn_macroContext) RDN_MACROS() antlr.TerminalNode {
	return s.GetToken(ACIParserRDN_MACROS, 0)
}

func (s *Rdn_macroContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterRdn_macro(s)
	}
}

func (s *Rdn_macroContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitRdn_macro(s)
	}
}

func (p *ACIParser) RDNMacros() (localctx IRDNMacrosContext) {
	localctx = NewRDNMacrosContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ACIParserRULE_rDNMacros)
	localctx = NewRdn_macroContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(779)
		p.Match(ACIParserRDN_MACROS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILDAPFilterContext is an interface to support dynamic dispatch.
type ILDAPFilterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLDAPFilterContext differentiates from other interfaces.
	IsLDAPFilterContext()
}

type LDAPFilterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLDAPFilterContext() *LDAPFilterContext {
	var p = new(LDAPFilterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_lDAPFilter
	return p
}

func InitEmptyLDAPFilterContext(p *LDAPFilterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_lDAPFilter
}

func (*LDAPFilterContext) IsLDAPFilterContext() {}

func NewLDAPFilterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LDAPFilterContext {
	var p = new(LDAPFilterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_lDAPFilter

	return p
}

func (s *LDAPFilterContext) GetParser() antlr.Parser { return s.parser }

func (s *LDAPFilterContext) CopyAll(ctx *LDAPFilterContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LDAPFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LDAPFilterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Parenthetical_filter_expressionContext struct {
	LDAPFilterContext
}

func NewParenthetical_filter_expressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_filter_expressionContext {
	var p = new(Parenthetical_filter_expressionContext)

	InitEmptyLDAPFilterContext(&p.LDAPFilterContext)
	p.parser = parser
	p.CopyAll(ctx.(*LDAPFilterContext))

	return p
}

func (s *Parenthetical_filter_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_filter_expressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Parenthetical_filter_expressionContext) LDAPFilterExpr() ILDAPFilterExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILDAPFilterExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILDAPFilterExprContext)
}

func (s *Parenthetical_filter_expressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Parenthetical_filter_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_filter_expression(s)
	}
}

func (s *Parenthetical_filter_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_filter_expression(s)
	}
}

type Filter_expressionsContext struct {
	LDAPFilterContext
}

func NewFilter_expressionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Filter_expressionsContext {
	var p = new(Filter_expressionsContext)

	InitEmptyLDAPFilterContext(&p.LDAPFilterContext)
	p.parser = parser
	p.CopyAll(ctx.(*LDAPFilterContext))

	return p
}

func (s *Filter_expressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Filter_expressionsContext) AllLDAPFilterExpr() []ILDAPFilterExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILDAPFilterExprContext); ok {
			len++
		}
	}

	tst := make([]ILDAPFilterExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILDAPFilterExprContext); ok {
			tst[i] = t.(ILDAPFilterExprContext)
			i++
		}
	}

	return tst
}

func (s *Filter_expressionsContext) LDAPFilterExpr(i int) ILDAPFilterExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILDAPFilterExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILDAPFilterExprContext)
}

func (s *Filter_expressionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterFilter_expressions(s)
	}
}

func (s *Filter_expressionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitFilter_expressions(s)
	}
}

func (p *ACIParser) LDAPFilter() (localctx ILDAPFilterContext) {
	localctx = NewLDAPFilterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ACIParserRULE_lDAPFilter)
	var _la int

	p.SetState(791)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 83, p.GetParserRuleContext()) {
	case 1:
		localctx = NewParenthetical_filter_expressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(781)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(782)
			p.LDAPFilterExpr()
		}
		{
			p.SetState(783)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewFilter_expressionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(788)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ACIParserLPAREN || _la == ACIParserFILTER_NOT || _la == ACIParserKEY_OR_VALUE {
			{
				p.SetState(785)
				p.LDAPFilterExpr()
			}

			p.SetState(790)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILDAPFilterExprContext is an interface to support dynamic dispatch.
type ILDAPFilterExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLDAPFilterExprContext differentiates from other interfaces.
	IsLDAPFilterExprContext()
}

type LDAPFilterExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLDAPFilterExprContext() *LDAPFilterExprContext {
	var p = new(LDAPFilterExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_lDAPFilterExpr
	return p
}

func InitEmptyLDAPFilterExprContext(p *LDAPFilterExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_lDAPFilterExpr
}

func (*LDAPFilterExprContext) IsLDAPFilterExprContext() {}

func NewLDAPFilterExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LDAPFilterExprContext {
	var p = new(LDAPFilterExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_lDAPFilterExpr

	return p
}

func (s *LDAPFilterExprContext) GetParser() antlr.Parser { return s.parser }

func (s *LDAPFilterExprContext) CopyAll(ctx *LDAPFilterExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LDAPFilterExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LDAPFilterExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Not_filter_expressionContext struct {
	LDAPFilterExprContext
}

func NewNot_filter_expressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Not_filter_expressionContext {
	var p = new(Not_filter_expressionContext)

	InitEmptyLDAPFilterExprContext(&p.LDAPFilterExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*LDAPFilterExprContext))

	return p
}

func (s *Not_filter_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Not_filter_expressionContext) FILTER_NOT() antlr.TerminalNode {
	return s.GetToken(ACIParserFILTER_NOT, 0)
}

func (s *Not_filter_expressionContext) LDAPFilterExpr() ILDAPFilterExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILDAPFilterExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILDAPFilterExprContext)
}

func (s *Not_filter_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterNot_filter_expression(s)
	}
}

func (s *Not_filter_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitNot_filter_expression(s)
	}
}

type Ava_expressionContext struct {
	LDAPFilterExprContext
}

func NewAva_expressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Ava_expressionContext {
	var p = new(Ava_expressionContext)

	InitEmptyLDAPFilterExprContext(&p.LDAPFilterExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*LDAPFilterExprContext))

	return p
}

func (s *Ava_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ava_expressionContext) AVAOrRDN() IAVAOrRDNContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAVAOrRDNContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAVAOrRDNContext)
}

func (s *Ava_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAva_expression(s)
	}
}

func (s *Ava_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAva_expression(s)
	}
}

type Parenthetical_filter_expression_opt_boolContext struct {
	LDAPFilterExprContext
}

func NewParenthetical_filter_expression_opt_boolContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_filter_expression_opt_boolContext {
	var p = new(Parenthetical_filter_expression_opt_boolContext)

	InitEmptyLDAPFilterExprContext(&p.LDAPFilterExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*LDAPFilterExprContext))

	return p
}

func (s *Parenthetical_filter_expression_opt_boolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_filter_expression_opt_boolContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(ACIParserLPAREN)
}

func (s *Parenthetical_filter_expression_opt_boolContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, i)
}

func (s *Parenthetical_filter_expression_opt_boolContext) AllLDAPFilterExpr() []ILDAPFilterExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILDAPFilterExprContext); ok {
			len++
		}
	}

	tst := make([]ILDAPFilterExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILDAPFilterExprContext); ok {
			tst[i] = t.(ILDAPFilterExprContext)
			i++
		}
	}

	return tst
}

func (s *Parenthetical_filter_expression_opt_boolContext) LDAPFilterExpr(i int) ILDAPFilterExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILDAPFilterExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILDAPFilterExprContext)
}

func (s *Parenthetical_filter_expression_opt_boolContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(ACIParserRPAREN)
}

func (s *Parenthetical_filter_expression_opt_boolContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, i)
}

func (s *Parenthetical_filter_expression_opt_boolContext) AllFILTER_AND() []antlr.TerminalNode {
	return s.GetTokens(ACIParserFILTER_AND)
}

func (s *Parenthetical_filter_expression_opt_boolContext) FILTER_AND(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserFILTER_AND, i)
}

func (s *Parenthetical_filter_expression_opt_boolContext) AllFILTER_OR() []antlr.TerminalNode {
	return s.GetTokens(ACIParserFILTER_OR)
}

func (s *Parenthetical_filter_expression_opt_boolContext) FILTER_OR(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserFILTER_OR, i)
}

func (s *Parenthetical_filter_expression_opt_boolContext) AllFILTER_NOT() []antlr.TerminalNode {
	return s.GetTokens(ACIParserFILTER_NOT)
}

func (s *Parenthetical_filter_expression_opt_boolContext) FILTER_NOT(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserFILTER_NOT, i)
}

func (s *Parenthetical_filter_expression_opt_boolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_filter_expression_opt_bool(s)
	}
}

func (s *Parenthetical_filter_expression_opt_boolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_filter_expression_opt_bool(s)
	}
}

func (p *ACIParser) LDAPFilterExpr() (localctx ILDAPFilterExprContext) {
	localctx = NewLDAPFilterExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, ACIParserRULE_lDAPFilterExpr)
	var _la int

	var _alt int

	p.SetState(807)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserLPAREN:
		localctx = NewParenthetical_filter_expression_opt_boolContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(800)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1 + 1
		for ok := true; ok; ok = _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1 + 1:
				{
					p.SetState(793)
					p.Match(ACIParserLPAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(795)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(794)
						_la = p.GetTokenStream().LA(1)

						if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&58720256) != 0) {
							p.GetErrorHandler().RecoverInline(p)
						} else {
							p.GetErrorHandler().ReportMatch(p)
							p.Consume()
						}
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}
				{
					p.SetState(797)
					p.LDAPFilterExpr()
				}
				{
					p.SetState(798)
					p.Match(ACIParserRPAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(802)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 85, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case ACIParserFILTER_NOT:
		localctx = NewNot_filter_expressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(804)
			p.Match(ACIParserFILTER_NOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(805)
			p.LDAPFilterExpr()
		}

	case ACIParserKEY_OR_VALUE:
		localctx = NewAva_expressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(806)
			p.AVAOrRDN()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAVAOrRDNContext is an interface to support dynamic dispatch.
type IAVAOrRDNContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAVAOrRDNContext differentiates from other interfaces.
	IsAVAOrRDNContext()
}

type AVAOrRDNContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAVAOrRDNContext() *AVAOrRDNContext {
	var p = new(AVAOrRDNContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_aVAOrRDN
	return p
}

func InitEmptyAVAOrRDNContext(p *AVAOrRDNContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_aVAOrRDN
}

func (*AVAOrRDNContext) IsAVAOrRDNContext() {}

func NewAVAOrRDNContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AVAOrRDNContext {
	var p = new(AVAOrRDNContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_aVAOrRDN

	return p
}

func (s *AVAOrRDNContext) GetParser() antlr.Parser { return s.parser }

func (s *AVAOrRDNContext) CopyAll(ctx *AVAOrRDNContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AVAOrRDNContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AVAOrRDNContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Ava_or_rdnContext struct {
	AVAOrRDNContext
}

func NewAva_or_rdnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Ava_or_rdnContext {
	var p = new(Ava_or_rdnContext)

	InitEmptyAVAOrRDNContext(&p.AVAOrRDNContext)
	p.parser = parser
	p.CopyAll(ctx.(*AVAOrRDNContext))

	return p
}

func (s *Ava_or_rdnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ava_or_rdnContext) AllAttributeTypeOrValue() []IAttributeTypeOrValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			len++
		}
	}

	tst := make([]IAttributeTypeOrValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeTypeOrValueContext); ok {
			tst[i] = t.(IAttributeTypeOrValueContext)
			i++
		}
	}

	return tst
}

func (s *Ava_or_rdnContext) AttributeTypeOrValue(i int) IAttributeTypeOrValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeTypeOrValueContext)
}

func (s *Ava_or_rdnContext) AttributeComparisonOperator() IAttributeComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeComparisonOperatorContext)
}

func (s *Ava_or_rdnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAva_or_rdn(s)
	}
}

func (s *Ava_or_rdnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAva_or_rdn(s)
	}
}

func (p *ACIParser) AVAOrRDN() (localctx IAVAOrRDNContext) {
	localctx = NewAVAOrRDNContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ACIParserRULE_aVAOrRDN)
	localctx = NewAva_or_rdnContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(809)
		p.AttributeTypeOrValue()
	}
	{
		p.SetState(810)
		p.AttributeComparisonOperator()
	}
	{
		p.SetState(811)
		p.AttributeTypeOrValue()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInheritanceContext is an interface to support dynamic dispatch.
type IInheritanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsInheritanceContext differentiates from other interfaces.
	IsInheritanceContext()
}

type InheritanceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInheritanceContext() *InheritanceContext {
	var p = new(InheritanceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_inheritance
	return p
}

func InitEmptyInheritanceContext(p *InheritanceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_inheritance
}

func (*InheritanceContext) IsInheritanceContext() {}

func NewInheritanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InheritanceContext {
	var p = new(InheritanceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_inheritance

	return p
}

func (s *InheritanceContext) GetParser() antlr.Parser { return s.parser }

func (s *InheritanceContext) CopyAll(ctx *InheritanceContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *InheritanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InheritanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Inheritance_expressionContext struct {
	InheritanceContext
}

func NewInheritance_expressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Inheritance_expressionContext {
	var p = new(Inheritance_expressionContext)

	InitEmptyInheritanceContext(&p.InheritanceContext)
	p.parser = parser
	p.CopyAll(ctx.(*InheritanceContext))

	return p
}

func (s *Inheritance_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inheritance_expressionContext) INHERITANCE_PREFIX() antlr.TerminalNode {
	return s.GetToken(ACIParserINHERITANCE_PREFIX, 0)
}

func (s *Inheritance_expressionContext) InheritanceLevels() IInheritanceLevelsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInheritanceLevelsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInheritanceLevelsContext)
}

func (s *Inheritance_expressionContext) DOT() antlr.TerminalNode {
	return s.GetToken(ACIParserDOT, 0)
}

func (s *Inheritance_expressionContext) AttributeBindTypeOrValue() IAttributeBindTypeOrValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeBindTypeOrValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeBindTypeOrValueContext)
}

func (s *Inheritance_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterInheritance_expression(s)
	}
}

func (s *Inheritance_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitInheritance_expression(s)
	}
}

func (p *ACIParser) Inheritance() (localctx IInheritanceContext) {
	localctx = NewInheritanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ACIParserRULE_inheritance)
	localctx = NewInheritance_expressionContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(813)
		p.Match(ACIParserINHERITANCE_PREFIX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(814)
		p.InheritanceLevels()
	}
	{
		p.SetState(815)
		p.Match(ACIParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(816)
		p.AttributeBindTypeOrValue()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInheritanceLevelsContext is an interface to support dynamic dispatch.
type IInheritanceLevelsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsInheritanceLevelsContext differentiates from other interfaces.
	IsInheritanceLevelsContext()
}

type InheritanceLevelsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInheritanceLevelsContext() *InheritanceLevelsContext {
	var p = new(InheritanceLevelsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_inheritanceLevels
	return p
}

func InitEmptyInheritanceLevelsContext(p *InheritanceLevelsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_inheritanceLevels
}

func (*InheritanceLevelsContext) IsInheritanceLevelsContext() {}

func NewInheritanceLevelsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InheritanceLevelsContext {
	var p = new(InheritanceLevelsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_inheritanceLevels

	return p
}

func (s *InheritanceLevelsContext) GetParser() antlr.Parser { return s.parser }

func (s *InheritanceLevelsContext) CopyAll(ctx *InheritanceLevelsContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *InheritanceLevelsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InheritanceLevelsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Inheritance_levelsContext struct {
	InheritanceLevelsContext
}

func NewInheritance_levelsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Inheritance_levelsContext {
	var p = new(Inheritance_levelsContext)

	InitEmptyInheritanceLevelsContext(&p.InheritanceLevelsContext)
	p.parser = parser
	p.CopyAll(ctx.(*InheritanceLevelsContext))

	return p
}

func (s *Inheritance_levelsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inheritance_levelsContext) LBRAK() antlr.TerminalNode {
	return s.GetToken(ACIParserLBRAK, 0)
}

func (s *Inheritance_levelsContext) RBRAK() antlr.TerminalNode {
	return s.GetToken(ACIParserRBRAK, 0)
}

func (s *Inheritance_levelsContext) AllINT() []antlr.TerminalNode {
	return s.GetTokens(ACIParserINT)
}

func (s *Inheritance_levelsContext) INT(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserINT, i)
}

func (s *Inheritance_levelsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ACIParserCOMMA)
}

func (s *Inheritance_levelsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserCOMMA, i)
}

func (s *Inheritance_levelsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterInheritance_levels(s)
	}
}

func (s *Inheritance_levelsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitInheritance_levels(s)
	}
}

func (p *ACIParser) InheritanceLevels() (localctx IInheritanceLevelsContext) {
	localctx = NewInheritanceLevelsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, ACIParserRULE_inheritanceLevels)
	var _la int

	var _alt int

	localctx = NewInheritance_levelsContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(818)
		p.Match(ACIParserLBRAK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(827)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1 + 1
	for ok := true; ok; ok = _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1 + 1:
			{
				p.SetState(819)
				p.Match(ACIParserINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(824)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == ACIParserCOMMA {
				{
					p.SetState(820)
					p.Match(ACIParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(821)
					p.Match(ACIParserINT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(826)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(829)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(831)
		p.Match(ACIParserRBRAK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeBindTypeOrValueContext is an interface to support dynamic dispatch.
type IAttributeBindTypeOrValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAttributeBindTypeOrValueContext differentiates from other interfaces.
	IsAttributeBindTypeOrValueContext()
}

type AttributeBindTypeOrValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeBindTypeOrValueContext() *AttributeBindTypeOrValueContext {
	var p = new(AttributeBindTypeOrValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_attributeBindTypeOrValue
	return p
}

func InitEmptyAttributeBindTypeOrValueContext(p *AttributeBindTypeOrValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_attributeBindTypeOrValue
}

func (*AttributeBindTypeOrValueContext) IsAttributeBindTypeOrValueContext() {}

func NewAttributeBindTypeOrValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeBindTypeOrValueContext {
	var p = new(AttributeBindTypeOrValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_attributeBindTypeOrValue

	return p
}

func (s *AttributeBindTypeOrValueContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeBindTypeOrValueContext) CopyAll(ctx *AttributeBindTypeOrValueContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AttributeBindTypeOrValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeBindTypeOrValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Attr_bind_type_or_valueContext struct {
	AttributeBindTypeOrValueContext
}

func NewAttr_bind_type_or_valueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Attr_bind_type_or_valueContext {
	var p = new(Attr_bind_type_or_valueContext)

	InitEmptyAttributeBindTypeOrValueContext(&p.AttributeBindTypeOrValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeBindTypeOrValueContext))

	return p
}

func (s *Attr_bind_type_or_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_bind_type_or_valueContext) AllAttributeTypeOrValue() []IAttributeTypeOrValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			len++
		}
	}

	tst := make([]IAttributeTypeOrValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeTypeOrValueContext); ok {
			tst[i] = t.(IAttributeTypeOrValueContext)
			i++
		}
	}

	return tst
}

func (s *Attr_bind_type_or_valueContext) AttributeTypeOrValue(i int) IAttributeTypeOrValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeTypeOrValueContext)
}

func (s *Attr_bind_type_or_valueContext) HASH() antlr.TerminalNode {
	return s.GetToken(ACIParserHASH, 0)
}

func (s *Attr_bind_type_or_valueContext) BindTypes() IBindTypesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindTypesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindTypesContext)
}

func (s *Attr_bind_type_or_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAttr_bind_type_or_value(s)
	}
}

func (s *Attr_bind_type_or_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAttr_bind_type_or_value(s)
	}
}

func (p *ACIParser) AttributeBindTypeOrValue() (localctx IAttributeBindTypeOrValueContext) {
	localctx = NewAttributeBindTypeOrValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ACIParserRULE_attributeBindTypeOrValue)
	localctx = NewAttr_bind_type_or_valueContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(833)
		p.AttributeTypeOrValue()
	}
	{
		p.SetState(834)
		p.Match(ACIParserHASH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(837)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserBINDTYPE_USER_DN, ACIParserBINDTYPE_GROUP_DN, ACIParserBINDTYPE_ROLE_DN, ACIParserBINDTYPE_SELF_DN, ACIParserBINDTYPE_LDAP_URL:
		{
			p.SetState(835)
			p.BindTypes()
		}

	case ACIParserKEY_OR_VALUE:
		{
			p.SetState(836)
			p.AttributeTypeOrValue()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindTypesContext is an interface to support dynamic dispatch.
type IBindTypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBindTypesContext differentiates from other interfaces.
	IsBindTypesContext()
}

type BindTypesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindTypesContext() *BindTypesContext {
	var p = new(BindTypesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindTypes
	return p
}

func InitEmptyBindTypesContext(p *BindTypesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindTypes
}

func (*BindTypesContext) IsBindTypesContext() {}

func NewBindTypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindTypesContext {
	var p = new(BindTypesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_bindTypes

	return p
}

func (s *BindTypesContext) GetParser() antlr.Parser { return s.parser }

func (s *BindTypesContext) CopyAll(ctx *BindTypesContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BindTypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindTypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type GROUPDNContext struct {
	BindTypesContext
}

func NewGROUPDNContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GROUPDNContext {
	var p = new(GROUPDNContext)

	InitEmptyBindTypesContext(&p.BindTypesContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindTypesContext))

	return p
}

func (s *GROUPDNContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GROUPDNContext) BINDTYPE_GROUP_DN() antlr.TerminalNode {
	return s.GetToken(ACIParserBINDTYPE_GROUP_DN, 0)
}

func (s *GROUPDNContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterGROUPDN(s)
	}
}

func (s *GROUPDNContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitGROUPDN(s)
	}
}

type SELFDNContext struct {
	BindTypesContext
}

func NewSELFDNContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SELFDNContext {
	var p = new(SELFDNContext)

	InitEmptyBindTypesContext(&p.BindTypesContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindTypesContext))

	return p
}

func (s *SELFDNContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SELFDNContext) BINDTYPE_SELF_DN() antlr.TerminalNode {
	return s.GetToken(ACIParserBINDTYPE_SELF_DN, 0)
}

func (s *SELFDNContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSELFDN(s)
	}
}

func (s *SELFDNContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSELFDN(s)
	}
}

type LDAPURLContext struct {
	BindTypesContext
}

func NewLDAPURLContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LDAPURLContext {
	var p = new(LDAPURLContext)

	InitEmptyBindTypesContext(&p.BindTypesContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindTypesContext))

	return p
}

func (s *LDAPURLContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LDAPURLContext) BINDTYPE_LDAP_URL() antlr.TerminalNode {
	return s.GetToken(ACIParserBINDTYPE_LDAP_URL, 0)
}

func (s *LDAPURLContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterLDAPURL(s)
	}
}

func (s *LDAPURLContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitLDAPURL(s)
	}
}

type ROLEDNContext struct {
	BindTypesContext
}

func NewROLEDNContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ROLEDNContext {
	var p = new(ROLEDNContext)

	InitEmptyBindTypesContext(&p.BindTypesContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindTypesContext))

	return p
}

func (s *ROLEDNContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ROLEDNContext) BINDTYPE_ROLE_DN() antlr.TerminalNode {
	return s.GetToken(ACIParserBINDTYPE_ROLE_DN, 0)
}

func (s *ROLEDNContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterROLEDN(s)
	}
}

func (s *ROLEDNContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitROLEDN(s)
	}
}

type USERDNContext struct {
	BindTypesContext
}

func NewUSERDNContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *USERDNContext {
	var p = new(USERDNContext)

	InitEmptyBindTypesContext(&p.BindTypesContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindTypesContext))

	return p
}

func (s *USERDNContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *USERDNContext) BINDTYPE_USER_DN() antlr.TerminalNode {
	return s.GetToken(ACIParserBINDTYPE_USER_DN, 0)
}

func (s *USERDNContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterUSERDN(s)
	}
}

func (s *USERDNContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitUSERDN(s)
	}
}

func (p *ACIParser) BindTypes() (localctx IBindTypesContext) {
	localctx = NewBindTypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, ACIParserRULE_bindTypes)
	p.SetState(844)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserBINDTYPE_USER_DN:
		localctx = NewUSERDNContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(839)
			p.Match(ACIParserBINDTYPE_USER_DN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserBINDTYPE_GROUP_DN:
		localctx = NewGROUPDNContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(840)
			p.Match(ACIParserBINDTYPE_GROUP_DN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserBINDTYPE_ROLE_DN:
		localctx = NewROLEDNContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(841)
			p.Match(ACIParserBINDTYPE_ROLE_DN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserBINDTYPE_SELF_DN:
		localctx = NewSELFDNContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(842)
			p.Match(ACIParserBINDTYPE_SELF_DN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserBINDTYPE_LDAP_URL:
		localctx = NewLDAPURLContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(843)
			p.Match(ACIParserBINDTYPE_LDAP_URL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeTypeOrValueContext is an interface to support dynamic dispatch.
type IAttributeTypeOrValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAttributeTypeOrValueContext differentiates from other interfaces.
	IsAttributeTypeOrValueContext()
}

type AttributeTypeOrValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeTypeOrValueContext() *AttributeTypeOrValueContext {
	var p = new(AttributeTypeOrValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_attributeTypeOrValue
	return p
}

func InitEmptyAttributeTypeOrValueContext(p *AttributeTypeOrValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_attributeTypeOrValue
}

func (*AttributeTypeOrValueContext) IsAttributeTypeOrValueContext() {}

func NewAttributeTypeOrValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeTypeOrValueContext {
	var p = new(AttributeTypeOrValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_attributeTypeOrValue

	return p
}

func (s *AttributeTypeOrValueContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeTypeOrValueContext) CopyAll(ctx *AttributeTypeOrValueContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AttributeTypeOrValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeTypeOrValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Key_or_valueContext struct {
	AttributeTypeOrValueContext
}

func NewKey_or_valueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Key_or_valueContext {
	var p = new(Key_or_valueContext)

	InitEmptyAttributeTypeOrValueContext(&p.AttributeTypeOrValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeTypeOrValueContext))

	return p
}

func (s *Key_or_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Key_or_valueContext) KEY_OR_VALUE() antlr.TerminalNode {
	return s.GetToken(ACIParserKEY_OR_VALUE, 0)
}

func (s *Key_or_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterKey_or_value(s)
	}
}

func (s *Key_or_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitKey_or_value(s)
	}
}

func (p *ACIParser) AttributeTypeOrValue() (localctx IAttributeTypeOrValueContext) {
	localctx = NewAttributeTypeOrValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, ACIParserRULE_attributeTypeOrValue)
	localctx = NewKey_or_valueContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(846)
		p.Match(ACIParserKEY_OR_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeComparisonOperatorContext is an interface to support dynamic dispatch.
type IAttributeComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAttributeComparisonOperatorContext differentiates from other interfaces.
	IsAttributeComparisonOperatorContext()
}

type AttributeComparisonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeComparisonOperatorContext() *AttributeComparisonOperatorContext {
	var p = new(AttributeComparisonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_attributeComparisonOperator
	return p
}

func InitEmptyAttributeComparisonOperatorContext(p *AttributeComparisonOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_attributeComparisonOperator
}

func (*AttributeComparisonOperatorContext) IsAttributeComparisonOperatorContext() {}

func NewAttributeComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeComparisonOperatorContext {
	var p = new(AttributeComparisonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_attributeComparisonOperator

	return p
}

func (s *AttributeComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeComparisonOperatorContext) CopyAll(ctx *AttributeComparisonOperatorContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AttributeComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Not_equal_toContext struct {
	AttributeComparisonOperatorContext
}

func NewNot_equal_toContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Not_equal_toContext {
	var p = new(Not_equal_toContext)

	InitEmptyAttributeComparisonOperatorContext(&p.AttributeComparisonOperatorContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeComparisonOperatorContext))

	return p
}

func (s *Not_equal_toContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Not_equal_toContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Not_equal_toContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterNot_equal_to(s)
	}
}

func (s *Not_equal_toContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitNot_equal_to(s)
	}
}

type Equal_toContext struct {
	AttributeComparisonOperatorContext
}

func NewEqual_toContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Equal_toContext {
	var p = new(Equal_toContext)

	InitEmptyAttributeComparisonOperatorContext(&p.AttributeComparisonOperatorContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeComparisonOperatorContext))

	return p
}

func (s *Equal_toContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Equal_toContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Equal_toContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterEqual_to(s)
	}
}

func (s *Equal_toContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitEqual_to(s)
	}
}

type Greater_than_or_equalContext struct {
	AttributeComparisonOperatorContext
}

func NewGreater_than_or_equalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Greater_than_or_equalContext {
	var p = new(Greater_than_or_equalContext)

	InitEmptyAttributeComparisonOperatorContext(&p.AttributeComparisonOperatorContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeComparisonOperatorContext))

	return p
}

func (s *Greater_than_or_equalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Greater_than_or_equalContext) GreaterThanOrEqual() IGreaterThanOrEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGreaterThanOrEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGreaterThanOrEqualContext)
}

func (s *Greater_than_or_equalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterGreater_than_or_equal(s)
	}
}

func (s *Greater_than_or_equalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitGreater_than_or_equal(s)
	}
}

type Extensible_rule_with_dn_oidContext struct {
	AttributeComparisonOperatorContext
}

func NewExtensible_rule_with_dn_oidContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Extensible_rule_with_dn_oidContext {
	var p = new(Extensible_rule_with_dn_oidContext)

	InitEmptyAttributeComparisonOperatorContext(&p.AttributeComparisonOperatorContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeComparisonOperatorContext))

	return p
}

func (s *Extensible_rule_with_dn_oidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Extensible_rule_with_dn_oidContext) ExtensibleRuleDNOID() IExtensibleRuleDNOIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtensibleRuleDNOIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtensibleRuleDNOIDContext)
}

func (s *Extensible_rule_with_dn_oidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterExtensible_rule_with_dn_oid(s)
	}
}

func (s *Extensible_rule_with_dn_oidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitExtensible_rule_with_dn_oid(s)
	}
}

type Less_than_or_equalContext struct {
	AttributeComparisonOperatorContext
}

func NewLess_than_or_equalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Less_than_or_equalContext {
	var p = new(Less_than_or_equalContext)

	InitEmptyAttributeComparisonOperatorContext(&p.AttributeComparisonOperatorContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeComparisonOperatorContext))

	return p
}

func (s *Less_than_or_equalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Less_than_or_equalContext) LessThanOrEqual() ILessThanOrEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILessThanOrEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILessThanOrEqualContext)
}

func (s *Less_than_or_equalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterLess_than_or_equal(s)
	}
}

func (s *Less_than_or_equalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitLess_than_or_equal(s)
	}
}

type Extensible_rule_with_attrsContext struct {
	AttributeComparisonOperatorContext
}

func NewExtensible_rule_with_attrsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Extensible_rule_with_attrsContext {
	var p = new(Extensible_rule_with_attrsContext)

	InitEmptyAttributeComparisonOperatorContext(&p.AttributeComparisonOperatorContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeComparisonOperatorContext))

	return p
}

func (s *Extensible_rule_with_attrsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Extensible_rule_with_attrsContext) ExtensibleRuleAttr() IExtensibleRuleAttrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtensibleRuleAttrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtensibleRuleAttrContext)
}

func (s *Extensible_rule_with_attrsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterExtensible_rule_with_attrs(s)
	}
}

func (s *Extensible_rule_with_attrsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitExtensible_rule_with_attrs(s)
	}
}

type Extensible_rule_with_dnContext struct {
	AttributeComparisonOperatorContext
}

func NewExtensible_rule_with_dnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Extensible_rule_with_dnContext {
	var p = new(Extensible_rule_with_dnContext)

	InitEmptyAttributeComparisonOperatorContext(&p.AttributeComparisonOperatorContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeComparisonOperatorContext))

	return p
}

func (s *Extensible_rule_with_dnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Extensible_rule_with_dnContext) ExtensibleRuleDN() IExtensibleRuleDNContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtensibleRuleDNContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtensibleRuleDNContext)
}

func (s *Extensible_rule_with_dnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterExtensible_rule_with_dn(s)
	}
}

func (s *Extensible_rule_with_dnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitExtensible_rule_with_dn(s)
	}
}

type Extensible_ruleContext struct {
	AttributeComparisonOperatorContext
}

func NewExtensible_ruleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Extensible_ruleContext {
	var p = new(Extensible_ruleContext)

	InitEmptyAttributeComparisonOperatorContext(&p.AttributeComparisonOperatorContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeComparisonOperatorContext))

	return p
}

func (s *Extensible_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Extensible_ruleContext) ExtensibleRule() IExtensibleRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtensibleRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtensibleRuleContext)
}

func (s *Extensible_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterExtensible_rule(s)
	}
}

func (s *Extensible_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitExtensible_rule(s)
	}
}

type ApproxContext struct {
	AttributeComparisonOperatorContext
}

func NewApproxContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ApproxContext {
	var p = new(ApproxContext)

	InitEmptyAttributeComparisonOperatorContext(&p.AttributeComparisonOperatorContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeComparisonOperatorContext))

	return p
}

func (s *ApproxContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ApproxContext) Approximate() IApproximateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IApproximateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IApproximateContext)
}

func (s *ApproxContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterApprox(s)
	}
}

func (s *ApproxContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitApprox(s)
	}
}

func (p *ACIParser) AttributeComparisonOperator() (localctx IAttributeComparisonOperatorContext) {
	localctx = NewAttributeComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, ACIParserRULE_attributeComparisonOperator)
	p.SetState(857)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserEQ:
		localctx = NewEqual_toContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(848)
			p.EqualTo()
		}

	case ACIParserNE:
		localctx = NewNot_equal_toContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(849)
			p.NotEqualTo()
		}

	case ACIParserGE:
		localctx = NewGreater_than_or_equalContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(850)
			p.GreaterThanOrEqual()
		}

	case ACIParserLE:
		localctx = NewLess_than_or_equalContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(851)
			p.LessThanOrEqual()
		}

	case ACIParserAPX:
		localctx = NewApproxContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(852)
			p.Approximate()
		}

	case ACIParserCOLON:
		localctx = NewExtensible_ruleContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(853)
			p.ExtensibleRule()
		}

	case ACIParserEXD:
		localctx = NewExtensible_rule_with_dnContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(854)
			p.ExtensibleRuleDN()
		}

	case ACIParserEXA:
		localctx = NewExtensible_rule_with_attrsContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(855)
			p.ExtensibleRuleAttr()
		}

	case ACIParserEXO:
		localctx = NewExtensible_rule_with_dn_oidContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(856)
			p.ExtensibleRuleDNOID()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEqualToContext is an interface to support dynamic dispatch.
type IEqualToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQ() antlr.TerminalNode

	// IsEqualToContext differentiates from other interfaces.
	IsEqualToContext()
}

type EqualToContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEqualToContext() *EqualToContext {
	var p = new(EqualToContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_equalTo
	return p
}

func InitEmptyEqualToContext(p *EqualToContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_equalTo
}

func (*EqualToContext) IsEqualToContext() {}

func NewEqualToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqualToContext {
	var p = new(EqualToContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_equalTo

	return p
}

func (s *EqualToContext) GetParser() antlr.Parser { return s.parser }

func (s *EqualToContext) EQ() antlr.TerminalNode {
	return s.GetToken(ACIParserEQ, 0)
}

func (s *EqualToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqualToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterEqualTo(s)
	}
}

func (s *EqualToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitEqualTo(s)
	}
}

func (p *ACIParser) EqualTo() (localctx IEqualToContext) {
	localctx = NewEqualToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, ACIParserRULE_equalTo)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(859)
		p.Match(ACIParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INotEqualToContext is an interface to support dynamic dispatch.
type INotEqualToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NE() antlr.TerminalNode

	// IsNotEqualToContext differentiates from other interfaces.
	IsNotEqualToContext()
}

type NotEqualToContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotEqualToContext() *NotEqualToContext {
	var p = new(NotEqualToContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_notEqualTo
	return p
}

func InitEmptyNotEqualToContext(p *NotEqualToContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_notEqualTo
}

func (*NotEqualToContext) IsNotEqualToContext() {}

func NewNotEqualToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotEqualToContext {
	var p = new(NotEqualToContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_notEqualTo

	return p
}

func (s *NotEqualToContext) GetParser() antlr.Parser { return s.parser }

func (s *NotEqualToContext) NE() antlr.TerminalNode {
	return s.GetToken(ACIParserNE, 0)
}

func (s *NotEqualToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotEqualToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotEqualToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterNotEqualTo(s)
	}
}

func (s *NotEqualToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitNotEqualTo(s)
	}
}

func (p *ACIParser) NotEqualTo() (localctx INotEqualToContext) {
	localctx = NewNotEqualToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, ACIParserRULE_notEqualTo)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(861)
		p.Match(ACIParserNE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGreaterThanContext is an interface to support dynamic dispatch.
type IGreaterThanContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GT() antlr.TerminalNode

	// IsGreaterThanContext differentiates from other interfaces.
	IsGreaterThanContext()
}

type GreaterThanContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGreaterThanContext() *GreaterThanContext {
	var p = new(GreaterThanContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_greaterThan
	return p
}

func InitEmptyGreaterThanContext(p *GreaterThanContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_greaterThan
}

func (*GreaterThanContext) IsGreaterThanContext() {}

func NewGreaterThanContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GreaterThanContext {
	var p = new(GreaterThanContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_greaterThan

	return p
}

func (s *GreaterThanContext) GetParser() antlr.Parser { return s.parser }

func (s *GreaterThanContext) GT() antlr.TerminalNode {
	return s.GetToken(ACIParserGT, 0)
}

func (s *GreaterThanContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GreaterThanContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GreaterThanContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterGreaterThan(s)
	}
}

func (s *GreaterThanContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitGreaterThan(s)
	}
}

func (p *ACIParser) GreaterThan() (localctx IGreaterThanContext) {
	localctx = NewGreaterThanContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, ACIParserRULE_greaterThan)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(863)
		p.Match(ACIParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILessThanContext is an interface to support dynamic dispatch.
type ILessThanContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode

	// IsLessThanContext differentiates from other interfaces.
	IsLessThanContext()
}

type LessThanContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLessThanContext() *LessThanContext {
	var p = new(LessThanContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_lessThan
	return p
}

func InitEmptyLessThanContext(p *LessThanContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_lessThan
}

func (*LessThanContext) IsLessThanContext() {}

func NewLessThanContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LessThanContext {
	var p = new(LessThanContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_lessThan

	return p
}

func (s *LessThanContext) GetParser() antlr.Parser { return s.parser }

func (s *LessThanContext) LT() antlr.TerminalNode {
	return s.GetToken(ACIParserLT, 0)
}

func (s *LessThanContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LessThanContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LessThanContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterLessThan(s)
	}
}

func (s *LessThanContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitLessThan(s)
	}
}

func (p *ACIParser) LessThan() (localctx ILessThanContext) {
	localctx = NewLessThanContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, ACIParserRULE_lessThan)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(865)
		p.Match(ACIParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGreaterThanOrEqualContext is an interface to support dynamic dispatch.
type IGreaterThanOrEqualContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GE() antlr.TerminalNode

	// IsGreaterThanOrEqualContext differentiates from other interfaces.
	IsGreaterThanOrEqualContext()
}

type GreaterThanOrEqualContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGreaterThanOrEqualContext() *GreaterThanOrEqualContext {
	var p = new(GreaterThanOrEqualContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_greaterThanOrEqual
	return p
}

func InitEmptyGreaterThanOrEqualContext(p *GreaterThanOrEqualContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_greaterThanOrEqual
}

func (*GreaterThanOrEqualContext) IsGreaterThanOrEqualContext() {}

func NewGreaterThanOrEqualContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GreaterThanOrEqualContext {
	var p = new(GreaterThanOrEqualContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_greaterThanOrEqual

	return p
}

func (s *GreaterThanOrEqualContext) GetParser() antlr.Parser { return s.parser }

func (s *GreaterThanOrEqualContext) GE() antlr.TerminalNode {
	return s.GetToken(ACIParserGE, 0)
}

func (s *GreaterThanOrEqualContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GreaterThanOrEqualContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GreaterThanOrEqualContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterGreaterThanOrEqual(s)
	}
}

func (s *GreaterThanOrEqualContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitGreaterThanOrEqual(s)
	}
}

func (p *ACIParser) GreaterThanOrEqual() (localctx IGreaterThanOrEqualContext) {
	localctx = NewGreaterThanOrEqualContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, ACIParserRULE_greaterThanOrEqual)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(867)
		p.Match(ACIParserGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILessThanOrEqualContext is an interface to support dynamic dispatch.
type ILessThanOrEqualContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LE() antlr.TerminalNode

	// IsLessThanOrEqualContext differentiates from other interfaces.
	IsLessThanOrEqualContext()
}

type LessThanOrEqualContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLessThanOrEqualContext() *LessThanOrEqualContext {
	var p = new(LessThanOrEqualContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_lessThanOrEqual
	return p
}

func InitEmptyLessThanOrEqualContext(p *LessThanOrEqualContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_lessThanOrEqual
}

func (*LessThanOrEqualContext) IsLessThanOrEqualContext() {}

func NewLessThanOrEqualContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LessThanOrEqualContext {
	var p = new(LessThanOrEqualContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_lessThanOrEqual

	return p
}

func (s *LessThanOrEqualContext) GetParser() antlr.Parser { return s.parser }

func (s *LessThanOrEqualContext) LE() antlr.TerminalNode {
	return s.GetToken(ACIParserLE, 0)
}

func (s *LessThanOrEqualContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LessThanOrEqualContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LessThanOrEqualContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterLessThanOrEqual(s)
	}
}

func (s *LessThanOrEqualContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitLessThanOrEqual(s)
	}
}

func (p *ACIParser) LessThanOrEqual() (localctx ILessThanOrEqualContext) {
	localctx = NewLessThanOrEqualContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, ACIParserRULE_lessThanOrEqual)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(869)
		p.Match(ACIParserLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IApproximateContext is an interface to support dynamic dispatch.
type IApproximateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	APX() antlr.TerminalNode

	// IsApproximateContext differentiates from other interfaces.
	IsApproximateContext()
}

type ApproximateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyApproximateContext() *ApproximateContext {
	var p = new(ApproximateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_approximate
	return p
}

func InitEmptyApproximateContext(p *ApproximateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_approximate
}

func (*ApproximateContext) IsApproximateContext() {}

func NewApproximateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ApproximateContext {
	var p = new(ApproximateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_approximate

	return p
}

func (s *ApproximateContext) GetParser() antlr.Parser { return s.parser }

func (s *ApproximateContext) APX() antlr.TerminalNode {
	return s.GetToken(ACIParserAPX, 0)
}

func (s *ApproximateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ApproximateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ApproximateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterApproximate(s)
	}
}

func (s *ApproximateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitApproximate(s)
	}
}

func (p *ACIParser) Approximate() (localctx IApproximateContext) {
	localctx = NewApproximateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, ACIParserRULE_approximate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(871)
		p.Match(ACIParserAPX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExtensibleRuleContext is an interface to support dynamic dispatch.
type IExtensibleRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLON() antlr.TerminalNode

	// IsExtensibleRuleContext differentiates from other interfaces.
	IsExtensibleRuleContext()
}

type ExtensibleRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensibleRuleContext() *ExtensibleRuleContext {
	var p = new(ExtensibleRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_extensibleRule
	return p
}

func InitEmptyExtensibleRuleContext(p *ExtensibleRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_extensibleRule
}

func (*ExtensibleRuleContext) IsExtensibleRuleContext() {}

func NewExtensibleRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensibleRuleContext {
	var p = new(ExtensibleRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_extensibleRule

	return p
}

func (s *ExtensibleRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensibleRuleContext) COLON() antlr.TerminalNode {
	return s.GetToken(ACIParserCOLON, 0)
}

func (s *ExtensibleRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensibleRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensibleRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterExtensibleRule(s)
	}
}

func (s *ExtensibleRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitExtensibleRule(s)
	}
}

func (p *ACIParser) ExtensibleRule() (localctx IExtensibleRuleContext) {
	localctx = NewExtensibleRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, ACIParserRULE_extensibleRule)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(873)
		p.Match(ACIParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExtensibleRuleDNOIDContext is an interface to support dynamic dispatch.
type IExtensibleRuleDNOIDContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXO() antlr.TerminalNode

	// IsExtensibleRuleDNOIDContext differentiates from other interfaces.
	IsExtensibleRuleDNOIDContext()
}

type ExtensibleRuleDNOIDContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensibleRuleDNOIDContext() *ExtensibleRuleDNOIDContext {
	var p = new(ExtensibleRuleDNOIDContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_extensibleRuleDNOID
	return p
}

func InitEmptyExtensibleRuleDNOIDContext(p *ExtensibleRuleDNOIDContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_extensibleRuleDNOID
}

func (*ExtensibleRuleDNOIDContext) IsExtensibleRuleDNOIDContext() {}

func NewExtensibleRuleDNOIDContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensibleRuleDNOIDContext {
	var p = new(ExtensibleRuleDNOIDContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_extensibleRuleDNOID

	return p
}

func (s *ExtensibleRuleDNOIDContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensibleRuleDNOIDContext) EXO() antlr.TerminalNode {
	return s.GetToken(ACIParserEXO, 0)
}

func (s *ExtensibleRuleDNOIDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensibleRuleDNOIDContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensibleRuleDNOIDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterExtensibleRuleDNOID(s)
	}
}

func (s *ExtensibleRuleDNOIDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitExtensibleRuleDNOID(s)
	}
}

func (p *ACIParser) ExtensibleRuleDNOID() (localctx IExtensibleRuleDNOIDContext) {
	localctx = NewExtensibleRuleDNOIDContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, ACIParserRULE_extensibleRuleDNOID)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(875)
		p.Match(ACIParserEXO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExtensibleRuleDNContext is an interface to support dynamic dispatch.
type IExtensibleRuleDNContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXD() antlr.TerminalNode

	// IsExtensibleRuleDNContext differentiates from other interfaces.
	IsExtensibleRuleDNContext()
}

type ExtensibleRuleDNContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensibleRuleDNContext() *ExtensibleRuleDNContext {
	var p = new(ExtensibleRuleDNContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_extensibleRuleDN
	return p
}

func InitEmptyExtensibleRuleDNContext(p *ExtensibleRuleDNContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_extensibleRuleDN
}

func (*ExtensibleRuleDNContext) IsExtensibleRuleDNContext() {}

func NewExtensibleRuleDNContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensibleRuleDNContext {
	var p = new(ExtensibleRuleDNContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_extensibleRuleDN

	return p
}

func (s *ExtensibleRuleDNContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensibleRuleDNContext) EXD() antlr.TerminalNode {
	return s.GetToken(ACIParserEXD, 0)
}

func (s *ExtensibleRuleDNContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensibleRuleDNContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensibleRuleDNContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterExtensibleRuleDN(s)
	}
}

func (s *ExtensibleRuleDNContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitExtensibleRuleDN(s)
	}
}

func (p *ACIParser) ExtensibleRuleDN() (localctx IExtensibleRuleDNContext) {
	localctx = NewExtensibleRuleDNContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, ACIParserRULE_extensibleRuleDN)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(877)
		p.Match(ACIParserEXD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExtensibleRuleAttrContext is an interface to support dynamic dispatch.
type IExtensibleRuleAttrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXA() antlr.TerminalNode

	// IsExtensibleRuleAttrContext differentiates from other interfaces.
	IsExtensibleRuleAttrContext()
}

type ExtensibleRuleAttrContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensibleRuleAttrContext() *ExtensibleRuleAttrContext {
	var p = new(ExtensibleRuleAttrContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_extensibleRuleAttr
	return p
}

func InitEmptyExtensibleRuleAttrContext(p *ExtensibleRuleAttrContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_extensibleRuleAttr
}

func (*ExtensibleRuleAttrContext) IsExtensibleRuleAttrContext() {}

func NewExtensibleRuleAttrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensibleRuleAttrContext {
	var p = new(ExtensibleRuleAttrContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_extensibleRuleAttr

	return p
}

func (s *ExtensibleRuleAttrContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensibleRuleAttrContext) EXA() antlr.TerminalNode {
	return s.GetToken(ACIParserEXA, 0)
}

func (s *ExtensibleRuleAttrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensibleRuleAttrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensibleRuleAttrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterExtensibleRuleAttr(s)
	}
}

func (s *ExtensibleRuleAttrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitExtensibleRuleAttr(s)
	}
}

func (p *ACIParser) ExtensibleRuleAttr() (localctx IExtensibleRuleAttrContext) {
	localctx = NewExtensibleRuleAttrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, ACIParserRULE_extensibleRuleAttr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(879)
		p.Match(ACIParserEXA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IORDelimiterContext is an interface to support dynamic dispatch.
type IORDelimiterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SYMBOLIC_OR() antlr.TerminalNode

	// IsORDelimiterContext differentiates from other interfaces.
	IsORDelimiterContext()
}

type ORDelimiterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyORDelimiterContext() *ORDelimiterContext {
	var p = new(ORDelimiterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_oRDelimiter
	return p
}

func InitEmptyORDelimiterContext(p *ORDelimiterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_oRDelimiter
}

func (*ORDelimiterContext) IsORDelimiterContext() {}

func NewORDelimiterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ORDelimiterContext {
	var p = new(ORDelimiterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_oRDelimiter

	return p
}

func (s *ORDelimiterContext) GetParser() antlr.Parser { return s.parser }

func (s *ORDelimiterContext) SYMBOLIC_OR() antlr.TerminalNode {
	return s.GetToken(ACIParserSYMBOLIC_OR, 0)
}

func (s *ORDelimiterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ORDelimiterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ORDelimiterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterORDelimiter(s)
	}
}

func (s *ORDelimiterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitORDelimiter(s)
	}
}

func (p *ACIParser) ORDelimiter() (localctx IORDelimiterContext) {
	localctx = NewORDelimiterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, ACIParserRULE_oRDelimiter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(881)
		p.Match(ACIParserSYMBOLIC_OR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IANDDelimiterContext is an interface to support dynamic dispatch.
type IANDDelimiterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SYMBOLIC_AND() antlr.TerminalNode

	// IsANDDelimiterContext differentiates from other interfaces.
	IsANDDelimiterContext()
}

type ANDDelimiterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyANDDelimiterContext() *ANDDelimiterContext {
	var p = new(ANDDelimiterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_aNDDelimiter
	return p
}

func InitEmptyANDDelimiterContext(p *ANDDelimiterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_aNDDelimiter
}

func (*ANDDelimiterContext) IsANDDelimiterContext() {}

func NewANDDelimiterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ANDDelimiterContext {
	var p = new(ANDDelimiterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_aNDDelimiter

	return p
}

func (s *ANDDelimiterContext) GetParser() antlr.Parser { return s.parser }

func (s *ANDDelimiterContext) SYMBOLIC_AND() antlr.TerminalNode {
	return s.GetToken(ACIParserSYMBOLIC_AND, 0)
}

func (s *ANDDelimiterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ANDDelimiterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ANDDelimiterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterANDDelimiter(s)
	}
}

func (s *ANDDelimiterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitANDDelimiter(s)
	}
}

func (p *ACIParser) ANDDelimiter() (localctx IANDDelimiterContext) {
	localctx = NewANDDelimiterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, ACIParserRULE_aNDDelimiter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(883)
		p.Match(ACIParserSYMBOLIC_AND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}
