// Code generated from ACIParser.g4 by ANTLR 4.13.0. DO NOT EDIT.

package parser // ACIParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type ACIParser struct {
	*antlr.BaseParser
}

var ACIParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func aciparserParserInit() {
	staticData := &ACIParserParserStaticData
	staticData.LiteralNames = []string{
		"", "", "'?'", "'\"'", "'['", "'('", "']'", "')'", "'.'", "':'", "'~'",
		"'='", "", "'>'", "'<'", "", "", "", "", "", "", "'#'", "", "", "",
		"", "", "", "','", "';'", "'*'", "'ldap:///'", "", "", "", "", "'version 3.0; acl '",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "'userdn'", "'groupdn'", "'roledn'", "'userattr'", "'groupattr'",
		"'ssf'", "'dns'", "'ip'", "'authmethod'", "'timeofday'", "'dayofweek'",
		"'USERDN'", "'GROUPDN'", "'ROLEDN'", "'SELFDN'", "'LDAPURL'",
	}
	staticData.SymbolicNames = []string{
		"", "WHSP", "QMARK", "DQUOTE", "LBRAK", "LPAREN", "RBRAK", "RPAREN",
		"DOT", "COLON", "TILDE", "EQ", "NE", "GT", "LT", "APX", "GE", "LE",
		"EXA", "EXO", "EXD", "HASH", "SYMBOLIC_AND", "SYMBOLIC_OR", "FILTER_AND",
		"FILTER_OR", "FILTER_NOT", "FILTER_OPERATOR", "COMMA", "SEMI", "STAR",
		"LOCAL_LDAP_SCHEME", "PARENT", "ANYONE", "ALL_USERS", "SELF", "ANCHOR",
		"SUNDAY", "MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY",
		"ANONYMOUS", "SIMPLE", "SSL", "SASL", "TARGET", "TARGET_TO", "TARGET_FROM",
		"TARGET_SCOPE", "TARGET_ATTR", "TARGET_FILTER", "TARGET_ATTR_FILTERS",
		"TARGET_CONTROL", "TARGET_EXTENDED_OPERATION", "BIND_USER_DN", "BIND_GROUP_DN",
		"BIND_ROLE_DN", "BIND_USER_ATTR", "BIND_GROUP_ATTR", "BIND_SSF", "BIND_DNS",
		"BIND_IP", "BIND_AUTH_METHOD", "BIND_TIME_OF_DAY", "BIND_DAY_OF_WEEK",
		"BINDTYPE_USER_DN", "BINDTYPE_GROUP_DN", "BINDTYPE_ROLE_DN", "BINDTYPE_SELF_DN",
		"BINDTYPE_LDAP_URL", "BASE_OBJECT_SCOPE", "ONE_LEVEL_SCOPE", "ONE_LEVEL_TARGET_SCOPE",
		"SUB_TREE_SCOPE", "SUB_TREE_TARGET_SCOPE", "SUBORDINATE_TARGET_SCOPE",
		"ALLOW_ACCESS", "DENY_ACCESS", "SEARCH_PRIVILEGE", "READ_PRIVILEGE",
		"COMPARE_PRIVILEGE", "ADD_PRIVILEGE", "DELETE_PRIVILEGE", "SELFWRITE_PRIVILEGE",
		"PROXY_PRIVILEGE", "IMPORT_PRIVILEGE", "EXPORT_PRIVILEGE", "RDN_MACROS",
		"BOOLEAN_AND", "BOOLEAN_OR", "BOOLEAN_NOT", "WHITESPACE", "INT", "KEY_OR_VALUE",
	}
	staticData.RuleNames = []string{
		"parse", "instruction", "permissionBindRules", "permissionBindRule",
		"permission", "permissionDisposition", "allow", "deny", "accessPrivileges",
		"searchPrivilege", "readPrivilege", "comparePrivilege", "addPrivilege",
		"deletePrivilege", "selfWritePrivilege", "proxyPrivilege", "exportPrivilege",
		"importPrivilege", "noPrivileges", "allPrivileges", "targetRules", "targetRule",
		"target", "targetTo", "targetFrom", "targetFilter", "targetAttrFilters",
		"targetScope", "targetAttributes", "targetControl", "targetExtendedOperation",
		"targetSearchScopes", "baseTargetScope", "oneLevelTargetScope", "subTreeTargetScope",
		"subordinateTargetScope", "objectIdentifiers", "targetedAttributes",
		"objectIdentifier", "numberForm", "targetAttrFiltersValue", "attributeFilters",
		"attributeFilterSet", "attributeFilterOperation", "addFilterOperation",
		"delFilterOperation", "attributeFilter", "bindRule", "bindRuleExprParen",
		"bindRuleExpr", "bindDayOfWeek", "doW", "sun", "mon", "tues", "wed",
		"thur", "fri", "sat", "bindAuthMethod", "authenticationMethods", "anonAuth",
		"simpleAuth", "sSLAuth", "sASLAuth", "bindUserDN", "bindRoleDN", "bindGroupDN",
		"bindUserAttr", "bindGroupAttr", "bindSecurityStrengthFactor", "bindTimeOfDay",
		"bindIP", "bindDNS", "iPAddresses", "iPAddress", "iPv4Address", "iPv6Address",
		"fQDN", "lDAPURI", "uRISearchFilter", "uRISearchScopes", "uRIAttributeList",
		"distinguishedNames", "distinguishedName", "rDNMacros", "lDAPFilter",
		"lDAPFilterExpr", "aVAOrRDN", "inheritance", "inheritanceLevels", "attributeBindTypeOrValue",
		"bindTypes", "userDN", "roleDN", "selfDN", "groupDN", "lDAPURL", "attributeTypeOrValue",
		"attributeComparisonOperator", "equalTo", "notEqualTo", "greaterThan",
		"lessThan", "greaterThanOrEqual", "lessThanOrEqual", "approximate",
		"extensibleRule", "extensibleRuleDNOID", "extensibleRuleDN", "extensibleRuleAttr",
		"oRDelimiter", "aNDDelimiter",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 96, 1088, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2,
		63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 68,
		7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 7,
		73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 78,
		2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 2,
		84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2, 89,
		7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94, 7,
		94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7, 99,
		2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2, 104,
		7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7, 108,
		2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 1, 0, 1,
		0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 237, 8, 1, 10,
		1, 12, 1, 240, 9, 1, 1, 1, 1, 1, 5, 1, 244, 8, 1, 10, 1, 12, 1, 247, 9,
		1, 1, 1, 1, 1, 3, 1, 251, 8, 1, 1, 1, 1, 1, 1, 2, 5, 2, 256, 8, 2, 10,
		2, 12, 2, 259, 9, 2, 1, 3, 1, 3, 1, 3, 3, 3, 264, 8, 3, 1, 3, 1, 3, 3,
		3, 268, 8, 3, 1, 4, 1, 4, 5, 4, 272, 8, 4, 10, 4, 12, 4, 275, 9, 4, 1,
		4, 1, 4, 5, 4, 279, 8, 4, 10, 4, 12, 4, 282, 9, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 5, 4, 288, 8, 4, 10, 4, 12, 4, 291, 9, 4, 5, 4, 293, 8, 4, 10, 4, 12,
		4, 296, 9, 4, 1, 4, 5, 4, 299, 8, 4, 10, 4, 12, 4, 302, 9, 4, 1, 4, 1,
		4, 1, 5, 1, 5, 3, 5, 308, 8, 5, 1, 6, 1, 6, 1, 7, 1, 7, 1, 8, 1, 8, 1,
		8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 325, 8, 8, 1,
		9, 1, 9, 1, 10, 1, 10, 1, 11, 1, 11, 1, 12, 1, 12, 1, 13, 1, 13, 1, 14,
		1, 14, 1, 15, 1, 15, 1, 16, 1, 16, 1, 17, 1, 17, 1, 18, 1, 18, 1, 19, 1,
		19, 1, 20, 5, 20, 350, 8, 20, 10, 20, 12, 20, 353, 9, 20, 1, 21, 1, 21,
		1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 3, 21, 364, 8, 21, 1,
		22, 1, 22, 1, 22, 1, 22, 3, 22, 370, 8, 22, 1, 22, 1, 22, 1, 22, 1, 23,
		1, 23, 1, 23, 1, 23, 3, 23, 379, 8, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1,
		23, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 390, 8, 24, 1, 24, 1, 24, 1, 24,
		1, 24, 1, 24, 1, 25, 1, 25, 1, 25, 1, 25, 3, 25, 401, 8, 25, 1, 25, 1,
		25, 1, 25, 1, 25, 1, 25, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26,
		1, 26, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 28, 1,
		28, 1, 28, 1, 28, 3, 28, 428, 8, 28, 1, 28, 1, 28, 1, 28, 1, 29, 1, 29,
		1, 29, 1, 29, 3, 29, 437, 8, 29, 1, 29, 1, 29, 1, 29, 1, 30, 1, 30, 1,
		30, 1, 30, 3, 30, 446, 8, 30, 1, 30, 1, 30, 1, 30, 1, 31, 1, 31, 1, 31,
		1, 31, 3, 31, 455, 8, 31, 1, 32, 1, 32, 1, 33, 1, 33, 1, 34, 1, 34, 1,
		35, 1, 35, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 5, 36, 470, 8, 36, 10, 36,
		12, 36, 473, 9, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1,
		36, 1, 36, 1, 36, 5, 36, 485, 8, 36, 10, 36, 12, 36, 488, 9, 36, 3, 36,
		490, 8, 36, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 5, 37, 497, 8, 37, 10, 37,
		12, 37, 500, 9, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1,
		37, 1, 37, 1, 37, 5, 37, 512, 8, 37, 10, 37, 12, 37, 515, 9, 37, 1, 37,
		1, 37, 1, 37, 3, 37, 520, 8, 37, 1, 38, 1, 38, 1, 38, 4, 38, 525, 8, 38,
		11, 38, 12, 38, 526, 1, 39, 1, 39, 1, 40, 1, 40, 1, 40, 3, 40, 534, 8,
		40, 1, 41, 1, 41, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 5, 42,
		545, 8, 42, 10, 42, 12, 42, 548, 9, 42, 1, 43, 1, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 3, 43, 556, 8, 43, 1, 44, 1, 44, 1, 45, 1, 45, 1, 46, 1, 46,
		1, 46, 1, 46, 1, 47, 1, 47, 1, 47, 1, 47, 5, 47, 570, 8, 47, 10, 47, 12,
		47, 573, 9, 47, 3, 47, 575, 8, 47, 1, 48, 1, 48, 1, 48, 1, 48, 5, 48, 581,
		8, 48, 10, 48, 12, 48, 584, 9, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1,
		48, 1, 48, 1, 48, 1, 48, 3, 48, 595, 8, 48, 1, 49, 1, 49, 1, 49, 1, 49,
		1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1,
		49, 3, 49, 612, 8, 49, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50,
		3, 50, 621, 8, 50, 1, 50, 1, 50, 1, 50, 1, 50, 5, 50, 627, 8, 50, 10, 50,
		12, 50, 630, 9, 50, 1, 50, 1, 50, 3, 50, 634, 8, 50, 1, 51, 1, 51, 1, 51,
		1, 51, 1, 51, 1, 51, 1, 51, 3, 51, 643, 8, 51, 1, 52, 1, 52, 1, 53, 1,
		53, 1, 54, 1, 54, 1, 55, 1, 55, 1, 56, 1, 56, 1, 57, 1, 57, 1, 58, 1, 58,
		1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 3, 59, 666, 8, 59, 1,
		59, 1, 59, 1, 59, 1, 59, 3, 59, 672, 8, 59, 1, 60, 1, 60, 1, 60, 1, 60,
		3, 60, 678, 8, 60, 1, 61, 1, 61, 1, 62, 1, 62, 1, 63, 1, 63, 1, 64, 1,
		64, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 3, 65, 695, 8, 65,
		1, 65, 3, 65, 698, 8, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 3, 65, 705,
		8, 65, 3, 65, 707, 8, 65, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1,
		66, 3, 66, 716, 8, 66, 1, 66, 1, 66, 3, 66, 720, 8, 66, 1, 67, 1, 67, 1,
		67, 1, 67, 1, 67, 1, 67, 1, 67, 3, 67, 729, 8, 67, 1, 67, 1, 67, 1, 67,
		1, 67, 1, 67, 3, 67, 736, 8, 67, 3, 67, 738, 8, 67, 1, 68, 1, 68, 1, 68,
		1, 68, 1, 68, 1, 68, 1, 68, 3, 68, 747, 8, 68, 1, 68, 1, 68, 1, 68, 3,
		68, 752, 8, 68, 1, 68, 1, 68, 3, 68, 756, 8, 68, 1, 69, 1, 69, 1, 69, 1,
		69, 1, 69, 1, 69, 1, 69, 3, 69, 765, 8, 69, 1, 69, 1, 69, 1, 69, 3, 69,
		770, 8, 69, 1, 69, 1, 69, 3, 69, 774, 8, 69, 1, 70, 1, 70, 1, 70, 1, 70,
		1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 3, 70, 787, 8, 70, 1,
		70, 1, 70, 1, 70, 1, 70, 3, 70, 793, 8, 70, 1, 71, 1, 71, 1, 71, 1, 71,
		1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 3, 71, 806, 8, 71, 1,
		71, 1, 71, 1, 71, 1, 71, 3, 71, 812, 8, 71, 1, 72, 1, 72, 1, 72, 1, 72,
		1, 72, 1, 72, 1, 72, 3, 72, 821, 8, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3,
		72, 827, 8, 72, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73,
		836, 8, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 842, 8, 73, 1, 74, 1, 74,
		1, 74, 5, 74, 847, 8, 74, 10, 74, 12, 74, 850, 9, 74, 4, 74, 852, 8, 74,
		11, 74, 12, 74, 853, 1, 75, 1, 75, 3, 75, 858, 8, 75, 1, 76, 1, 76, 1,
		76, 5, 76, 863, 8, 76, 10, 76, 12, 76, 866, 9, 76, 1, 77, 1, 77, 1, 77,
		4, 77, 871, 8, 77, 11, 77, 12, 77, 872, 1, 77, 3, 77, 876, 8, 77, 1, 78,
		1, 78, 1, 78, 4, 78, 881, 8, 78, 11, 78, 12, 78, 882, 1, 79, 1, 79, 1,
		79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79, 894, 8, 79, 1, 80,
		1, 80, 1, 80, 1, 81, 1, 81, 3, 81, 901, 8, 81, 1, 82, 1, 82, 1, 82, 1,
		82, 5, 82, 907, 8, 82, 10, 82, 12, 82, 910, 9, 82, 3, 82, 912, 8, 82, 1,
		83, 1, 83, 1, 83, 1, 83, 1, 83, 5, 83, 919, 8, 83, 10, 83, 12, 83, 922,
		9, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1,
		83, 5, 83, 934, 8, 83, 10, 83, 12, 83, 937, 9, 83, 3, 83, 939, 8, 83, 1,
		84, 1, 84, 1, 84, 1, 84, 1, 84, 3, 84, 946, 8, 84, 5, 84, 948, 8, 84, 10,
		84, 12, 84, 951, 9, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84,
		1, 84, 3, 84, 961, 8, 84, 1, 85, 1, 85, 1, 86, 1, 86, 1, 86, 1, 86, 1,
		86, 5, 86, 970, 8, 86, 10, 86, 12, 86, 973, 9, 86, 3, 86, 975, 8, 86, 1,
		87, 1, 87, 3, 87, 979, 8, 87, 1, 87, 1, 87, 1, 87, 4, 87, 984, 8, 87, 11,
		87, 12, 87, 985, 1, 87, 1, 87, 1, 87, 3, 87, 991, 8, 87, 1, 88, 1, 88,
		1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 3, 88, 1003, 8,
		88, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 90, 1, 90, 1, 90, 1, 90, 5, 90,
		1014, 8, 90, 10, 90, 12, 90, 1017, 9, 90, 4, 90, 1019, 8, 90, 11, 90, 12,
		90, 1020, 1, 90, 1, 90, 1, 91, 1, 91, 1, 91, 1, 91, 3, 91, 1029, 8, 91,
		1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 3, 92, 1036, 8, 92, 1, 93, 1, 93, 1,
		94, 1, 94, 1, 95, 1, 95, 1, 96, 1, 96, 1, 97, 1, 97, 1, 98, 1, 98, 3, 98,
		1050, 8, 98, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 3,
		99, 1060, 8, 99, 1, 100, 1, 100, 1, 101, 1, 101, 1, 102, 1, 102, 1, 103,
		1, 103, 1, 104, 1, 104, 1, 105, 1, 105, 1, 106, 1, 106, 1, 107, 1, 107,
		1, 108, 1, 108, 1, 109, 1, 109, 1, 110, 1, 110, 1, 111, 1, 111, 1, 112,
		1, 112, 1, 112, 9, 238, 245, 273, 280, 289, 300, 853, 985, 1020, 0, 113,
		0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36,
		38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72,
		74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106,
		108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136,
		138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166,
		168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196,
		198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 0,
		5, 1, 0, 28, 29, 1, 0, 91, 93, 2, 0, 30, 30, 95, 95, 2, 0, 73, 74, 76,
		76, 1, 0, 24, 26, 1131, 0, 226, 1, 0, 0, 0, 2, 229, 1, 0, 0, 0, 4, 257,
		1, 0, 0, 0, 6, 260, 1, 0, 0, 0, 8, 269, 1, 0, 0, 0, 10, 307, 1, 0, 0, 0,
		12, 309, 1, 0, 0, 0, 14, 311, 1, 0, 0, 0, 16, 324, 1, 0, 0, 0, 18, 326,
		1, 0, 0, 0, 20, 328, 1, 0, 0, 0, 22, 330, 1, 0, 0, 0, 24, 332, 1, 0, 0,
		0, 26, 334, 1, 0, 0, 0, 28, 336, 1, 0, 0, 0, 30, 338, 1, 0, 0, 0, 32, 340,
		1, 0, 0, 0, 34, 342, 1, 0, 0, 0, 36, 344, 1, 0, 0, 0, 38, 346, 1, 0, 0,
		0, 40, 351, 1, 0, 0, 0, 42, 363, 1, 0, 0, 0, 44, 365, 1, 0, 0, 0, 46, 374,
		1, 0, 0, 0, 48, 385, 1, 0, 0, 0, 50, 396, 1, 0, 0, 0, 52, 407, 1, 0, 0,
		0, 54, 415, 1, 0, 0, 0, 56, 423, 1, 0, 0, 0, 58, 432, 1, 0, 0, 0, 60, 441,
		1, 0, 0, 0, 62, 454, 1, 0, 0, 0, 64, 456, 1, 0, 0, 0, 66, 458, 1, 0, 0,
		0, 68, 460, 1, 0, 0, 0, 70, 462, 1, 0, 0, 0, 72, 489, 1, 0, 0, 0, 74, 519,
		1, 0, 0, 0, 76, 521, 1, 0, 0, 0, 78, 528, 1, 0, 0, 0, 80, 533, 1, 0, 0,
		0, 82, 535, 1, 0, 0, 0, 84, 539, 1, 0, 0, 0, 86, 555, 1, 0, 0, 0, 88, 557,
		1, 0, 0, 0, 90, 559, 1, 0, 0, 0, 92, 561, 1, 0, 0, 0, 94, 574, 1, 0, 0,
		0, 96, 594, 1, 0, 0, 0, 98, 611, 1, 0, 0, 0, 100, 633, 1, 0, 0, 0, 102,
		642, 1, 0, 0, 0, 104, 644, 1, 0, 0, 0, 106, 646, 1, 0, 0, 0, 108, 648,
		1, 0, 0, 0, 110, 650, 1, 0, 0, 0, 112, 652, 1, 0, 0, 0, 114, 654, 1, 0,
		0, 0, 116, 656, 1, 0, 0, 0, 118, 671, 1, 0, 0, 0, 120, 677, 1, 0, 0, 0,
		122, 679, 1, 0, 0, 0, 124, 681, 1, 0, 0, 0, 126, 683, 1, 0, 0, 0, 128,
		685, 1, 0, 0, 0, 130, 706, 1, 0, 0, 0, 132, 719, 1, 0, 0, 0, 134, 737,
		1, 0, 0, 0, 136, 755, 1, 0, 0, 0, 138, 773, 1, 0, 0, 0, 140, 792, 1, 0,
		0, 0, 142, 811, 1, 0, 0, 0, 144, 826, 1, 0, 0, 0, 146, 841, 1, 0, 0, 0,
		148, 851, 1, 0, 0, 0, 150, 857, 1, 0, 0, 0, 152, 859, 1, 0, 0, 0, 154,
		867, 1, 0, 0, 0, 156, 877, 1, 0, 0, 0, 158, 893, 1, 0, 0, 0, 160, 895,
		1, 0, 0, 0, 162, 898, 1, 0, 0, 0, 164, 902, 1, 0, 0, 0, 166, 938, 1, 0,
		0, 0, 168, 960, 1, 0, 0, 0, 170, 962, 1, 0, 0, 0, 172, 974, 1, 0, 0, 0,
		174, 990, 1, 0, 0, 0, 176, 1002, 1, 0, 0, 0, 178, 1004, 1, 0, 0, 0, 180,
		1009, 1, 0, 0, 0, 182, 1024, 1, 0, 0, 0, 184, 1035, 1, 0, 0, 0, 186, 1037,
		1, 0, 0, 0, 188, 1039, 1, 0, 0, 0, 190, 1041, 1, 0, 0, 0, 192, 1043, 1,
		0, 0, 0, 194, 1045, 1, 0, 0, 0, 196, 1049, 1, 0, 0, 0, 198, 1059, 1, 0,
		0, 0, 200, 1061, 1, 0, 0, 0, 202, 1063, 1, 0, 0, 0, 204, 1065, 1, 0, 0,
		0, 206, 1067, 1, 0, 0, 0, 208, 1069, 1, 0, 0, 0, 210, 1071, 1, 0, 0, 0,
		212, 1073, 1, 0, 0, 0, 214, 1075, 1, 0, 0, 0, 216, 1077, 1, 0, 0, 0, 218,
		1079, 1, 0, 0, 0, 220, 1081, 1, 0, 0, 0, 222, 1083, 1, 0, 0, 0, 224, 1085,
		1, 0, 0, 0, 226, 227, 3, 2, 1, 0, 227, 228, 5, 0, 0, 1, 228, 1, 1, 0, 0,
		0, 229, 230, 3, 40, 20, 0, 230, 231, 5, 5, 0, 0, 231, 232, 5, 36, 0, 0,
		232, 233, 5, 3, 0, 0, 233, 234, 3, 196, 98, 0, 234, 238, 5, 3, 0, 0, 235,
		237, 5, 1, 0, 0, 236, 235, 1, 0, 0, 0, 237, 240, 1, 0, 0, 0, 238, 239,
		1, 0, 0, 0, 238, 236, 1, 0, 0, 0, 239, 241, 1, 0, 0, 0, 240, 238, 1, 0,
		0, 0, 241, 245, 5, 29, 0, 0, 242, 244, 5, 1, 0, 0, 243, 242, 1, 0, 0, 0,
		244, 247, 1, 0, 0, 0, 245, 246, 1, 0, 0, 0, 245, 243, 1, 0, 0, 0, 246,
		248, 1, 0, 0, 0, 247, 245, 1, 0, 0, 0, 248, 250, 3, 4, 2, 0, 249, 251,
		5, 1, 0, 0, 250, 249, 1, 0, 0, 0, 250, 251, 1, 0, 0, 0, 251, 252, 1, 0,
		0, 0, 252, 253, 5, 7, 0, 0, 253, 3, 1, 0, 0, 0, 254, 256, 3, 6, 3, 0, 255,
		254, 1, 0, 0, 0, 256, 259, 1, 0, 0, 0, 257, 255, 1, 0, 0, 0, 257, 258,
		1, 0, 0, 0, 258, 5, 1, 0, 0, 0, 259, 257, 1, 0, 0, 0, 260, 261, 3, 8, 4,
		0, 261, 263, 3, 94, 47, 0, 262, 264, 5, 1, 0, 0, 263, 262, 1, 0, 0, 0,
		263, 264, 1, 0, 0, 0, 264, 265, 1, 0, 0, 0, 265, 267, 5, 29, 0, 0, 266,
		268, 5, 1, 0, 0, 267, 266, 1, 0, 0, 0, 267, 268, 1, 0, 0, 0, 268, 7, 1,
		0, 0, 0, 269, 273, 3, 10, 5, 0, 270, 272, 5, 1, 0, 0, 271, 270, 1, 0, 0,
		0, 272, 275, 1, 0, 0, 0, 273, 274, 1, 0, 0, 0, 273, 271, 1, 0, 0, 0, 274,
		276, 1, 0, 0, 0, 275, 273, 1, 0, 0, 0, 276, 280, 5, 5, 0, 0, 277, 279,
		5, 1, 0, 0, 278, 277, 1, 0, 0, 0, 279, 282, 1, 0, 0, 0, 280, 281, 1, 0,
		0, 0, 280, 278, 1, 0, 0, 0, 281, 283, 1, 0, 0, 0, 282, 280, 1, 0, 0, 0,
		283, 294, 3, 16, 8, 0, 284, 285, 5, 28, 0, 0, 285, 289, 3, 16, 8, 0, 286,
		288, 5, 1, 0, 0, 287, 286, 1, 0, 0, 0, 288, 291, 1, 0, 0, 0, 289, 290,
		1, 0, 0, 0, 289, 287, 1, 0, 0, 0, 290, 293, 1, 0, 0, 0, 291, 289, 1, 0,
		0, 0, 292, 284, 1, 0, 0, 0, 293, 296, 1, 0, 0, 0, 294, 292, 1, 0, 0, 0,
		294, 295, 1, 0, 0, 0, 295, 300, 1, 0, 0, 0, 296, 294, 1, 0, 0, 0, 297,
		299, 5, 1, 0, 0, 298, 297, 1, 0, 0, 0, 299, 302, 1, 0, 0, 0, 300, 301,
		1, 0, 0, 0, 300, 298, 1, 0, 0, 0, 301, 303, 1, 0, 0, 0, 302, 300, 1, 0,
		0, 0, 303, 304, 5, 7, 0, 0, 304, 9, 1, 0, 0, 0, 305, 308, 3, 12, 6, 0,
		306, 308, 3, 14, 7, 0, 307, 305, 1, 0, 0, 0, 307, 306, 1, 0, 0, 0, 308,
		11, 1, 0, 0, 0, 309, 310, 5, 79, 0, 0, 310, 13, 1, 0, 0, 0, 311, 312, 5,
		80, 0, 0, 312, 15, 1, 0, 0, 0, 313, 325, 3, 18, 9, 0, 314, 325, 3, 20,
		10, 0, 315, 325, 3, 22, 11, 0, 316, 325, 3, 24, 12, 0, 317, 325, 3, 26,
		13, 0, 318, 325, 3, 28, 14, 0, 319, 325, 3, 30, 15, 0, 320, 325, 3, 34,
		17, 0, 321, 325, 3, 32, 16, 0, 322, 325, 3, 38, 19, 0, 323, 325, 3, 36,
		18, 0, 324, 313, 1, 0, 0, 0, 324, 314, 1, 0, 0, 0, 324, 315, 1, 0, 0, 0,
		324, 316, 1, 0, 0, 0, 324, 317, 1, 0, 0, 0, 324, 318, 1, 0, 0, 0, 324,
		319, 1, 0, 0, 0, 324, 320, 1, 0, 0, 0, 324, 321, 1, 0, 0, 0, 324, 322,
		1, 0, 0, 0, 324, 323, 1, 0, 0, 0, 325, 17, 1, 0, 0, 0, 326, 327, 5, 81,
		0, 0, 327, 19, 1, 0, 0, 0, 328, 329, 5, 82, 0, 0, 329, 21, 1, 0, 0, 0,
		330, 331, 5, 83, 0, 0, 331, 23, 1, 0, 0, 0, 332, 333, 5, 84, 0, 0, 333,
		25, 1, 0, 0, 0, 334, 335, 5, 85, 0, 0, 335, 27, 1, 0, 0, 0, 336, 337, 5,
		86, 0, 0, 337, 29, 1, 0, 0, 0, 338, 339, 5, 87, 0, 0, 339, 31, 1, 0, 0,
		0, 340, 341, 5, 89, 0, 0, 341, 33, 1, 0, 0, 0, 342, 343, 5, 88, 0, 0, 343,
		35, 1, 0, 0, 0, 344, 345, 5, 44, 0, 0, 345, 37, 1, 0, 0, 0, 346, 347, 5,
		34, 0, 0, 347, 39, 1, 0, 0, 0, 348, 350, 3, 42, 21, 0, 349, 348, 1, 0,
		0, 0, 350, 353, 1, 0, 0, 0, 351, 349, 1, 0, 0, 0, 351, 352, 1, 0, 0, 0,
		352, 41, 1, 0, 0, 0, 353, 351, 1, 0, 0, 0, 354, 364, 3, 58, 29, 0, 355,
		364, 3, 60, 30, 0, 356, 364, 3, 50, 25, 0, 357, 364, 3, 52, 26, 0, 358,
		364, 3, 54, 27, 0, 359, 364, 3, 56, 28, 0, 360, 364, 3, 44, 22, 0, 361,
		364, 3, 46, 23, 0, 362, 364, 3, 48, 24, 0, 363, 354, 1, 0, 0, 0, 363, 355,
		1, 0, 0, 0, 363, 356, 1, 0, 0, 0, 363, 357, 1, 0, 0, 0, 363, 358, 1, 0,
		0, 0, 363, 359, 1, 0, 0, 0, 363, 360, 1, 0, 0, 0, 363, 361, 1, 0, 0, 0,
		363, 362, 1, 0, 0, 0, 364, 43, 1, 0, 0, 0, 365, 366, 5, 5, 0, 0, 366, 369,
		5, 48, 0, 0, 367, 370, 3, 200, 100, 0, 368, 370, 3, 202, 101, 0, 369, 367,
		1, 0, 0, 0, 369, 368, 1, 0, 0, 0, 370, 371, 1, 0, 0, 0, 371, 372, 3, 166,
		83, 0, 372, 373, 5, 7, 0, 0, 373, 45, 1, 0, 0, 0, 374, 375, 5, 5, 0, 0,
		375, 378, 5, 49, 0, 0, 376, 379, 3, 200, 100, 0, 377, 379, 3, 202, 101,
		0, 378, 376, 1, 0, 0, 0, 378, 377, 1, 0, 0, 0, 379, 380, 1, 0, 0, 0, 380,
		381, 5, 3, 0, 0, 381, 382, 3, 168, 84, 0, 382, 383, 5, 3, 0, 0, 383, 384,
		5, 7, 0, 0, 384, 47, 1, 0, 0, 0, 385, 386, 5, 5, 0, 0, 386, 389, 5, 50,
		0, 0, 387, 390, 3, 200, 100, 0, 388, 390, 3, 202, 101, 0, 389, 387, 1,
		0, 0, 0, 389, 388, 1, 0, 0, 0, 390, 391, 1, 0, 0, 0, 391, 392, 5, 3, 0,
		0, 392, 393, 3, 168, 84, 0, 393, 394, 5, 3, 0, 0, 394, 395, 5, 7, 0, 0,
		395, 49, 1, 0, 0, 0, 396, 397, 5, 5, 0, 0, 397, 400, 5, 53, 0, 0, 398,
		401, 3, 200, 100, 0, 399, 401, 3, 202, 101, 0, 400, 398, 1, 0, 0, 0, 400,
		399, 1, 0, 0, 0, 401, 402, 1, 0, 0, 0, 402, 403, 5, 3, 0, 0, 403, 404,
		3, 172, 86, 0, 404, 405, 5, 3, 0, 0, 405, 406, 5, 7, 0, 0, 406, 51, 1,
		0, 0, 0, 407, 408, 5, 5, 0, 0, 408, 409, 5, 54, 0, 0, 409, 410, 3, 200,
		100, 0, 410, 411, 5, 3, 0, 0, 411, 412, 3, 80, 40, 0, 412, 413, 5, 3, 0,
		0, 413, 414, 5, 7, 0, 0, 414, 53, 1, 0, 0, 0, 415, 416, 5, 5, 0, 0, 416,
		417, 5, 51, 0, 0, 417, 418, 3, 200, 100, 0, 418, 419, 5, 3, 0, 0, 419,
		420, 3, 62, 31, 0, 420, 421, 5, 3, 0, 0, 421, 422, 5, 7, 0, 0, 422, 55,
		1, 0, 0, 0, 423, 424, 5, 5, 0, 0, 424, 427, 5, 52, 0, 0, 425, 428, 3, 200,
		100, 0, 426, 428, 3, 202, 101, 0, 427, 425, 1, 0, 0, 0, 427, 426, 1, 0,
		0, 0, 428, 429, 1, 0, 0, 0, 429, 430, 3, 74, 37, 0, 430, 431, 5, 7, 0,
		0, 431, 57, 1, 0, 0, 0, 432, 433, 5, 5, 0, 0, 433, 436, 5, 55, 0, 0, 434,
		437, 3, 200, 100, 0, 435, 437, 3, 202, 101, 0, 436, 434, 1, 0, 0, 0, 436,
		435, 1, 0, 0, 0, 437, 438, 1, 0, 0, 0, 438, 439, 3, 72, 36, 0, 439, 440,
		5, 7, 0, 0, 440, 59, 1, 0, 0, 0, 441, 442, 5, 5, 0, 0, 442, 445, 5, 56,
		0, 0, 443, 446, 3, 200, 100, 0, 444, 446, 3, 202, 101, 0, 445, 443, 1,
		0, 0, 0, 445, 444, 1, 0, 0, 0, 446, 447, 1, 0, 0, 0, 447, 448, 3, 72, 36,
		0, 448, 449, 5, 7, 0, 0, 449, 61, 1, 0, 0, 0, 450, 455, 3, 64, 32, 0, 451,
		455, 3, 66, 33, 0, 452, 455, 3, 68, 34, 0, 453, 455, 3, 70, 35, 0, 454,
		450, 1, 0, 0, 0, 454, 451, 1, 0, 0, 0, 454, 452, 1, 0, 0, 0, 454, 453,
		1, 0, 0, 0, 455, 63, 1, 0, 0, 0, 456, 457, 5, 73, 0, 0, 457, 65, 1, 0,
		0, 0, 458, 459, 5, 75, 0, 0, 459, 67, 1, 0, 0, 0, 460, 461, 5, 77, 0, 0,
		461, 69, 1, 0, 0, 0, 462, 463, 5, 78, 0, 0, 463, 71, 1, 0, 0, 0, 464, 465,
		5, 3, 0, 0, 465, 471, 3, 76, 38, 0, 466, 467, 3, 222, 111, 0, 467, 468,
		3, 76, 38, 0, 468, 470, 1, 0, 0, 0, 469, 466, 1, 0, 0, 0, 470, 473, 1,
		0, 0, 0, 471, 469, 1, 0, 0, 0, 471, 472, 1, 0, 0, 0, 472, 474, 1, 0, 0,
		0, 473, 471, 1, 0, 0, 0, 474, 475, 5, 3, 0, 0, 475, 490, 1, 0, 0, 0, 476,
		477, 5, 3, 0, 0, 477, 478, 3, 76, 38, 0, 478, 486, 5, 3, 0, 0, 479, 480,
		3, 222, 111, 0, 480, 481, 5, 3, 0, 0, 481, 482, 3, 76, 38, 0, 482, 483,
		5, 3, 0, 0, 483, 485, 1, 0, 0, 0, 484, 479, 1, 0, 0, 0, 485, 488, 1, 0,
		0, 0, 486, 484, 1, 0, 0, 0, 486, 487, 1, 0, 0, 0, 487, 490, 1, 0, 0, 0,
		488, 486, 1, 0, 0, 0, 489, 464, 1, 0, 0, 0, 489, 476, 1, 0, 0, 0, 490,
		73, 1, 0, 0, 0, 491, 492, 5, 3, 0, 0, 492, 498, 3, 196, 98, 0, 493, 494,
		3, 222, 111, 0, 494, 495, 3, 196, 98, 0, 495, 497, 1, 0, 0, 0, 496, 493,
		1, 0, 0, 0, 497, 500, 1, 0, 0, 0, 498, 496, 1, 0, 0, 0, 498, 499, 1, 0,
		0, 0, 499, 501, 1, 0, 0, 0, 500, 498, 1, 0, 0, 0, 501, 502, 5, 3, 0, 0,
		502, 520, 1, 0, 0, 0, 503, 504, 5, 3, 0, 0, 504, 505, 3, 196, 98, 0, 505,
		513, 5, 3, 0, 0, 506, 507, 3, 222, 111, 0, 507, 508, 5, 3, 0, 0, 508, 509,
		3, 196, 98, 0, 509, 510, 5, 3, 0, 0, 510, 512, 1, 0, 0, 0, 511, 506, 1,
		0, 0, 0, 512, 515, 1, 0, 0, 0, 513, 511, 1, 0, 0, 0, 513, 514, 1, 0, 0,
		0, 514, 520, 1, 0, 0, 0, 515, 513, 1, 0, 0, 0, 516, 517, 5, 3, 0, 0, 517,
		518, 5, 30, 0, 0, 518, 520, 5, 3, 0, 0, 519, 491, 1, 0, 0, 0, 519, 503,
		1, 0, 0, 0, 519, 516, 1, 0, 0, 0, 520, 75, 1, 0, 0, 0, 521, 524, 3, 78,
		39, 0, 522, 523, 5, 8, 0, 0, 523, 525, 3, 78, 39, 0, 524, 522, 1, 0, 0,
		0, 525, 526, 1, 0, 0, 0, 526, 524, 1, 0, 0, 0, 526, 527, 1, 0, 0, 0, 527,
		77, 1, 0, 0, 0, 528, 529, 5, 95, 0, 0, 529, 79, 1, 0, 0, 0, 530, 534, 3,
		82, 41, 0, 531, 534, 3, 84, 42, 0, 532, 534, 3, 92, 46, 0, 533, 530, 1,
		0, 0, 0, 533, 531, 1, 0, 0, 0, 533, 532, 1, 0, 0, 0, 534, 81, 1, 0, 0,
		0, 535, 536, 3, 84, 42, 0, 536, 537, 7, 0, 0, 0, 537, 538, 3, 84, 42, 0,
		538, 83, 1, 0, 0, 0, 539, 540, 3, 86, 43, 0, 540, 546, 3, 92, 46, 0, 541,
		542, 3, 224, 112, 0, 542, 543, 3, 92, 46, 0, 543, 545, 1, 0, 0, 0, 544,
		541, 1, 0, 0, 0, 545, 548, 1, 0, 0, 0, 546, 544, 1, 0, 0, 0, 546, 547,
		1, 0, 0, 0, 547, 85, 1, 0, 0, 0, 548, 546, 1, 0, 0, 0, 549, 550, 3, 88,
		44, 0, 550, 551, 3, 200, 100, 0, 551, 556, 1, 0, 0, 0, 552, 553, 3, 90,
		45, 0, 553, 554, 3, 200, 100, 0, 554, 556, 1, 0, 0, 0, 555, 549, 1, 0,
		0, 0, 555, 552, 1, 0, 0, 0, 556, 87, 1, 0, 0, 0, 557, 558, 5, 84, 0, 0,
		558, 89, 1, 0, 0, 0, 559, 560, 5, 85, 0, 0, 560, 91, 1, 0, 0, 0, 561, 562,
		3, 196, 98, 0, 562, 563, 5, 9, 0, 0, 563, 564, 3, 172, 86, 0, 564, 93,
		1, 0, 0, 0, 565, 575, 3, 98, 49, 0, 566, 571, 3, 96, 48, 0, 567, 568, 7,
		1, 0, 0, 568, 570, 3, 96, 48, 0, 569, 567, 1, 0, 0, 0, 570, 573, 1, 0,
		0, 0, 571, 569, 1, 0, 0, 0, 571, 572, 1, 0, 0, 0, 572, 575, 1, 0, 0, 0,
		573, 571, 1, 0, 0, 0, 574, 565, 1, 0, 0, 0, 574, 566, 1, 0, 0, 0, 575,
		95, 1, 0, 0, 0, 576, 577, 5, 5, 0, 0, 577, 582, 3, 98, 49, 0, 578, 579,
		7, 1, 0, 0, 579, 581, 3, 98, 49, 0, 580, 578, 1, 0, 0, 0, 581, 584, 1,
		0, 0, 0, 582, 580, 1, 0, 0, 0, 582, 583, 1, 0, 0, 0, 583, 585, 1, 0, 0,
		0, 584, 582, 1, 0, 0, 0, 585, 586, 5, 7, 0, 0, 586, 595, 1, 0, 0, 0, 587,
		588, 5, 93, 0, 0, 588, 595, 3, 98, 49, 0, 589, 590, 5, 5, 0, 0, 590, 591,
		3, 98, 49, 0, 591, 592, 5, 7, 0, 0, 592, 595, 1, 0, 0, 0, 593, 595, 3,
		98, 49, 0, 594, 576, 1, 0, 0, 0, 594, 587, 1, 0, 0, 0, 594, 589, 1, 0,
		0, 0, 594, 593, 1, 0, 0, 0, 595, 97, 1, 0, 0, 0, 596, 597, 5, 5, 0, 0,
		597, 598, 3, 98, 49, 0, 598, 599, 5, 7, 0, 0, 599, 612, 1, 0, 0, 0, 600,
		612, 3, 130, 65, 0, 601, 612, 3, 136, 68, 0, 602, 612, 3, 134, 67, 0, 603,
		612, 3, 138, 69, 0, 604, 612, 3, 132, 66, 0, 605, 612, 3, 146, 73, 0, 606,
		612, 3, 144, 72, 0, 607, 612, 3, 142, 71, 0, 608, 612, 3, 100, 50, 0, 609,
		612, 3, 140, 70, 0, 610, 612, 3, 118, 59, 0, 611, 596, 1, 0, 0, 0, 611,
		600, 1, 0, 0, 0, 611, 601, 1, 0, 0, 0, 611, 602, 1, 0, 0, 0, 611, 603,
		1, 0, 0, 0, 611, 604, 1, 0, 0, 0, 611, 605, 1, 0, 0, 0, 611, 606, 1, 0,
		0, 0, 611, 607, 1, 0, 0, 0, 611, 608, 1, 0, 0, 0, 611, 609, 1, 0, 0, 0,
		611, 610, 1, 0, 0, 0, 612, 99, 1, 0, 0, 0, 613, 614, 5, 5, 0, 0, 614, 615,
		3, 100, 50, 0, 615, 616, 5, 7, 0, 0, 616, 634, 1, 0, 0, 0, 617, 620, 5,
		67, 0, 0, 618, 621, 3, 200, 100, 0, 619, 621, 3, 202, 101, 0, 620, 618,
		1, 0, 0, 0, 620, 619, 1, 0, 0, 0, 621, 622, 1, 0, 0, 0, 622, 623, 5, 3,
		0, 0, 623, 628, 3, 102, 51, 0, 624, 625, 5, 28, 0, 0, 625, 627, 3, 102,
		51, 0, 626, 624, 1, 0, 0, 0, 627, 630, 1, 0, 0, 0, 628, 626, 1, 0, 0, 0,
		628, 629, 1, 0, 0, 0, 629, 631, 1, 0, 0, 0, 630, 628, 1, 0, 0, 0, 631,
		632, 5, 3, 0, 0, 632, 634, 1, 0, 0, 0, 633, 613, 1, 0, 0, 0, 633, 617,
		1, 0, 0, 0, 634, 101, 1, 0, 0, 0, 635, 643, 3, 104, 52, 0, 636, 643, 3,
		106, 53, 0, 637, 643, 3, 108, 54, 0, 638, 643, 3, 110, 55, 0, 639, 643,
		3, 112, 56, 0, 640, 643, 3, 114, 57, 0, 641, 643, 3, 116, 58, 0, 642, 635,
		1, 0, 0, 0, 642, 636, 1, 0, 0, 0, 642, 637, 1, 0, 0, 0, 642, 638, 1, 0,
		0, 0, 642, 639, 1, 0, 0, 0, 642, 640, 1, 0, 0, 0, 642, 641, 1, 0, 0, 0,
		643, 103, 1, 0, 0, 0, 644, 645, 5, 37, 0, 0, 645, 105, 1, 0, 0, 0, 646,
		647, 5, 38, 0, 0, 647, 107, 1, 0, 0, 0, 648, 649, 5, 39, 0, 0, 649, 109,
		1, 0, 0, 0, 650, 651, 5, 40, 0, 0, 651, 111, 1, 0, 0, 0, 652, 653, 5, 41,
		0, 0, 653, 113, 1, 0, 0, 0, 654, 655, 5, 42, 0, 0, 655, 115, 1, 0, 0, 0,
		656, 657, 5, 43, 0, 0, 657, 117, 1, 0, 0, 0, 658, 659, 5, 5, 0, 0, 659,
		660, 3, 118, 59, 0, 660, 661, 5, 7, 0, 0, 661, 672, 1, 0, 0, 0, 662, 665,
		5, 65, 0, 0, 663, 666, 3, 200, 100, 0, 664, 666, 3, 202, 101, 0, 665, 663,
		1, 0, 0, 0, 665, 664, 1, 0, 0, 0, 666, 667, 1, 0, 0, 0, 667, 668, 5, 3,
		0, 0, 668, 669, 3, 120, 60, 0, 669, 670, 5, 3, 0, 0, 670, 672, 1, 0, 0,
		0, 671, 658, 1, 0, 0, 0, 671, 662, 1, 0, 0, 0, 672, 119, 1, 0, 0, 0, 673,
		678, 3, 122, 61, 0, 674, 678, 3, 124, 62, 0, 675, 678, 3, 126, 63, 0, 676,
		678, 3, 128, 64, 0, 677, 673, 1, 0, 0, 0, 677, 674, 1, 0, 0, 0, 677, 675,
		1, 0, 0, 0, 677, 676, 1, 0, 0, 0, 678, 121, 1, 0, 0, 0, 679, 680, 5, 44,
		0, 0, 680, 123, 1, 0, 0, 0, 681, 682, 5, 45, 0, 0, 682, 125, 1, 0, 0, 0,
		683, 684, 5, 46, 0, 0, 684, 127, 1, 0, 0, 0, 685, 686, 5, 47, 0, 0, 686,
		129, 1, 0, 0, 0, 687, 688, 5, 5, 0, 0, 688, 689, 3, 130, 65, 0, 689, 690,
		5, 7, 0, 0, 690, 707, 1, 0, 0, 0, 691, 694, 5, 57, 0, 0, 692, 695, 3, 200,
		100, 0, 693, 695, 3, 202, 101, 0, 694, 692, 1, 0, 0, 0, 694, 693, 1, 0,
		0, 0, 695, 697, 1, 0, 0, 0, 696, 698, 5, 1, 0, 0, 697, 696, 1, 0, 0, 0,
		697, 698, 1, 0, 0, 0, 698, 704, 1, 0, 0, 0, 699, 705, 3, 166, 83, 0, 700,
		701, 5, 3, 0, 0, 701, 702, 3, 158, 79, 0, 702, 703, 5, 3, 0, 0, 703, 705,
		1, 0, 0, 0, 704, 699, 1, 0, 0, 0, 704, 700, 1, 0, 0, 0, 705, 707, 1, 0,
		0, 0, 706, 687, 1, 0, 0, 0, 706, 691, 1, 0, 0, 0, 707, 131, 1, 0, 0, 0,
		708, 709, 5, 5, 0, 0, 709, 710, 3, 132, 66, 0, 710, 711, 5, 7, 0, 0, 711,
		720, 1, 0, 0, 0, 712, 715, 5, 59, 0, 0, 713, 716, 3, 200, 100, 0, 714,
		716, 3, 202, 101, 0, 715, 713, 1, 0, 0, 0, 715, 714, 1, 0, 0, 0, 716, 717,
		1, 0, 0, 0, 717, 718, 3, 166, 83, 0, 718, 720, 1, 0, 0, 0, 719, 708, 1,
		0, 0, 0, 719, 712, 1, 0, 0, 0, 720, 133, 1, 0, 0, 0, 721, 722, 5, 5, 0,
		0, 722, 723, 3, 134, 67, 0, 723, 724, 5, 7, 0, 0, 724, 738, 1, 0, 0, 0,
		725, 728, 5, 58, 0, 0, 726, 729, 3, 200, 100, 0, 727, 729, 3, 202, 101,
		0, 728, 726, 1, 0, 0, 0, 728, 727, 1, 0, 0, 0, 729, 735, 1, 0, 0, 0, 730,
		736, 3, 166, 83, 0, 731, 732, 5, 3, 0, 0, 732, 733, 3, 158, 79, 0, 733,
		734, 5, 3, 0, 0, 734, 736, 1, 0, 0, 0, 735, 730, 1, 0, 0, 0, 735, 731,
		1, 0, 0, 0, 736, 738, 1, 0, 0, 0, 737, 721, 1, 0, 0, 0, 737, 725, 1, 0,
		0, 0, 738, 135, 1, 0, 0, 0, 739, 740, 5, 5, 0, 0, 740, 741, 3, 136, 68,
		0, 741, 742, 5, 7, 0, 0, 742, 756, 1, 0, 0, 0, 743, 746, 5, 60, 0, 0, 744,
		747, 3, 200, 100, 0, 745, 747, 3, 202, 101, 0, 746, 744, 1, 0, 0, 0, 746,
		745, 1, 0, 0, 0, 747, 748, 1, 0, 0, 0, 748, 751, 5, 3, 0, 0, 749, 752,
		3, 182, 91, 0, 750, 752, 3, 178, 89, 0, 751, 749, 1, 0, 0, 0, 751, 750,
		1, 0, 0, 0, 752, 753, 1, 0, 0, 0, 753, 754, 5, 3, 0, 0, 754, 756, 1, 0,
		0, 0, 755, 739, 1, 0, 0, 0, 755, 743, 1, 0, 0, 0, 756, 137, 1, 0, 0, 0,
		757, 758, 5, 5, 0, 0, 758, 759, 3, 138, 69, 0, 759, 760, 5, 7, 0, 0, 760,
		774, 1, 0, 0, 0, 761, 764, 5, 61, 0, 0, 762, 765, 3, 200, 100, 0, 763,
		765, 3, 202, 101, 0, 764, 762, 1, 0, 0, 0, 764, 763, 1, 0, 0, 0, 765, 766,
		1, 0, 0, 0, 766, 769, 5, 3, 0, 0, 767, 770, 3, 182, 91, 0, 768, 770, 3,
		178, 89, 0, 769, 767, 1, 0, 0, 0, 769, 768, 1, 0, 0, 0, 770, 771, 1, 0,
		0, 0, 771, 772, 5, 3, 0, 0, 772, 774, 1, 0, 0, 0, 773, 757, 1, 0, 0, 0,
		773, 761, 1, 0, 0, 0, 774, 139, 1, 0, 0, 0, 775, 776, 5, 5, 0, 0, 776,
		777, 3, 140, 70, 0, 777, 778, 5, 7, 0, 0, 778, 793, 1, 0, 0, 0, 779, 786,
		5, 62, 0, 0, 780, 787, 3, 200, 100, 0, 781, 787, 3, 202, 101, 0, 782, 787,
		3, 204, 102, 0, 783, 787, 3, 208, 104, 0, 784, 787, 3, 206, 103, 0, 785,
		787, 3, 210, 105, 0, 786, 780, 1, 0, 0, 0, 786, 781, 1, 0, 0, 0, 786, 782,
		1, 0, 0, 0, 786, 783, 1, 0, 0, 0, 786, 784, 1, 0, 0, 0, 786, 785, 1, 0,
		0, 0, 787, 788, 1, 0, 0, 0, 788, 789, 5, 3, 0, 0, 789, 790, 5, 95, 0, 0,
		790, 791, 5, 3, 0, 0, 791, 793, 1, 0, 0, 0, 792, 775, 1, 0, 0, 0, 792,
		779, 1, 0, 0, 0, 793, 141, 1, 0, 0, 0, 794, 795, 5, 5, 0, 0, 795, 796,
		3, 142, 71, 0, 796, 797, 5, 7, 0, 0, 797, 812, 1, 0, 0, 0, 798, 805, 5,
		66, 0, 0, 799, 806, 3, 200, 100, 0, 800, 806, 3, 202, 101, 0, 801, 806,
		3, 204, 102, 0, 802, 806, 3, 208, 104, 0, 803, 806, 3, 206, 103, 0, 804,
		806, 3, 210, 105, 0, 805, 799, 1, 0, 0, 0, 805, 800, 1, 0, 0, 0, 805, 801,
		1, 0, 0, 0, 805, 802, 1, 0, 0, 0, 805, 803, 1, 0, 0, 0, 805, 804, 1, 0,
		0, 0, 806, 807, 1, 0, 0, 0, 807, 808, 5, 3, 0, 0, 808, 809, 5, 95, 0, 0,
		809, 810, 5, 3, 0, 0, 810, 812, 1, 0, 0, 0, 811, 794, 1, 0, 0, 0, 811,
		798, 1, 0, 0, 0, 812, 143, 1, 0, 0, 0, 813, 814, 5, 5, 0, 0, 814, 815,
		3, 144, 72, 0, 815, 816, 5, 7, 0, 0, 816, 827, 1, 0, 0, 0, 817, 820, 5,
		64, 0, 0, 818, 821, 3, 200, 100, 0, 819, 821, 3, 202, 101, 0, 820, 818,
		1, 0, 0, 0, 820, 819, 1, 0, 0, 0, 821, 822, 1, 0, 0, 0, 822, 823, 5, 3,
		0, 0, 823, 824, 3, 148, 74, 0, 824, 825, 5, 3, 0, 0, 825, 827, 1, 0, 0,
		0, 826, 813, 1, 0, 0, 0, 826, 817, 1, 0, 0, 0, 827, 145, 1, 0, 0, 0, 828,
		829, 5, 5, 0, 0, 829, 830, 3, 146, 73, 0, 830, 831, 5, 7, 0, 0, 831, 842,
		1, 0, 0, 0, 832, 835, 5, 63, 0, 0, 833, 836, 3, 200, 100, 0, 834, 836,
		3, 202, 101, 0, 835, 833, 1, 0, 0, 0, 835, 834, 1, 0, 0, 0, 836, 837, 1,
		0, 0, 0, 837, 838, 5, 3, 0, 0, 838, 839, 3, 156, 78, 0, 839, 840, 5, 3,
		0, 0, 840, 842, 1, 0, 0, 0, 841, 828, 1, 0, 0, 0, 841, 832, 1, 0, 0, 0,
		842, 147, 1, 0, 0, 0, 843, 848, 3, 150, 75, 0, 844, 845, 5, 28, 0, 0, 845,
		847, 3, 150, 75, 0, 846, 844, 1, 0, 0, 0, 847, 850, 1, 0, 0, 0, 848, 846,
		1, 0, 0, 0, 848, 849, 1, 0, 0, 0, 849, 852, 1, 0, 0, 0, 850, 848, 1, 0,
		0, 0, 851, 843, 1, 0, 0, 0, 852, 853, 1, 0, 0, 0, 853, 854, 1, 0, 0, 0,
		853, 851, 1, 0, 0, 0, 854, 149, 1, 0, 0, 0, 855, 858, 3, 152, 76, 0, 856,
		858, 3, 154, 77, 0, 857, 855, 1, 0, 0, 0, 857, 856, 1, 0, 0, 0, 858, 151,
		1, 0, 0, 0, 859, 860, 5, 95, 0, 0, 860, 864, 5, 8, 0, 0, 861, 863, 7, 2,
		0, 0, 862, 861, 1, 0, 0, 0, 863, 866, 1, 0, 0, 0, 864, 862, 1, 0, 0, 0,
		864, 865, 1, 0, 0, 0, 865, 153, 1, 0, 0, 0, 866, 864, 1, 0, 0, 0, 867,
		870, 3, 196, 98, 0, 868, 869, 5, 9, 0, 0, 869, 871, 3, 196, 98, 0, 870,
		868, 1, 0, 0, 0, 871, 872, 1, 0, 0, 0, 872, 870, 1, 0, 0, 0, 872, 873,
		1, 0, 0, 0, 873, 875, 1, 0, 0, 0, 874, 876, 5, 9, 0, 0, 875, 874, 1, 0,
		0, 0, 875, 876, 1, 0, 0, 0, 876, 155, 1, 0, 0, 0, 877, 880, 3, 196, 98,
		0, 878, 879, 5, 8, 0, 0, 879, 881, 3, 196, 98, 0, 880, 878, 1, 0, 0, 0,
		881, 882, 1, 0, 0, 0, 882, 880, 1, 0, 0, 0, 882, 883, 1, 0, 0, 0, 883,
		157, 1, 0, 0, 0, 884, 885, 3, 168, 84, 0, 885, 886, 3, 164, 82, 0, 886,
		887, 3, 162, 81, 0, 887, 888, 3, 160, 80, 0, 888, 894, 1, 0, 0, 0, 889,
		890, 3, 168, 84, 0, 890, 891, 5, 2, 0, 0, 891, 892, 3, 182, 91, 0, 892,
		894, 1, 0, 0, 0, 893, 884, 1, 0, 0, 0, 893, 889, 1, 0, 0, 0, 894, 159,
		1, 0, 0, 0, 895, 896, 5, 2, 0, 0, 896, 897, 3, 172, 86, 0, 897, 161, 1,
		0, 0, 0, 898, 900, 5, 2, 0, 0, 899, 901, 7, 3, 0, 0, 900, 899, 1, 0, 0,
		0, 900, 901, 1, 0, 0, 0, 901, 163, 1, 0, 0, 0, 902, 911, 5, 2, 0, 0, 903,
		908, 3, 196, 98, 0, 904, 905, 5, 28, 0, 0, 905, 907, 3, 196, 98, 0, 906,
		904, 1, 0, 0, 0, 907, 910, 1, 0, 0, 0, 908, 906, 1, 0, 0, 0, 908, 909,
		1, 0, 0, 0, 909, 912, 1, 0, 0, 0, 910, 908, 1, 0, 0, 0, 911, 903, 1, 0,
		0, 0, 911, 912, 1, 0, 0, 0, 912, 165, 1, 0, 0, 0, 913, 914, 5, 3, 0, 0,
		914, 920, 3, 168, 84, 0, 915, 916, 3, 222, 111, 0, 916, 917, 3, 168, 84,
		0, 917, 919, 1, 0, 0, 0, 918, 915, 1, 0, 0, 0, 919, 922, 1, 0, 0, 0, 920,
		918, 1, 0, 0, 0, 920, 921, 1, 0, 0, 0, 921, 923, 1, 0, 0, 0, 922, 920,
		1, 0, 0, 0, 923, 924, 5, 3, 0, 0, 924, 939, 1, 0, 0, 0, 925, 926, 5, 3,
		0, 0, 926, 927, 3, 168, 84, 0, 927, 935, 5, 3, 0, 0, 928, 929, 3, 222,
		111, 0, 929, 930, 5, 3, 0, 0, 930, 931, 3, 168, 84, 0, 931, 932, 5, 3,
		0, 0, 932, 934, 1, 0, 0, 0, 933, 928, 1, 0, 0, 0, 934, 937, 1, 0, 0, 0,
		935, 933, 1, 0, 0, 0, 935, 936, 1, 0, 0, 0, 936, 939, 1, 0, 0, 0, 937,
		935, 1, 0, 0, 0, 938, 913, 1, 0, 0, 0, 938, 925, 1, 0, 0, 0, 939, 167,
		1, 0, 0, 0, 940, 941, 5, 31, 0, 0, 941, 949, 3, 176, 88, 0, 942, 945, 5,
		28, 0, 0, 943, 946, 3, 176, 88, 0, 944, 946, 3, 170, 85, 0, 945, 943, 1,
		0, 0, 0, 945, 944, 1, 0, 0, 0, 946, 948, 1, 0, 0, 0, 947, 942, 1, 0, 0,
		0, 948, 951, 1, 0, 0, 0, 949, 947, 1, 0, 0, 0, 949, 950, 1, 0, 0, 0, 950,
		961, 1, 0, 0, 0, 951, 949, 1, 0, 0, 0, 952, 953, 5, 31, 0, 0, 953, 961,
		5, 33, 0, 0, 954, 955, 5, 31, 0, 0, 955, 961, 5, 34, 0, 0, 956, 957, 5,
		31, 0, 0, 957, 961, 5, 35, 0, 0, 958, 959, 5, 31, 0, 0, 959, 961, 5, 32,
		0, 0, 960, 940, 1, 0, 0, 0, 960, 952, 1, 0, 0, 0, 960, 954, 1, 0, 0, 0,
		960, 956, 1, 0, 0, 0, 960, 958, 1, 0, 0, 0, 961, 169, 1, 0, 0, 0, 962,
		963, 5, 90, 0, 0, 963, 171, 1, 0, 0, 0, 964, 965, 5, 5, 0, 0, 965, 966,
		3, 174, 87, 0, 966, 967, 5, 7, 0, 0, 967, 975, 1, 0, 0, 0, 968, 970, 3,
		174, 87, 0, 969, 968, 1, 0, 0, 0, 970, 973, 1, 0, 0, 0, 971, 969, 1, 0,
		0, 0, 971, 972, 1, 0, 0, 0, 972, 975, 1, 0, 0, 0, 973, 971, 1, 0, 0, 0,
		974, 964, 1, 0, 0, 0, 974, 971, 1, 0, 0, 0, 975, 173, 1, 0, 0, 0, 976,
		978, 5, 5, 0, 0, 977, 979, 7, 4, 0, 0, 978, 977, 1, 0, 0, 0, 978, 979,
		1, 0, 0, 0, 979, 980, 1, 0, 0, 0, 980, 981, 3, 174, 87, 0, 981, 982, 5,
		7, 0, 0, 982, 984, 1, 0, 0, 0, 983, 976, 1, 0, 0, 0, 984, 985, 1, 0, 0,
		0, 985, 986, 1, 0, 0, 0, 985, 983, 1, 0, 0, 0, 986, 991, 1, 0, 0, 0, 987,
		988, 5, 26, 0, 0, 988, 991, 3, 174, 87, 0, 989, 991, 3, 176, 88, 0, 990,
		983, 1, 0, 0, 0, 990, 987, 1, 0, 0, 0, 990, 989, 1, 0, 0, 0, 991, 175,
		1, 0, 0, 0, 992, 993, 5, 5, 0, 0, 993, 994, 3, 196, 98, 0, 994, 995, 3,
		198, 99, 0, 995, 996, 3, 196, 98, 0, 996, 997, 5, 7, 0, 0, 997, 1003, 1,
		0, 0, 0, 998, 999, 3, 196, 98, 0, 999, 1000, 3, 198, 99, 0, 1000, 1001,
		3, 196, 98, 0, 1001, 1003, 1, 0, 0, 0, 1002, 992, 1, 0, 0, 0, 1002, 998,
		1, 0, 0, 0, 1003, 177, 1, 0, 0, 0, 1004, 1005, 5, 32, 0, 0, 1005, 1006,
		3, 180, 90, 0, 1006, 1007, 5, 8, 0, 0, 1007, 1008, 3, 182, 91, 0, 1008,
		179, 1, 0, 0, 0, 1009, 1018, 5, 4, 0, 0, 1010, 1015, 5, 95, 0, 0, 1011,
		1012, 5, 28, 0, 0, 1012, 1014, 5, 95, 0, 0, 1013, 1011, 1, 0, 0, 0, 1014,
		1017, 1, 0, 0, 0, 1015, 1013, 1, 0, 0, 0, 1015, 1016, 1, 0, 0, 0, 1016,
		1019, 1, 0, 0, 0, 1017, 1015, 1, 0, 0, 0, 1018, 1010, 1, 0, 0, 0, 1019,
		1020, 1, 0, 0, 0, 1020, 1021, 1, 0, 0, 0, 1020, 1018, 1, 0, 0, 0, 1021,
		1022, 1, 0, 0, 0, 1022, 1023, 5, 6, 0, 0, 1023, 181, 1, 0, 0, 0, 1024,
		1025, 3, 196, 98, 0, 1025, 1028, 5, 21, 0, 0, 1026, 1029, 3, 184, 92, 0,
		1027, 1029, 3, 196, 98, 0, 1028, 1026, 1, 0, 0, 0, 1028, 1027, 1, 0, 0,
		0, 1029, 183, 1, 0, 0, 0, 1030, 1036, 3, 186, 93, 0, 1031, 1036, 3, 192,
		96, 0, 1032, 1036, 3, 188, 94, 0, 1033, 1036, 3, 190, 95, 0, 1034, 1036,
		3, 194, 97, 0, 1035, 1030, 1, 0, 0, 0, 1035, 1031, 1, 0, 0, 0, 1035, 1032,
		1, 0, 0, 0, 1035, 1033, 1, 0, 0, 0, 1035, 1034, 1, 0, 0, 0, 1036, 185,
		1, 0, 0, 0, 1037, 1038, 5, 68, 0, 0, 1038, 187, 1, 0, 0, 0, 1039, 1040,
		5, 70, 0, 0, 1040, 189, 1, 0, 0, 0, 1041, 1042, 5, 71, 0, 0, 1042, 191,
		1, 0, 0, 0, 1043, 1044, 5, 69, 0, 0, 1044, 193, 1, 0, 0, 0, 1045, 1046,
		5, 72, 0, 0, 1046, 195, 1, 0, 0, 0, 1047, 1050, 5, 96, 0, 0, 1048, 1050,
		5, 30, 0, 0, 1049, 1047, 1, 0, 0, 0, 1049, 1048, 1, 0, 0, 0, 1050, 197,
		1, 0, 0, 0, 1051, 1060, 3, 200, 100, 0, 1052, 1060, 3, 208, 104, 0, 1053,
		1060, 3, 210, 105, 0, 1054, 1060, 3, 212, 106, 0, 1055, 1060, 3, 214, 107,
		0, 1056, 1060, 3, 218, 109, 0, 1057, 1060, 3, 220, 110, 0, 1058, 1060,
		3, 216, 108, 0, 1059, 1051, 1, 0, 0, 0, 1059, 1052, 1, 0, 0, 0, 1059, 1053,
		1, 0, 0, 0, 1059, 1054, 1, 0, 0, 0, 1059, 1055, 1, 0, 0, 0, 1059, 1056,
		1, 0, 0, 0, 1059, 1057, 1, 0, 0, 0, 1059, 1058, 1, 0, 0, 0, 1060, 199,
		1, 0, 0, 0, 1061, 1062, 5, 11, 0, 0, 1062, 201, 1, 0, 0, 0, 1063, 1064,
		5, 12, 0, 0, 1064, 203, 1, 0, 0, 0, 1065, 1066, 5, 13, 0, 0, 1066, 205,
		1, 0, 0, 0, 1067, 1068, 5, 14, 0, 0, 1068, 207, 1, 0, 0, 0, 1069, 1070,
		5, 16, 0, 0, 1070, 209, 1, 0, 0, 0, 1071, 1072, 5, 17, 0, 0, 1072, 211,
		1, 0, 0, 0, 1073, 1074, 5, 15, 0, 0, 1074, 213, 1, 0, 0, 0, 1075, 1076,
		5, 9, 0, 0, 1076, 215, 1, 0, 0, 0, 1077, 1078, 5, 19, 0, 0, 1078, 217,
		1, 0, 0, 0, 1079, 1080, 5, 20, 0, 0, 1080, 219, 1, 0, 0, 0, 1081, 1082,
		5, 18, 0, 0, 1082, 221, 1, 0, 0, 0, 1083, 1084, 5, 23, 0, 0, 1084, 223,
		1, 0, 0, 0, 1085, 1086, 5, 22, 0, 0, 1086, 225, 1, 0, 0, 0, 97, 238, 245,
		250, 257, 263, 267, 273, 280, 289, 294, 300, 307, 324, 351, 363, 369, 378,
		389, 400, 427, 436, 445, 454, 471, 486, 489, 498, 513, 519, 526, 533, 546,
		555, 571, 574, 582, 594, 611, 620, 628, 633, 642, 665, 671, 677, 694, 697,
		704, 706, 715, 719, 728, 735, 737, 746, 751, 755, 764, 769, 773, 786, 792,
		805, 811, 820, 826, 835, 841, 848, 853, 857, 864, 872, 875, 882, 893, 900,
		908, 911, 920, 935, 938, 945, 949, 960, 971, 974, 978, 985, 990, 1002,
		1015, 1020, 1028, 1035, 1049, 1059,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// ACIParserInit initializes any static state used to implement ACIParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewACIParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func ACIParserInit() {
	staticData := &ACIParserParserStaticData
	staticData.once.Do(aciparserParserInit)
}

// NewACIParser produces a new parser instance for the optional input antlr.TokenStream.
func NewACIParser(input antlr.TokenStream) *ACIParser {
	ACIParserInit()
	this := new(ACIParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &ACIParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "ACIParser.g4"

	return this
}

// ACIParser tokens.
const (
	ACIParserEOF                       = antlr.TokenEOF
	ACIParserWHSP                      = 1
	ACIParserQMARK                     = 2
	ACIParserDQUOTE                    = 3
	ACIParserLBRAK                     = 4
	ACIParserLPAREN                    = 5
	ACIParserRBRAK                     = 6
	ACIParserRPAREN                    = 7
	ACIParserDOT                       = 8
	ACIParserCOLON                     = 9
	ACIParserTILDE                     = 10
	ACIParserEQ                        = 11
	ACIParserNE                        = 12
	ACIParserGT                        = 13
	ACIParserLT                        = 14
	ACIParserAPX                       = 15
	ACIParserGE                        = 16
	ACIParserLE                        = 17
	ACIParserEXA                       = 18
	ACIParserEXO                       = 19
	ACIParserEXD                       = 20
	ACIParserHASH                      = 21
	ACIParserSYMBOLIC_AND              = 22
	ACIParserSYMBOLIC_OR               = 23
	ACIParserFILTER_AND                = 24
	ACIParserFILTER_OR                 = 25
	ACIParserFILTER_NOT                = 26
	ACIParserFILTER_OPERATOR           = 27
	ACIParserCOMMA                     = 28
	ACIParserSEMI                      = 29
	ACIParserSTAR                      = 30
	ACIParserLOCAL_LDAP_SCHEME         = 31
	ACIParserPARENT                    = 32
	ACIParserANYONE                    = 33
	ACIParserALL_USERS                 = 34
	ACIParserSELF                      = 35
	ACIParserANCHOR                    = 36
	ACIParserSUNDAY                    = 37
	ACIParserMONDAY                    = 38
	ACIParserTUESDAY                   = 39
	ACIParserWEDNESDAY                 = 40
	ACIParserTHURSDAY                  = 41
	ACIParserFRIDAY                    = 42
	ACIParserSATURDAY                  = 43
	ACIParserANONYMOUS                 = 44
	ACIParserSIMPLE                    = 45
	ACIParserSSL                       = 46
	ACIParserSASL                      = 47
	ACIParserTARGET                    = 48
	ACIParserTARGET_TO                 = 49
	ACIParserTARGET_FROM               = 50
	ACIParserTARGET_SCOPE              = 51
	ACIParserTARGET_ATTR               = 52
	ACIParserTARGET_FILTER             = 53
	ACIParserTARGET_ATTR_FILTERS       = 54
	ACIParserTARGET_CONTROL            = 55
	ACIParserTARGET_EXTENDED_OPERATION = 56
	ACIParserBIND_USER_DN              = 57
	ACIParserBIND_GROUP_DN             = 58
	ACIParserBIND_ROLE_DN              = 59
	ACIParserBIND_USER_ATTR            = 60
	ACIParserBIND_GROUP_ATTR           = 61
	ACIParserBIND_SSF                  = 62
	ACIParserBIND_DNS                  = 63
	ACIParserBIND_IP                   = 64
	ACIParserBIND_AUTH_METHOD          = 65
	ACIParserBIND_TIME_OF_DAY          = 66
	ACIParserBIND_DAY_OF_WEEK          = 67
	ACIParserBINDTYPE_USER_DN          = 68
	ACIParserBINDTYPE_GROUP_DN         = 69
	ACIParserBINDTYPE_ROLE_DN          = 70
	ACIParserBINDTYPE_SELF_DN          = 71
	ACIParserBINDTYPE_LDAP_URL         = 72
	ACIParserBASE_OBJECT_SCOPE         = 73
	ACIParserONE_LEVEL_SCOPE           = 74
	ACIParserONE_LEVEL_TARGET_SCOPE    = 75
	ACIParserSUB_TREE_SCOPE            = 76
	ACIParserSUB_TREE_TARGET_SCOPE     = 77
	ACIParserSUBORDINATE_TARGET_SCOPE  = 78
	ACIParserALLOW_ACCESS              = 79
	ACIParserDENY_ACCESS               = 80
	ACIParserSEARCH_PRIVILEGE          = 81
	ACIParserREAD_PRIVILEGE            = 82
	ACIParserCOMPARE_PRIVILEGE         = 83
	ACIParserADD_PRIVILEGE             = 84
	ACIParserDELETE_PRIVILEGE          = 85
	ACIParserSELFWRITE_PRIVILEGE       = 86
	ACIParserPROXY_PRIVILEGE           = 87
	ACIParserIMPORT_PRIVILEGE          = 88
	ACIParserEXPORT_PRIVILEGE          = 89
	ACIParserRDN_MACROS                = 90
	ACIParserBOOLEAN_AND               = 91
	ACIParserBOOLEAN_OR                = 92
	ACIParserBOOLEAN_NOT               = 93
	ACIParserWHITESPACE                = 94
	ACIParserINT                       = 95
	ACIParserKEY_OR_VALUE              = 96
)

// ACIParser rules.
const (
	ACIParserRULE_parse                       = 0
	ACIParserRULE_instruction                 = 1
	ACIParserRULE_permissionBindRules         = 2
	ACIParserRULE_permissionBindRule          = 3
	ACIParserRULE_permission                  = 4
	ACIParserRULE_permissionDisposition       = 5
	ACIParserRULE_allow                       = 6
	ACIParserRULE_deny                        = 7
	ACIParserRULE_accessPrivileges            = 8
	ACIParserRULE_searchPrivilege             = 9
	ACIParserRULE_readPrivilege               = 10
	ACIParserRULE_comparePrivilege            = 11
	ACIParserRULE_addPrivilege                = 12
	ACIParserRULE_deletePrivilege             = 13
	ACIParserRULE_selfWritePrivilege          = 14
	ACIParserRULE_proxyPrivilege              = 15
	ACIParserRULE_exportPrivilege             = 16
	ACIParserRULE_importPrivilege             = 17
	ACIParserRULE_noPrivileges                = 18
	ACIParserRULE_allPrivileges               = 19
	ACIParserRULE_targetRules                 = 20
	ACIParserRULE_targetRule                  = 21
	ACIParserRULE_target                      = 22
	ACIParserRULE_targetTo                    = 23
	ACIParserRULE_targetFrom                  = 24
	ACIParserRULE_targetFilter                = 25
	ACIParserRULE_targetAttrFilters           = 26
	ACIParserRULE_targetScope                 = 27
	ACIParserRULE_targetAttributes            = 28
	ACIParserRULE_targetControl               = 29
	ACIParserRULE_targetExtendedOperation     = 30
	ACIParserRULE_targetSearchScopes          = 31
	ACIParserRULE_baseTargetScope             = 32
	ACIParserRULE_oneLevelTargetScope         = 33
	ACIParserRULE_subTreeTargetScope          = 34
	ACIParserRULE_subordinateTargetScope      = 35
	ACIParserRULE_objectIdentifiers           = 36
	ACIParserRULE_targetedAttributes          = 37
	ACIParserRULE_objectIdentifier            = 38
	ACIParserRULE_numberForm                  = 39
	ACIParserRULE_targetAttrFiltersValue      = 40
	ACIParserRULE_attributeFilters            = 41
	ACIParserRULE_attributeFilterSet          = 42
	ACIParserRULE_attributeFilterOperation    = 43
	ACIParserRULE_addFilterOperation          = 44
	ACIParserRULE_delFilterOperation          = 45
	ACIParserRULE_attributeFilter             = 46
	ACIParserRULE_bindRule                    = 47
	ACIParserRULE_bindRuleExprParen           = 48
	ACIParserRULE_bindRuleExpr                = 49
	ACIParserRULE_bindDayOfWeek               = 50
	ACIParserRULE_doW                         = 51
	ACIParserRULE_sun                         = 52
	ACIParserRULE_mon                         = 53
	ACIParserRULE_tues                        = 54
	ACIParserRULE_wed                         = 55
	ACIParserRULE_thur                        = 56
	ACIParserRULE_fri                         = 57
	ACIParserRULE_sat                         = 58
	ACIParserRULE_bindAuthMethod              = 59
	ACIParserRULE_authenticationMethods       = 60
	ACIParserRULE_anonAuth                    = 61
	ACIParserRULE_simpleAuth                  = 62
	ACIParserRULE_sSLAuth                     = 63
	ACIParserRULE_sASLAuth                    = 64
	ACIParserRULE_bindUserDN                  = 65
	ACIParserRULE_bindRoleDN                  = 66
	ACIParserRULE_bindGroupDN                 = 67
	ACIParserRULE_bindUserAttr                = 68
	ACIParserRULE_bindGroupAttr               = 69
	ACIParserRULE_bindSecurityStrengthFactor  = 70
	ACIParserRULE_bindTimeOfDay               = 71
	ACIParserRULE_bindIP                      = 72
	ACIParserRULE_bindDNS                     = 73
	ACIParserRULE_iPAddresses                 = 74
	ACIParserRULE_iPAddress                   = 75
	ACIParserRULE_iPv4Address                 = 76
	ACIParserRULE_iPv6Address                 = 77
	ACIParserRULE_fQDN                        = 78
	ACIParserRULE_lDAPURI                     = 79
	ACIParserRULE_uRISearchFilter             = 80
	ACIParserRULE_uRISearchScopes             = 81
	ACIParserRULE_uRIAttributeList            = 82
	ACIParserRULE_distinguishedNames          = 83
	ACIParserRULE_distinguishedName           = 84
	ACIParserRULE_rDNMacros                   = 85
	ACIParserRULE_lDAPFilter                  = 86
	ACIParserRULE_lDAPFilterExpr              = 87
	ACIParserRULE_aVAOrRDN                    = 88
	ACIParserRULE_inheritance                 = 89
	ACIParserRULE_inheritanceLevels           = 90
	ACIParserRULE_attributeBindTypeOrValue    = 91
	ACIParserRULE_bindTypes                   = 92
	ACIParserRULE_userDN                      = 93
	ACIParserRULE_roleDN                      = 94
	ACIParserRULE_selfDN                      = 95
	ACIParserRULE_groupDN                     = 96
	ACIParserRULE_lDAPURL                     = 97
	ACIParserRULE_attributeTypeOrValue        = 98
	ACIParserRULE_attributeComparisonOperator = 99
	ACIParserRULE_equalTo                     = 100
	ACIParserRULE_notEqualTo                  = 101
	ACIParserRULE_greaterThan                 = 102
	ACIParserRULE_lessThan                    = 103
	ACIParserRULE_greaterThanOrEqual          = 104
	ACIParserRULE_lessThanOrEqual             = 105
	ACIParserRULE_approximate                 = 106
	ACIParserRULE_extensibleRule              = 107
	ACIParserRULE_extensibleRuleDNOID         = 108
	ACIParserRULE_extensibleRuleDN            = 109
	ACIParserRULE_extensibleRuleAttr          = 110
	ACIParserRULE_oRDelimiter                 = 111
	ACIParserRULE_aNDDelimiter                = 112
)

// IParseContext is an interface to support dynamic dispatch.
type IParseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Instruction() IInstructionContext
	EOF() antlr.TerminalNode

	// IsParseContext differentiates from other interfaces.
	IsParseContext()
}

type ParseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParseContext() *ParseContext {
	var p = new(ParseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_parse
	return p
}

func InitEmptyParseContext(p *ParseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_parse
}

func (*ParseContext) IsParseContext() {}

func NewParseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParseContext {
	var p = new(ParseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_parse

	return p
}

func (s *ParseContext) GetParser() antlr.Parser { return s.parser }

func (s *ParseContext) Instruction() IInstructionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstructionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstructionContext)
}

func (s *ParseContext) EOF() antlr.TerminalNode {
	return s.GetToken(ACIParserEOF, 0)
}

func (s *ParseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParse(s)
	}
}

func (s *ParseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParse(s)
	}
}

func (p *ACIParser) Parse() (localctx IParseContext) {
	localctx = NewParseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ACIParserRULE_parse)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(226)
		p.Instruction()
	}
	{
		p.SetState(227)
		p.Match(ACIParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInstructionContext is an interface to support dynamic dispatch.
type IInstructionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsInstructionContext differentiates from other interfaces.
	IsInstructionContext()
}

type InstructionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstructionContext() *InstructionContext {
	var p = new(InstructionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_instruction
	return p
}

func InitEmptyInstructionContext(p *InstructionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_instruction
}

func (*InstructionContext) IsInstructionContext() {}

func NewInstructionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstructionContext {
	var p = new(InstructionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_instruction

	return p
}

func (s *InstructionContext) GetParser() antlr.Parser { return s.parser }

func (s *InstructionContext) CopyAll(ctx *InstructionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *InstructionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstructionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AciContext struct {
	InstructionContext
}

func NewAciContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AciContext {
	var p = new(AciContext)

	InitEmptyInstructionContext(&p.InstructionContext)
	p.parser = parser
	p.CopyAll(ctx.(*InstructionContext))

	return p
}

func (s *AciContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AciContext) TargetRules() ITargetRulesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetRulesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetRulesContext)
}

func (s *AciContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *AciContext) ANCHOR() antlr.TerminalNode {
	return s.GetToken(ACIParserANCHOR, 0)
}

func (s *AciContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *AciContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *AciContext) AttributeTypeOrValue() IAttributeTypeOrValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeTypeOrValueContext)
}

func (s *AciContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ACIParserSEMI, 0)
}

func (s *AciContext) PermissionBindRules() IPermissionBindRulesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPermissionBindRulesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPermissionBindRulesContext)
}

func (s *AciContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *AciContext) AllWHSP() []antlr.TerminalNode {
	return s.GetTokens(ACIParserWHSP)
}

func (s *AciContext) WHSP(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserWHSP, i)
}

func (s *AciContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAci(s)
	}
}

func (s *AciContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAci(s)
	}
}

func (p *ACIParser) Instruction() (localctx IInstructionContext) {
	localctx = NewInstructionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ACIParserRULE_instruction)
	var _la int

	var _alt int

	localctx = NewAciContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(229)
		p.TargetRules()
	}
	{
		p.SetState(230)
		p.Match(ACIParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(231)
		p.Match(ACIParserANCHOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(232)
		p.Match(ACIParserDQUOTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(233)
		p.AttributeTypeOrValue()
	}
	{
		p.SetState(234)
		p.Match(ACIParserDQUOTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(238)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1+1 {
			{
				p.SetState(235)
				p.Match(ACIParserWHSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(240)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(241)
		p.Match(ACIParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(245)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1+1 {
			{
				p.SetState(242)
				p.Match(ACIParserWHSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(247)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(248)
		p.PermissionBindRules()
	}
	p.SetState(250)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ACIParserWHSP {
		{
			p.SetState(249)
			p.Match(ACIParserWHSP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(252)
		p.Match(ACIParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPermissionBindRulesContext is an interface to support dynamic dispatch.
type IPermissionBindRulesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPermissionBindRulesContext differentiates from other interfaces.
	IsPermissionBindRulesContext()
}

type PermissionBindRulesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPermissionBindRulesContext() *PermissionBindRulesContext {
	var p = new(PermissionBindRulesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_permissionBindRules
	return p
}

func InitEmptyPermissionBindRulesContext(p *PermissionBindRulesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_permissionBindRules
}

func (*PermissionBindRulesContext) IsPermissionBindRulesContext() {}

func NewPermissionBindRulesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PermissionBindRulesContext {
	var p = new(PermissionBindRulesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_permissionBindRules

	return p
}

func (s *PermissionBindRulesContext) GetParser() antlr.Parser { return s.parser }

func (s *PermissionBindRulesContext) CopyAll(ctx *PermissionBindRulesContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PermissionBindRulesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PermissionBindRulesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Permission_bind_rulesContext struct {
	PermissionBindRulesContext
}

func NewPermission_bind_rulesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Permission_bind_rulesContext {
	var p = new(Permission_bind_rulesContext)

	InitEmptyPermissionBindRulesContext(&p.PermissionBindRulesContext)
	p.parser = parser
	p.CopyAll(ctx.(*PermissionBindRulesContext))

	return p
}

func (s *Permission_bind_rulesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Permission_bind_rulesContext) AllPermissionBindRule() []IPermissionBindRuleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPermissionBindRuleContext); ok {
			len++
		}
	}

	tst := make([]IPermissionBindRuleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPermissionBindRuleContext); ok {
			tst[i] = t.(IPermissionBindRuleContext)
			i++
		}
	}

	return tst
}

func (s *Permission_bind_rulesContext) PermissionBindRule(i int) IPermissionBindRuleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPermissionBindRuleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPermissionBindRuleContext)
}

func (s *Permission_bind_rulesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterPermission_bind_rules(s)
	}
}

func (s *Permission_bind_rulesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitPermission_bind_rules(s)
	}
}

func (p *ACIParser) PermissionBindRules() (localctx IPermissionBindRulesContext) {
	localctx = NewPermissionBindRulesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ACIParserRULE_permissionBindRules)
	var _la int

	localctx = NewPermission_bind_rulesContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(257)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ACIParserALLOW_ACCESS || _la == ACIParserDENY_ACCESS {
		{
			p.SetState(254)
			p.PermissionBindRule()
		}

		p.SetState(259)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPermissionBindRuleContext is an interface to support dynamic dispatch.
type IPermissionBindRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPermissionBindRuleContext differentiates from other interfaces.
	IsPermissionBindRuleContext()
}

type PermissionBindRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPermissionBindRuleContext() *PermissionBindRuleContext {
	var p = new(PermissionBindRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_permissionBindRule
	return p
}

func InitEmptyPermissionBindRuleContext(p *PermissionBindRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_permissionBindRule
}

func (*PermissionBindRuleContext) IsPermissionBindRuleContext() {}

func NewPermissionBindRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PermissionBindRuleContext {
	var p = new(PermissionBindRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_permissionBindRule

	return p
}

func (s *PermissionBindRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *PermissionBindRuleContext) CopyAll(ctx *PermissionBindRuleContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PermissionBindRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PermissionBindRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Permission_and_bind_rule_pairContext struct {
	PermissionBindRuleContext
}

func NewPermission_and_bind_rule_pairContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Permission_and_bind_rule_pairContext {
	var p = new(Permission_and_bind_rule_pairContext)

	InitEmptyPermissionBindRuleContext(&p.PermissionBindRuleContext)
	p.parser = parser
	p.CopyAll(ctx.(*PermissionBindRuleContext))

	return p
}

func (s *Permission_and_bind_rule_pairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Permission_and_bind_rule_pairContext) Permission() IPermissionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPermissionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPermissionContext)
}

func (s *Permission_and_bind_rule_pairContext) BindRule() IBindRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindRuleContext)
}

func (s *Permission_and_bind_rule_pairContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ACIParserSEMI, 0)
}

func (s *Permission_and_bind_rule_pairContext) AllWHSP() []antlr.TerminalNode {
	return s.GetTokens(ACIParserWHSP)
}

func (s *Permission_and_bind_rule_pairContext) WHSP(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserWHSP, i)
}

func (s *Permission_and_bind_rule_pairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterPermission_and_bind_rule_pair(s)
	}
}

func (s *Permission_and_bind_rule_pairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitPermission_and_bind_rule_pair(s)
	}
}

func (p *ACIParser) PermissionBindRule() (localctx IPermissionBindRuleContext) {
	localctx = NewPermissionBindRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ACIParserRULE_permissionBindRule)
	var _la int

	localctx = NewPermission_and_bind_rule_pairContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(260)
		p.Permission()
	}
	{
		p.SetState(261)
		p.BindRule()
	}
	p.SetState(263)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ACIParserWHSP {
		{
			p.SetState(262)
			p.Match(ACIParserWHSP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(265)
		p.Match(ACIParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(267)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(266)
			p.Match(ACIParserWHSP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPermissionContext is an interface to support dynamic dispatch.
type IPermissionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPermissionContext differentiates from other interfaces.
	IsPermissionContext()
}

type PermissionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPermissionContext() *PermissionContext {
	var p = new(PermissionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_permission
	return p
}

func InitEmptyPermissionContext(p *PermissionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_permission
}

func (*PermissionContext) IsPermissionContext() {}

func NewPermissionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PermissionContext {
	var p = new(PermissionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_permission

	return p
}

func (s *PermissionContext) GetParser() antlr.Parser { return s.parser }

func (s *PermissionContext) CopyAll(ctx *PermissionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PermissionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PermissionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Permission_expressionContext struct {
	PermissionContext
}

func NewPermission_expressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Permission_expressionContext {
	var p = new(Permission_expressionContext)

	InitEmptyPermissionContext(&p.PermissionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PermissionContext))

	return p
}

func (s *Permission_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Permission_expressionContext) PermissionDisposition() IPermissionDispositionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPermissionDispositionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPermissionDispositionContext)
}

func (s *Permission_expressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Permission_expressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Permission_expressionContext) AllAccessPrivileges() []IAccessPrivilegesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAccessPrivilegesContext); ok {
			len++
		}
	}

	tst := make([]IAccessPrivilegesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAccessPrivilegesContext); ok {
			tst[i] = t.(IAccessPrivilegesContext)
			i++
		}
	}

	return tst
}

func (s *Permission_expressionContext) AccessPrivileges(i int) IAccessPrivilegesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessPrivilegesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessPrivilegesContext)
}

func (s *Permission_expressionContext) AllWHSP() []antlr.TerminalNode {
	return s.GetTokens(ACIParserWHSP)
}

func (s *Permission_expressionContext) WHSP(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserWHSP, i)
}

func (s *Permission_expressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ACIParserCOMMA)
}

func (s *Permission_expressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserCOMMA, i)
}

func (s *Permission_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterPermission_expression(s)
	}
}

func (s *Permission_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitPermission_expression(s)
	}
}

func (p *ACIParser) Permission() (localctx IPermissionContext) {
	localctx = NewPermissionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ACIParserRULE_permission)
	var _la int

	var _alt int

	localctx = NewPermission_expressionContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(269)
		p.PermissionDisposition()
	}
	p.SetState(273)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1+1 {
			{
				p.SetState(270)
				p.Match(ACIParserWHSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(275)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(276)
		p.Match(ACIParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	p.SetState(280)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1+1 {
			{
				p.SetState(277)
				p.Match(ACIParserWHSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(282)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(283)
		p.AccessPrivileges()
	}
	p.SetState(294)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ACIParserCOMMA {
		{
			p.SetState(284)
			p.Match(ACIParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(285)
			p.AccessPrivileges()
		}
		p.SetState(289)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1+1 {
				{
					p.SetState(286)
					p.Match(ACIParserWHSP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(291)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

		p.SetState(296)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

	p.SetState(300)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1+1 {
			{
				p.SetState(297)
				p.Match(ACIParserWHSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(302)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(303)
		p.Match(ACIParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPermissionDispositionContext is an interface to support dynamic dispatch.
type IPermissionDispositionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPermissionDispositionContext differentiates from other interfaces.
	IsPermissionDispositionContext()
}

type PermissionDispositionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPermissionDispositionContext() *PermissionDispositionContext {
	var p = new(PermissionDispositionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_permissionDisposition
	return p
}

func InitEmptyPermissionDispositionContext(p *PermissionDispositionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_permissionDisposition
}

func (*PermissionDispositionContext) IsPermissionDispositionContext() {}

func NewPermissionDispositionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PermissionDispositionContext {
	var p = new(PermissionDispositionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_permissionDisposition

	return p
}

func (s *PermissionDispositionContext) GetParser() antlr.Parser { return s.parser }

func (s *PermissionDispositionContext) CopyAll(ctx *PermissionDispositionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PermissionDispositionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PermissionDispositionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Deny_accessContext struct {
	PermissionDispositionContext
}

func NewDeny_accessContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Deny_accessContext {
	var p = new(Deny_accessContext)

	InitEmptyPermissionDispositionContext(&p.PermissionDispositionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PermissionDispositionContext))

	return p
}

func (s *Deny_accessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Deny_accessContext) Deny() IDenyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDenyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDenyContext)
}

func (s *Deny_accessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterDeny_access(s)
	}
}

func (s *Deny_accessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitDeny_access(s)
	}
}

type Allow_accessContext struct {
	PermissionDispositionContext
}

func NewAllow_accessContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Allow_accessContext {
	var p = new(Allow_accessContext)

	InitEmptyPermissionDispositionContext(&p.PermissionDispositionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PermissionDispositionContext))

	return p
}

func (s *Allow_accessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Allow_accessContext) Allow() IAllowContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAllowContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAllowContext)
}

func (s *Allow_accessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAllow_access(s)
	}
}

func (s *Allow_accessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAllow_access(s)
	}
}

func (p *ACIParser) PermissionDisposition() (localctx IPermissionDispositionContext) {
	localctx = NewPermissionDispositionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ACIParserRULE_permissionDisposition)
	p.SetState(307)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserALLOW_ACCESS:
		localctx = NewAllow_accessContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(305)
			p.Allow()
		}

	case ACIParserDENY_ACCESS:
		localctx = NewDeny_accessContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(306)
			p.Deny()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAllowContext is an interface to support dynamic dispatch.
type IAllowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALLOW_ACCESS() antlr.TerminalNode

	// IsAllowContext differentiates from other interfaces.
	IsAllowContext()
}

type AllowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAllowContext() *AllowContext {
	var p = new(AllowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_allow
	return p
}

func InitEmptyAllowContext(p *AllowContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_allow
}

func (*AllowContext) IsAllowContext() {}

func NewAllowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AllowContext {
	var p = new(AllowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_allow

	return p
}

func (s *AllowContext) GetParser() antlr.Parser { return s.parser }

func (s *AllowContext) ALLOW_ACCESS() antlr.TerminalNode {
	return s.GetToken(ACIParserALLOW_ACCESS, 0)
}

func (s *AllowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AllowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AllowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAllow(s)
	}
}

func (s *AllowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAllow(s)
	}
}

func (p *ACIParser) Allow() (localctx IAllowContext) {
	localctx = NewAllowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ACIParserRULE_allow)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(309)
		p.Match(ACIParserALLOW_ACCESS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDenyContext is an interface to support dynamic dispatch.
type IDenyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DENY_ACCESS() antlr.TerminalNode

	// IsDenyContext differentiates from other interfaces.
	IsDenyContext()
}

type DenyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDenyContext() *DenyContext {
	var p = new(DenyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_deny
	return p
}

func InitEmptyDenyContext(p *DenyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_deny
}

func (*DenyContext) IsDenyContext() {}

func NewDenyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DenyContext {
	var p = new(DenyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_deny

	return p
}

func (s *DenyContext) GetParser() antlr.Parser { return s.parser }

func (s *DenyContext) DENY_ACCESS() antlr.TerminalNode {
	return s.GetToken(ACIParserDENY_ACCESS, 0)
}

func (s *DenyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DenyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DenyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterDeny(s)
	}
}

func (s *DenyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitDeny(s)
	}
}

func (p *ACIParser) Deny() (localctx IDenyContext) {
	localctx = NewDenyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ACIParserRULE_deny)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(311)
		p.Match(ACIParserDENY_ACCESS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAccessPrivilegesContext is an interface to support dynamic dispatch.
type IAccessPrivilegesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAccessPrivilegesContext differentiates from other interfaces.
	IsAccessPrivilegesContext()
}

type AccessPrivilegesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccessPrivilegesContext() *AccessPrivilegesContext {
	var p = new(AccessPrivilegesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_accessPrivileges
	return p
}

func InitEmptyAccessPrivilegesContext(p *AccessPrivilegesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_accessPrivileges
}

func (*AccessPrivilegesContext) IsAccessPrivilegesContext() {}

func NewAccessPrivilegesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AccessPrivilegesContext {
	var p = new(AccessPrivilegesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_accessPrivileges

	return p
}

func (s *AccessPrivilegesContext) GetParser() antlr.Parser { return s.parser }

func (s *AccessPrivilegesContext) CopyAll(ctx *AccessPrivilegesContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AccessPrivilegesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AccessPrivilegesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Selfwrite_privilegeContext struct {
	AccessPrivilegesContext
}

func NewSelfwrite_privilegeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Selfwrite_privilegeContext {
	var p = new(Selfwrite_privilegeContext)

	InitEmptyAccessPrivilegesContext(&p.AccessPrivilegesContext)
	p.parser = parser
	p.CopyAll(ctx.(*AccessPrivilegesContext))

	return p
}

func (s *Selfwrite_privilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Selfwrite_privilegeContext) SelfWritePrivilege() ISelfWritePrivilegeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelfWritePrivilegeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelfWritePrivilegeContext)
}

func (s *Selfwrite_privilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSelfwrite_privilege(s)
	}
}

func (s *Selfwrite_privilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSelfwrite_privilege(s)
	}
}

type Export_privilegeContext struct {
	AccessPrivilegesContext
}

func NewExport_privilegeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Export_privilegeContext {
	var p = new(Export_privilegeContext)

	InitEmptyAccessPrivilegesContext(&p.AccessPrivilegesContext)
	p.parser = parser
	p.CopyAll(ctx.(*AccessPrivilegesContext))

	return p
}

func (s *Export_privilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Export_privilegeContext) ExportPrivilege() IExportPrivilegeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportPrivilegeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportPrivilegeContext)
}

func (s *Export_privilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterExport_privilege(s)
	}
}

func (s *Export_privilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitExport_privilege(s)
	}
}

type All_privilegesContext struct {
	AccessPrivilegesContext
}

func NewAll_privilegesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *All_privilegesContext {
	var p = new(All_privilegesContext)

	InitEmptyAccessPrivilegesContext(&p.AccessPrivilegesContext)
	p.parser = parser
	p.CopyAll(ctx.(*AccessPrivilegesContext))

	return p
}

func (s *All_privilegesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *All_privilegesContext) AllPrivileges() IAllPrivilegesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAllPrivilegesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAllPrivilegesContext)
}

func (s *All_privilegesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAll_privileges(s)
	}
}

func (s *All_privilegesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAll_privileges(s)
	}
}

type No_privilegesContext struct {
	AccessPrivilegesContext
}

func NewNo_privilegesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *No_privilegesContext {
	var p = new(No_privilegesContext)

	InitEmptyAccessPrivilegesContext(&p.AccessPrivilegesContext)
	p.parser = parser
	p.CopyAll(ctx.(*AccessPrivilegesContext))

	return p
}

func (s *No_privilegesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *No_privilegesContext) NoPrivileges() INoPrivilegesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INoPrivilegesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INoPrivilegesContext)
}

func (s *No_privilegesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterNo_privileges(s)
	}
}

func (s *No_privilegesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitNo_privileges(s)
	}
}

type Import_privilegeContext struct {
	AccessPrivilegesContext
}

func NewImport_privilegeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Import_privilegeContext {
	var p = new(Import_privilegeContext)

	InitEmptyAccessPrivilegesContext(&p.AccessPrivilegesContext)
	p.parser = parser
	p.CopyAll(ctx.(*AccessPrivilegesContext))

	return p
}

func (s *Import_privilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_privilegeContext) ImportPrivilege() IImportPrivilegeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportPrivilegeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportPrivilegeContext)
}

func (s *Import_privilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterImport_privilege(s)
	}
}

func (s *Import_privilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitImport_privilege(s)
	}
}

type Add_privilegeContext struct {
	AccessPrivilegesContext
}

func NewAdd_privilegeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Add_privilegeContext {
	var p = new(Add_privilegeContext)

	InitEmptyAccessPrivilegesContext(&p.AccessPrivilegesContext)
	p.parser = parser
	p.CopyAll(ctx.(*AccessPrivilegesContext))

	return p
}

func (s *Add_privilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Add_privilegeContext) AddPrivilege() IAddPrivilegeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddPrivilegeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddPrivilegeContext)
}

func (s *Add_privilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAdd_privilege(s)
	}
}

func (s *Add_privilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAdd_privilege(s)
	}
}

type Search_privilegeContext struct {
	AccessPrivilegesContext
}

func NewSearch_privilegeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Search_privilegeContext {
	var p = new(Search_privilegeContext)

	InitEmptyAccessPrivilegesContext(&p.AccessPrivilegesContext)
	p.parser = parser
	p.CopyAll(ctx.(*AccessPrivilegesContext))

	return p
}

func (s *Search_privilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Search_privilegeContext) SearchPrivilege() ISearchPrivilegeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearchPrivilegeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearchPrivilegeContext)
}

func (s *Search_privilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSearch_privilege(s)
	}
}

func (s *Search_privilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSearch_privilege(s)
	}
}

type Compare_privilegeContext struct {
	AccessPrivilegesContext
}

func NewCompare_privilegeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Compare_privilegeContext {
	var p = new(Compare_privilegeContext)

	InitEmptyAccessPrivilegesContext(&p.AccessPrivilegesContext)
	p.parser = parser
	p.CopyAll(ctx.(*AccessPrivilegesContext))

	return p
}

func (s *Compare_privilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Compare_privilegeContext) ComparePrivilege() IComparePrivilegeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparePrivilegeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparePrivilegeContext)
}

func (s *Compare_privilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterCompare_privilege(s)
	}
}

func (s *Compare_privilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitCompare_privilege(s)
	}
}

type Proxy_privilegeContext struct {
	AccessPrivilegesContext
}

func NewProxy_privilegeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Proxy_privilegeContext {
	var p = new(Proxy_privilegeContext)

	InitEmptyAccessPrivilegesContext(&p.AccessPrivilegesContext)
	p.parser = parser
	p.CopyAll(ctx.(*AccessPrivilegesContext))

	return p
}

func (s *Proxy_privilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Proxy_privilegeContext) ProxyPrivilege() IProxyPrivilegeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProxyPrivilegeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProxyPrivilegeContext)
}

func (s *Proxy_privilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterProxy_privilege(s)
	}
}

func (s *Proxy_privilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitProxy_privilege(s)
	}
}

type Read_privilegeContext struct {
	AccessPrivilegesContext
}

func NewRead_privilegeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Read_privilegeContext {
	var p = new(Read_privilegeContext)

	InitEmptyAccessPrivilegesContext(&p.AccessPrivilegesContext)
	p.parser = parser
	p.CopyAll(ctx.(*AccessPrivilegesContext))

	return p
}

func (s *Read_privilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Read_privilegeContext) ReadPrivilege() IReadPrivilegeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReadPrivilegeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReadPrivilegeContext)
}

func (s *Read_privilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterRead_privilege(s)
	}
}

func (s *Read_privilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitRead_privilege(s)
	}
}

type Delete_privilegeContext struct {
	AccessPrivilegesContext
}

func NewDelete_privilegeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Delete_privilegeContext {
	var p = new(Delete_privilegeContext)

	InitEmptyAccessPrivilegesContext(&p.AccessPrivilegesContext)
	p.parser = parser
	p.CopyAll(ctx.(*AccessPrivilegesContext))

	return p
}

func (s *Delete_privilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delete_privilegeContext) DeletePrivilege() IDeletePrivilegeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeletePrivilegeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeletePrivilegeContext)
}

func (s *Delete_privilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterDelete_privilege(s)
	}
}

func (s *Delete_privilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitDelete_privilege(s)
	}
}

func (p *ACIParser) AccessPrivileges() (localctx IAccessPrivilegesContext) {
	localctx = NewAccessPrivilegesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ACIParserRULE_accessPrivileges)
	p.SetState(324)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserSEARCH_PRIVILEGE:
		localctx = NewSearch_privilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(313)
			p.SearchPrivilege()
		}

	case ACIParserREAD_PRIVILEGE:
		localctx = NewRead_privilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(314)
			p.ReadPrivilege()
		}

	case ACIParserCOMPARE_PRIVILEGE:
		localctx = NewCompare_privilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(315)
			p.ComparePrivilege()
		}

	case ACIParserADD_PRIVILEGE:
		localctx = NewAdd_privilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(316)
			p.AddPrivilege()
		}

	case ACIParserDELETE_PRIVILEGE:
		localctx = NewDelete_privilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(317)
			p.DeletePrivilege()
		}

	case ACIParserSELFWRITE_PRIVILEGE:
		localctx = NewSelfwrite_privilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(318)
			p.SelfWritePrivilege()
		}

	case ACIParserPROXY_PRIVILEGE:
		localctx = NewProxy_privilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(319)
			p.ProxyPrivilege()
		}

	case ACIParserIMPORT_PRIVILEGE:
		localctx = NewImport_privilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(320)
			p.ImportPrivilege()
		}

	case ACIParserEXPORT_PRIVILEGE:
		localctx = NewExport_privilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(321)
			p.ExportPrivilege()
		}

	case ACIParserALL_USERS:
		localctx = NewAll_privilegesContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(322)
			p.AllPrivileges()
		}

	case ACIParserANONYMOUS:
		localctx = NewNo_privilegesContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(323)
			p.NoPrivileges()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISearchPrivilegeContext is an interface to support dynamic dispatch.
type ISearchPrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEARCH_PRIVILEGE() antlr.TerminalNode

	// IsSearchPrivilegeContext differentiates from other interfaces.
	IsSearchPrivilegeContext()
}

type SearchPrivilegeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySearchPrivilegeContext() *SearchPrivilegeContext {
	var p = new(SearchPrivilegeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_searchPrivilege
	return p
}

func InitEmptySearchPrivilegeContext(p *SearchPrivilegeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_searchPrivilege
}

func (*SearchPrivilegeContext) IsSearchPrivilegeContext() {}

func NewSearchPrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SearchPrivilegeContext {
	var p = new(SearchPrivilegeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_searchPrivilege

	return p
}

func (s *SearchPrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *SearchPrivilegeContext) SEARCH_PRIVILEGE() antlr.TerminalNode {
	return s.GetToken(ACIParserSEARCH_PRIVILEGE, 0)
}

func (s *SearchPrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchPrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SearchPrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSearchPrivilege(s)
	}
}

func (s *SearchPrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSearchPrivilege(s)
	}
}

func (p *ACIParser) SearchPrivilege() (localctx ISearchPrivilegeContext) {
	localctx = NewSearchPrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ACIParserRULE_searchPrivilege)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(326)
		p.Match(ACIParserSEARCH_PRIVILEGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReadPrivilegeContext is an interface to support dynamic dispatch.
type IReadPrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ_PRIVILEGE() antlr.TerminalNode

	// IsReadPrivilegeContext differentiates from other interfaces.
	IsReadPrivilegeContext()
}

type ReadPrivilegeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadPrivilegeContext() *ReadPrivilegeContext {
	var p = new(ReadPrivilegeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_readPrivilege
	return p
}

func InitEmptyReadPrivilegeContext(p *ReadPrivilegeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_readPrivilege
}

func (*ReadPrivilegeContext) IsReadPrivilegeContext() {}

func NewReadPrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadPrivilegeContext {
	var p = new(ReadPrivilegeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_readPrivilege

	return p
}

func (s *ReadPrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadPrivilegeContext) READ_PRIVILEGE() antlr.TerminalNode {
	return s.GetToken(ACIParserREAD_PRIVILEGE, 0)
}

func (s *ReadPrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadPrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadPrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterReadPrivilege(s)
	}
}

func (s *ReadPrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitReadPrivilege(s)
	}
}

func (p *ACIParser) ReadPrivilege() (localctx IReadPrivilegeContext) {
	localctx = NewReadPrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ACIParserRULE_readPrivilege)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(328)
		p.Match(ACIParserREAD_PRIVILEGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparePrivilegeContext is an interface to support dynamic dispatch.
type IComparePrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMPARE_PRIVILEGE() antlr.TerminalNode

	// IsComparePrivilegeContext differentiates from other interfaces.
	IsComparePrivilegeContext()
}

type ComparePrivilegeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparePrivilegeContext() *ComparePrivilegeContext {
	var p = new(ComparePrivilegeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_comparePrivilege
	return p
}

func InitEmptyComparePrivilegeContext(p *ComparePrivilegeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_comparePrivilege
}

func (*ComparePrivilegeContext) IsComparePrivilegeContext() {}

func NewComparePrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparePrivilegeContext {
	var p = new(ComparePrivilegeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_comparePrivilege

	return p
}

func (s *ComparePrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparePrivilegeContext) COMPARE_PRIVILEGE() antlr.TerminalNode {
	return s.GetToken(ACIParserCOMPARE_PRIVILEGE, 0)
}

func (s *ComparePrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparePrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparePrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterComparePrivilege(s)
	}
}

func (s *ComparePrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitComparePrivilege(s)
	}
}

func (p *ACIParser) ComparePrivilege() (localctx IComparePrivilegeContext) {
	localctx = NewComparePrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ACIParserRULE_comparePrivilege)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(330)
		p.Match(ACIParserCOMPARE_PRIVILEGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddPrivilegeContext is an interface to support dynamic dispatch.
type IAddPrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD_PRIVILEGE() antlr.TerminalNode

	// IsAddPrivilegeContext differentiates from other interfaces.
	IsAddPrivilegeContext()
}

type AddPrivilegeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddPrivilegeContext() *AddPrivilegeContext {
	var p = new(AddPrivilegeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_addPrivilege
	return p
}

func InitEmptyAddPrivilegeContext(p *AddPrivilegeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_addPrivilege
}

func (*AddPrivilegeContext) IsAddPrivilegeContext() {}

func NewAddPrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddPrivilegeContext {
	var p = new(AddPrivilegeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_addPrivilege

	return p
}

func (s *AddPrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *AddPrivilegeContext) ADD_PRIVILEGE() antlr.TerminalNode {
	return s.GetToken(ACIParserADD_PRIVILEGE, 0)
}

func (s *AddPrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddPrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddPrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAddPrivilege(s)
	}
}

func (s *AddPrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAddPrivilege(s)
	}
}

func (p *ACIParser) AddPrivilege() (localctx IAddPrivilegeContext) {
	localctx = NewAddPrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ACIParserRULE_addPrivilege)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(332)
		p.Match(ACIParserADD_PRIVILEGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeletePrivilegeContext is an interface to support dynamic dispatch.
type IDeletePrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELETE_PRIVILEGE() antlr.TerminalNode

	// IsDeletePrivilegeContext differentiates from other interfaces.
	IsDeletePrivilegeContext()
}

type DeletePrivilegeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeletePrivilegeContext() *DeletePrivilegeContext {
	var p = new(DeletePrivilegeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_deletePrivilege
	return p
}

func InitEmptyDeletePrivilegeContext(p *DeletePrivilegeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_deletePrivilege
}

func (*DeletePrivilegeContext) IsDeletePrivilegeContext() {}

func NewDeletePrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeletePrivilegeContext {
	var p = new(DeletePrivilegeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_deletePrivilege

	return p
}

func (s *DeletePrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *DeletePrivilegeContext) DELETE_PRIVILEGE() antlr.TerminalNode {
	return s.GetToken(ACIParserDELETE_PRIVILEGE, 0)
}

func (s *DeletePrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeletePrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeletePrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterDeletePrivilege(s)
	}
}

func (s *DeletePrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitDeletePrivilege(s)
	}
}

func (p *ACIParser) DeletePrivilege() (localctx IDeletePrivilegeContext) {
	localctx = NewDeletePrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ACIParserRULE_deletePrivilege)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(334)
		p.Match(ACIParserDELETE_PRIVILEGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelfWritePrivilegeContext is an interface to support dynamic dispatch.
type ISelfWritePrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELFWRITE_PRIVILEGE() antlr.TerminalNode

	// IsSelfWritePrivilegeContext differentiates from other interfaces.
	IsSelfWritePrivilegeContext()
}

type SelfWritePrivilegeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelfWritePrivilegeContext() *SelfWritePrivilegeContext {
	var p = new(SelfWritePrivilegeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_selfWritePrivilege
	return p
}

func InitEmptySelfWritePrivilegeContext(p *SelfWritePrivilegeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_selfWritePrivilege
}

func (*SelfWritePrivilegeContext) IsSelfWritePrivilegeContext() {}

func NewSelfWritePrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelfWritePrivilegeContext {
	var p = new(SelfWritePrivilegeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_selfWritePrivilege

	return p
}

func (s *SelfWritePrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *SelfWritePrivilegeContext) SELFWRITE_PRIVILEGE() antlr.TerminalNode {
	return s.GetToken(ACIParserSELFWRITE_PRIVILEGE, 0)
}

func (s *SelfWritePrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelfWritePrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelfWritePrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSelfWritePrivilege(s)
	}
}

func (s *SelfWritePrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSelfWritePrivilege(s)
	}
}

func (p *ACIParser) SelfWritePrivilege() (localctx ISelfWritePrivilegeContext) {
	localctx = NewSelfWritePrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ACIParserRULE_selfWritePrivilege)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(336)
		p.Match(ACIParserSELFWRITE_PRIVILEGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProxyPrivilegeContext is an interface to support dynamic dispatch.
type IProxyPrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROXY_PRIVILEGE() antlr.TerminalNode

	// IsProxyPrivilegeContext differentiates from other interfaces.
	IsProxyPrivilegeContext()
}

type ProxyPrivilegeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProxyPrivilegeContext() *ProxyPrivilegeContext {
	var p = new(ProxyPrivilegeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_proxyPrivilege
	return p
}

func InitEmptyProxyPrivilegeContext(p *ProxyPrivilegeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_proxyPrivilege
}

func (*ProxyPrivilegeContext) IsProxyPrivilegeContext() {}

func NewProxyPrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProxyPrivilegeContext {
	var p = new(ProxyPrivilegeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_proxyPrivilege

	return p
}

func (s *ProxyPrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *ProxyPrivilegeContext) PROXY_PRIVILEGE() antlr.TerminalNode {
	return s.GetToken(ACIParserPROXY_PRIVILEGE, 0)
}

func (s *ProxyPrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProxyPrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProxyPrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterProxyPrivilege(s)
	}
}

func (s *ProxyPrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitProxyPrivilege(s)
	}
}

func (p *ACIParser) ProxyPrivilege() (localctx IProxyPrivilegeContext) {
	localctx = NewProxyPrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ACIParserRULE_proxyPrivilege)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(338)
		p.Match(ACIParserPROXY_PRIVILEGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExportPrivilegeContext is an interface to support dynamic dispatch.
type IExportPrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXPORT_PRIVILEGE() antlr.TerminalNode

	// IsExportPrivilegeContext differentiates from other interfaces.
	IsExportPrivilegeContext()
}

type ExportPrivilegeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportPrivilegeContext() *ExportPrivilegeContext {
	var p = new(ExportPrivilegeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_exportPrivilege
	return p
}

func InitEmptyExportPrivilegeContext(p *ExportPrivilegeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_exportPrivilege
}

func (*ExportPrivilegeContext) IsExportPrivilegeContext() {}

func NewExportPrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportPrivilegeContext {
	var p = new(ExportPrivilegeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_exportPrivilege

	return p
}

func (s *ExportPrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportPrivilegeContext) EXPORT_PRIVILEGE() antlr.TerminalNode {
	return s.GetToken(ACIParserEXPORT_PRIVILEGE, 0)
}

func (s *ExportPrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportPrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportPrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterExportPrivilege(s)
	}
}

func (s *ExportPrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitExportPrivilege(s)
	}
}

func (p *ACIParser) ExportPrivilege() (localctx IExportPrivilegeContext) {
	localctx = NewExportPrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ACIParserRULE_exportPrivilege)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(340)
		p.Match(ACIParserEXPORT_PRIVILEGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportPrivilegeContext is an interface to support dynamic dispatch.
type IImportPrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPORT_PRIVILEGE() antlr.TerminalNode

	// IsImportPrivilegeContext differentiates from other interfaces.
	IsImportPrivilegeContext()
}

type ImportPrivilegeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportPrivilegeContext() *ImportPrivilegeContext {
	var p = new(ImportPrivilegeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_importPrivilege
	return p
}

func InitEmptyImportPrivilegeContext(p *ImportPrivilegeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_importPrivilege
}

func (*ImportPrivilegeContext) IsImportPrivilegeContext() {}

func NewImportPrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportPrivilegeContext {
	var p = new(ImportPrivilegeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_importPrivilege

	return p
}

func (s *ImportPrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportPrivilegeContext) IMPORT_PRIVILEGE() antlr.TerminalNode {
	return s.GetToken(ACIParserIMPORT_PRIVILEGE, 0)
}

func (s *ImportPrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportPrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportPrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterImportPrivilege(s)
	}
}

func (s *ImportPrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitImportPrivilege(s)
	}
}

func (p *ACIParser) ImportPrivilege() (localctx IImportPrivilegeContext) {
	localctx = NewImportPrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ACIParserRULE_importPrivilege)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(342)
		p.Match(ACIParserIMPORT_PRIVILEGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INoPrivilegesContext is an interface to support dynamic dispatch.
type INoPrivilegesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ANONYMOUS() antlr.TerminalNode

	// IsNoPrivilegesContext differentiates from other interfaces.
	IsNoPrivilegesContext()
}

type NoPrivilegesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNoPrivilegesContext() *NoPrivilegesContext {
	var p = new(NoPrivilegesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_noPrivileges
	return p
}

func InitEmptyNoPrivilegesContext(p *NoPrivilegesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_noPrivileges
}

func (*NoPrivilegesContext) IsNoPrivilegesContext() {}

func NewNoPrivilegesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NoPrivilegesContext {
	var p = new(NoPrivilegesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_noPrivileges

	return p
}

func (s *NoPrivilegesContext) GetParser() antlr.Parser { return s.parser }

func (s *NoPrivilegesContext) ANONYMOUS() antlr.TerminalNode {
	return s.GetToken(ACIParserANONYMOUS, 0)
}

func (s *NoPrivilegesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NoPrivilegesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NoPrivilegesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterNoPrivileges(s)
	}
}

func (s *NoPrivilegesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitNoPrivileges(s)
	}
}

func (p *ACIParser) NoPrivileges() (localctx INoPrivilegesContext) {
	localctx = NewNoPrivilegesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ACIParserRULE_noPrivileges)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(344)
		p.Match(ACIParserANONYMOUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAllPrivilegesContext is an interface to support dynamic dispatch.
type IAllPrivilegesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL_USERS() antlr.TerminalNode

	// IsAllPrivilegesContext differentiates from other interfaces.
	IsAllPrivilegesContext()
}

type AllPrivilegesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAllPrivilegesContext() *AllPrivilegesContext {
	var p = new(AllPrivilegesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_allPrivileges
	return p
}

func InitEmptyAllPrivilegesContext(p *AllPrivilegesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_allPrivileges
}

func (*AllPrivilegesContext) IsAllPrivilegesContext() {}

func NewAllPrivilegesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AllPrivilegesContext {
	var p = new(AllPrivilegesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_allPrivileges

	return p
}

func (s *AllPrivilegesContext) GetParser() antlr.Parser { return s.parser }

func (s *AllPrivilegesContext) ALL_USERS() antlr.TerminalNode {
	return s.GetToken(ACIParserALL_USERS, 0)
}

func (s *AllPrivilegesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AllPrivilegesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AllPrivilegesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAllPrivileges(s)
	}
}

func (s *AllPrivilegesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAllPrivileges(s)
	}
}

func (p *ACIParser) AllPrivileges() (localctx IAllPrivilegesContext) {
	localctx = NewAllPrivilegesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ACIParserRULE_allPrivileges)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(346)
		p.Match(ACIParserALL_USERS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetRulesContext is an interface to support dynamic dispatch.
type ITargetRulesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTargetRulesContext differentiates from other interfaces.
	IsTargetRulesContext()
}

type TargetRulesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetRulesContext() *TargetRulesContext {
	var p = new(TargetRulesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetRules
	return p
}

func InitEmptyTargetRulesContext(p *TargetRulesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetRules
}

func (*TargetRulesContext) IsTargetRulesContext() {}

func NewTargetRulesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetRulesContext {
	var p = new(TargetRulesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_targetRules

	return p
}

func (s *TargetRulesContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetRulesContext) CopyAll(ctx *TargetRulesContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TargetRulesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetRulesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Target_rulesContext struct {
	TargetRulesContext
}

func NewTarget_rulesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Target_rulesContext {
	var p = new(Target_rulesContext)

	InitEmptyTargetRulesContext(&p.TargetRulesContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetRulesContext))

	return p
}

func (s *Target_rulesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Target_rulesContext) AllTargetRule() []ITargetRuleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITargetRuleContext); ok {
			len++
		}
	}

	tst := make([]ITargetRuleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITargetRuleContext); ok {
			tst[i] = t.(ITargetRuleContext)
			i++
		}
	}

	return tst
}

func (s *Target_rulesContext) TargetRule(i int) ITargetRuleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetRuleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetRuleContext)
}

func (s *Target_rulesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterTarget_rules(s)
	}
}

func (s *Target_rulesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitTarget_rules(s)
	}
}

func (p *ACIParser) TargetRules() (localctx ITargetRulesContext) {
	localctx = NewTargetRulesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ACIParserRULE_targetRules)
	var _alt int

	localctx = NewTarget_rulesContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(351)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(348)
				p.TargetRule()
			}

		}
		p.SetState(353)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetRuleContext is an interface to support dynamic dispatch.
type ITargetRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTargetRuleContext differentiates from other interfaces.
	IsTargetRuleContext()
}

type TargetRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetRuleContext() *TargetRuleContext {
	var p = new(TargetRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetRule
	return p
}

func InitEmptyTargetRuleContext(p *TargetRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetRule
}

func (*TargetRuleContext) IsTargetRuleContext() {}

func NewTargetRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetRuleContext {
	var p = new(TargetRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_targetRule

	return p
}

func (s *TargetRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetRuleContext) CopyAll(ctx *TargetRuleContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TargetRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Rule_is_targetscopeContext struct {
	TargetRuleContext
}

func NewRule_is_targetscopeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Rule_is_targetscopeContext {
	var p = new(Rule_is_targetscopeContext)

	InitEmptyTargetRuleContext(&p.TargetRuleContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetRuleContext))

	return p
}

func (s *Rule_is_targetscopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rule_is_targetscopeContext) TargetScope() ITargetScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetScopeContext)
}

func (s *Rule_is_targetscopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterRule_is_targetscope(s)
	}
}

func (s *Rule_is_targetscopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitRule_is_targetscope(s)
	}
}

type Rule_is_targattrfiltersContext struct {
	TargetRuleContext
}

func NewRule_is_targattrfiltersContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Rule_is_targattrfiltersContext {
	var p = new(Rule_is_targattrfiltersContext)

	InitEmptyTargetRuleContext(&p.TargetRuleContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetRuleContext))

	return p
}

func (s *Rule_is_targattrfiltersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rule_is_targattrfiltersContext) TargetAttrFilters() ITargetAttrFiltersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetAttrFiltersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetAttrFiltersContext)
}

func (s *Rule_is_targattrfiltersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterRule_is_targattrfilters(s)
	}
}

func (s *Rule_is_targattrfiltersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitRule_is_targattrfilters(s)
	}
}

type Rule_is_targetattrContext struct {
	TargetRuleContext
}

func NewRule_is_targetattrContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Rule_is_targetattrContext {
	var p = new(Rule_is_targetattrContext)

	InitEmptyTargetRuleContext(&p.TargetRuleContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetRuleContext))

	return p
}

func (s *Rule_is_targetattrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rule_is_targetattrContext) TargetAttributes() ITargetAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetAttributesContext)
}

func (s *Rule_is_targetattrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterRule_is_targetattr(s)
	}
}

func (s *Rule_is_targetattrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitRule_is_targetattr(s)
	}
}

type Rule_is_targetContext struct {
	TargetRuleContext
}

func NewRule_is_targetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Rule_is_targetContext {
	var p = new(Rule_is_targetContext)

	InitEmptyTargetRuleContext(&p.TargetRuleContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetRuleContext))

	return p
}

func (s *Rule_is_targetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rule_is_targetContext) Target() ITargetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetContext)
}

func (s *Rule_is_targetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterRule_is_target(s)
	}
}

func (s *Rule_is_targetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitRule_is_target(s)
	}
}

type Rule_is_target_toContext struct {
	TargetRuleContext
}

func NewRule_is_target_toContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Rule_is_target_toContext {
	var p = new(Rule_is_target_toContext)

	InitEmptyTargetRuleContext(&p.TargetRuleContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetRuleContext))

	return p
}

func (s *Rule_is_target_toContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rule_is_target_toContext) TargetTo() ITargetToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetToContext)
}

func (s *Rule_is_target_toContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterRule_is_target_to(s)
	}
}

func (s *Rule_is_target_toContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitRule_is_target_to(s)
	}
}

type Rule_is_targetcontrolContext struct {
	TargetRuleContext
}

func NewRule_is_targetcontrolContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Rule_is_targetcontrolContext {
	var p = new(Rule_is_targetcontrolContext)

	InitEmptyTargetRuleContext(&p.TargetRuleContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetRuleContext))

	return p
}

func (s *Rule_is_targetcontrolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rule_is_targetcontrolContext) TargetControl() ITargetControlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetControlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetControlContext)
}

func (s *Rule_is_targetcontrolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterRule_is_targetcontrol(s)
	}
}

func (s *Rule_is_targetcontrolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitRule_is_targetcontrol(s)
	}
}

type Rule_is_targetfilterContext struct {
	TargetRuleContext
}

func NewRule_is_targetfilterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Rule_is_targetfilterContext {
	var p = new(Rule_is_targetfilterContext)

	InitEmptyTargetRuleContext(&p.TargetRuleContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetRuleContext))

	return p
}

func (s *Rule_is_targetfilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rule_is_targetfilterContext) TargetFilter() ITargetFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetFilterContext)
}

func (s *Rule_is_targetfilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterRule_is_targetfilter(s)
	}
}

func (s *Rule_is_targetfilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitRule_is_targetfilter(s)
	}
}

type Rule_is_target_fromContext struct {
	TargetRuleContext
}

func NewRule_is_target_fromContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Rule_is_target_fromContext {
	var p = new(Rule_is_target_fromContext)

	InitEmptyTargetRuleContext(&p.TargetRuleContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetRuleContext))

	return p
}

func (s *Rule_is_target_fromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rule_is_target_fromContext) TargetFrom() ITargetFromContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetFromContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetFromContext)
}

func (s *Rule_is_target_fromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterRule_is_target_from(s)
	}
}

func (s *Rule_is_target_fromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitRule_is_target_from(s)
	}
}

type Rule_is_extopContext struct {
	TargetRuleContext
}

func NewRule_is_extopContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Rule_is_extopContext {
	var p = new(Rule_is_extopContext)

	InitEmptyTargetRuleContext(&p.TargetRuleContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetRuleContext))

	return p
}

func (s *Rule_is_extopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rule_is_extopContext) TargetExtendedOperation() ITargetExtendedOperationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetExtendedOperationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetExtendedOperationContext)
}

func (s *Rule_is_extopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterRule_is_extop(s)
	}
}

func (s *Rule_is_extopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitRule_is_extop(s)
	}
}

func (p *ACIParser) TargetRule() (localctx ITargetRuleContext) {
	localctx = NewTargetRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ACIParserRULE_targetRule)
	p.SetState(363)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext()) {
	case 1:
		localctx = NewRule_is_targetcontrolContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(354)
			p.TargetControl()
		}

	case 2:
		localctx = NewRule_is_extopContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(355)
			p.TargetExtendedOperation()
		}

	case 3:
		localctx = NewRule_is_targetfilterContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(356)
			p.TargetFilter()
		}

	case 4:
		localctx = NewRule_is_targattrfiltersContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(357)
			p.TargetAttrFilters()
		}

	case 5:
		localctx = NewRule_is_targetscopeContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(358)
			p.TargetScope()
		}

	case 6:
		localctx = NewRule_is_targetattrContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(359)
			p.TargetAttributes()
		}

	case 7:
		localctx = NewRule_is_targetContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(360)
			p.Target()
		}

	case 8:
		localctx = NewRule_is_target_toContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(361)
			p.TargetTo()
		}

	case 9:
		localctx = NewRule_is_target_fromContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(362)
			p.TargetFrom()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetContext is an interface to support dynamic dispatch.
type ITargetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTargetContext differentiates from other interfaces.
	IsTargetContext()
}

type TargetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetContext() *TargetContext {
	var p = new(TargetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_target
	return p
}

func InitEmptyTargetContext(p *TargetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_target
}

func (*TargetContext) IsTargetContext() {}

func NewTargetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetContext {
	var p = new(TargetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_target

	return p
}

func (s *TargetContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetContext) CopyAll(ctx *TargetContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TargetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Target_dn_ruleContext struct {
	TargetContext
}

func NewTarget_dn_ruleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Target_dn_ruleContext {
	var p = new(Target_dn_ruleContext)

	InitEmptyTargetContext(&p.TargetContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetContext))

	return p
}

func (s *Target_dn_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Target_dn_ruleContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Target_dn_ruleContext) TARGET() antlr.TerminalNode {
	return s.GetToken(ACIParserTARGET, 0)
}

func (s *Target_dn_ruleContext) DistinguishedNames() IDistinguishedNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistinguishedNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistinguishedNamesContext)
}

func (s *Target_dn_ruleContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Target_dn_ruleContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Target_dn_ruleContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Target_dn_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterTarget_dn_rule(s)
	}
}

func (s *Target_dn_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitTarget_dn_rule(s)
	}
}

func (p *ACIParser) Target() (localctx ITargetContext) {
	localctx = NewTargetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ACIParserRULE_target)
	localctx = NewTarget_dn_ruleContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(365)
		p.Match(ACIParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(366)
		p.Match(ACIParserTARGET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(369)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserEQ:
		{
			p.SetState(367)
			p.EqualTo()
		}

	case ACIParserNE:
		{
			p.SetState(368)
			p.NotEqualTo()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(371)
		p.DistinguishedNames()
	}
	{
		p.SetState(372)
		p.Match(ACIParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetToContext is an interface to support dynamic dispatch.
type ITargetToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTargetToContext differentiates from other interfaces.
	IsTargetToContext()
}

type TargetToContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetToContext() *TargetToContext {
	var p = new(TargetToContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetTo
	return p
}

func InitEmptyTargetToContext(p *TargetToContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetTo
}

func (*TargetToContext) IsTargetToContext() {}

func NewTargetToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetToContext {
	var p = new(TargetToContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_targetTo

	return p
}

func (s *TargetToContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetToContext) CopyAll(ctx *TargetToContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TargetToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Target_to_ruleContext struct {
	TargetToContext
}

func NewTarget_to_ruleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Target_to_ruleContext {
	var p = new(Target_to_ruleContext)

	InitEmptyTargetToContext(&p.TargetToContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetToContext))

	return p
}

func (s *Target_to_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Target_to_ruleContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Target_to_ruleContext) TARGET_TO() antlr.TerminalNode {
	return s.GetToken(ACIParserTARGET_TO, 0)
}

func (s *Target_to_ruleContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Target_to_ruleContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Target_to_ruleContext) DistinguishedName() IDistinguishedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistinguishedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistinguishedNameContext)
}

func (s *Target_to_ruleContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Target_to_ruleContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Target_to_ruleContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Target_to_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterTarget_to_rule(s)
	}
}

func (s *Target_to_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitTarget_to_rule(s)
	}
}

func (p *ACIParser) TargetTo() (localctx ITargetToContext) {
	localctx = NewTargetToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ACIParserRULE_targetTo)
	localctx = NewTarget_to_ruleContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(374)
		p.Match(ACIParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(375)
		p.Match(ACIParserTARGET_TO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(378)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserEQ:
		{
			p.SetState(376)
			p.EqualTo()
		}

	case ACIParserNE:
		{
			p.SetState(377)
			p.NotEqualTo()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(380)
		p.Match(ACIParserDQUOTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(381)
		p.DistinguishedName()
	}
	{
		p.SetState(382)
		p.Match(ACIParserDQUOTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(383)
		p.Match(ACIParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetFromContext is an interface to support dynamic dispatch.
type ITargetFromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTargetFromContext differentiates from other interfaces.
	IsTargetFromContext()
}

type TargetFromContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetFromContext() *TargetFromContext {
	var p = new(TargetFromContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetFrom
	return p
}

func InitEmptyTargetFromContext(p *TargetFromContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetFrom
}

func (*TargetFromContext) IsTargetFromContext() {}

func NewTargetFromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetFromContext {
	var p = new(TargetFromContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_targetFrom

	return p
}

func (s *TargetFromContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetFromContext) CopyAll(ctx *TargetFromContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TargetFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetFromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Target_from_ruleContext struct {
	TargetFromContext
}

func NewTarget_from_ruleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Target_from_ruleContext {
	var p = new(Target_from_ruleContext)

	InitEmptyTargetFromContext(&p.TargetFromContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetFromContext))

	return p
}

func (s *Target_from_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Target_from_ruleContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Target_from_ruleContext) TARGET_FROM() antlr.TerminalNode {
	return s.GetToken(ACIParserTARGET_FROM, 0)
}

func (s *Target_from_ruleContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Target_from_ruleContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Target_from_ruleContext) DistinguishedName() IDistinguishedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistinguishedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistinguishedNameContext)
}

func (s *Target_from_ruleContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Target_from_ruleContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Target_from_ruleContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Target_from_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterTarget_from_rule(s)
	}
}

func (s *Target_from_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitTarget_from_rule(s)
	}
}

func (p *ACIParser) TargetFrom() (localctx ITargetFromContext) {
	localctx = NewTargetFromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ACIParserRULE_targetFrom)
	localctx = NewTarget_from_ruleContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(385)
		p.Match(ACIParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(386)
		p.Match(ACIParserTARGET_FROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(389)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserEQ:
		{
			p.SetState(387)
			p.EqualTo()
		}

	case ACIParserNE:
		{
			p.SetState(388)
			p.NotEqualTo()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(391)
		p.Match(ACIParserDQUOTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(392)
		p.DistinguishedName()
	}
	{
		p.SetState(393)
		p.Match(ACIParserDQUOTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(394)
		p.Match(ACIParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetFilterContext is an interface to support dynamic dispatch.
type ITargetFilterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTargetFilterContext differentiates from other interfaces.
	IsTargetFilterContext()
}

type TargetFilterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetFilterContext() *TargetFilterContext {
	var p = new(TargetFilterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetFilter
	return p
}

func InitEmptyTargetFilterContext(p *TargetFilterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetFilter
}

func (*TargetFilterContext) IsTargetFilterContext() {}

func NewTargetFilterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetFilterContext {
	var p = new(TargetFilterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_targetFilter

	return p
}

func (s *TargetFilterContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetFilterContext) CopyAll(ctx *TargetFilterContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TargetFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetFilterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Targetfilter_ruleContext struct {
	TargetFilterContext
}

func NewTargetfilter_ruleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Targetfilter_ruleContext {
	var p = new(Targetfilter_ruleContext)

	InitEmptyTargetFilterContext(&p.TargetFilterContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetFilterContext))

	return p
}

func (s *Targetfilter_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Targetfilter_ruleContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Targetfilter_ruleContext) TARGET_FILTER() antlr.TerminalNode {
	return s.GetToken(ACIParserTARGET_FILTER, 0)
}

func (s *Targetfilter_ruleContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Targetfilter_ruleContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Targetfilter_ruleContext) LDAPFilter() ILDAPFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILDAPFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILDAPFilterContext)
}

func (s *Targetfilter_ruleContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Targetfilter_ruleContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Targetfilter_ruleContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Targetfilter_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterTargetfilter_rule(s)
	}
}

func (s *Targetfilter_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitTargetfilter_rule(s)
	}
}

func (p *ACIParser) TargetFilter() (localctx ITargetFilterContext) {
	localctx = NewTargetFilterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ACIParserRULE_targetFilter)
	localctx = NewTargetfilter_ruleContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(396)
		p.Match(ACIParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(397)
		p.Match(ACIParserTARGET_FILTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(400)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserEQ:
		{
			p.SetState(398)
			p.EqualTo()
		}

	case ACIParserNE:
		{
			p.SetState(399)
			p.NotEqualTo()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(402)
		p.Match(ACIParserDQUOTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(403)
		p.LDAPFilter()
	}
	{
		p.SetState(404)
		p.Match(ACIParserDQUOTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(405)
		p.Match(ACIParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetAttrFiltersContext is an interface to support dynamic dispatch.
type ITargetAttrFiltersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTargetAttrFiltersContext differentiates from other interfaces.
	IsTargetAttrFiltersContext()
}

type TargetAttrFiltersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetAttrFiltersContext() *TargetAttrFiltersContext {
	var p = new(TargetAttrFiltersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetAttrFilters
	return p
}

func InitEmptyTargetAttrFiltersContext(p *TargetAttrFiltersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetAttrFilters
}

func (*TargetAttrFiltersContext) IsTargetAttrFiltersContext() {}

func NewTargetAttrFiltersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetAttrFiltersContext {
	var p = new(TargetAttrFiltersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_targetAttrFilters

	return p
}

func (s *TargetAttrFiltersContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetAttrFiltersContext) CopyAll(ctx *TargetAttrFiltersContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TargetAttrFiltersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetAttrFiltersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Targattrfilters_ruleContext struct {
	TargetAttrFiltersContext
}

func NewTargattrfilters_ruleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Targattrfilters_ruleContext {
	var p = new(Targattrfilters_ruleContext)

	InitEmptyTargetAttrFiltersContext(&p.TargetAttrFiltersContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetAttrFiltersContext))

	return p
}

func (s *Targattrfilters_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Targattrfilters_ruleContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Targattrfilters_ruleContext) TARGET_ATTR_FILTERS() antlr.TerminalNode {
	return s.GetToken(ACIParserTARGET_ATTR_FILTERS, 0)
}

func (s *Targattrfilters_ruleContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Targattrfilters_ruleContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Targattrfilters_ruleContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Targattrfilters_ruleContext) TargetAttrFiltersValue() ITargetAttrFiltersValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetAttrFiltersValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetAttrFiltersValueContext)
}

func (s *Targattrfilters_ruleContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Targattrfilters_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterTargattrfilters_rule(s)
	}
}

func (s *Targattrfilters_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitTargattrfilters_rule(s)
	}
}

func (p *ACIParser) TargetAttrFilters() (localctx ITargetAttrFiltersContext) {
	localctx = NewTargetAttrFiltersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ACIParserRULE_targetAttrFilters)
	localctx = NewTargattrfilters_ruleContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(407)
		p.Match(ACIParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(408)
		p.Match(ACIParserTARGET_ATTR_FILTERS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(409)
		p.EqualTo()
	}
	{
		p.SetState(410)
		p.Match(ACIParserDQUOTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(411)
		p.TargetAttrFiltersValue()
	}
	{
		p.SetState(412)
		p.Match(ACIParserDQUOTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(413)
		p.Match(ACIParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetScopeContext is an interface to support dynamic dispatch.
type ITargetScopeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTargetScopeContext differentiates from other interfaces.
	IsTargetScopeContext()
}

type TargetScopeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetScopeContext() *TargetScopeContext {
	var p = new(TargetScopeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetScope
	return p
}

func InitEmptyTargetScopeContext(p *TargetScopeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetScope
}

func (*TargetScopeContext) IsTargetScopeContext() {}

func NewTargetScopeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetScopeContext {
	var p = new(TargetScopeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_targetScope

	return p
}

func (s *TargetScopeContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetScopeContext) CopyAll(ctx *TargetScopeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TargetScopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetScopeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Targetscope_ruleContext struct {
	TargetScopeContext
}

func NewTargetscope_ruleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Targetscope_ruleContext {
	var p = new(Targetscope_ruleContext)

	InitEmptyTargetScopeContext(&p.TargetScopeContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetScopeContext))

	return p
}

func (s *Targetscope_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Targetscope_ruleContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Targetscope_ruleContext) TARGET_SCOPE() antlr.TerminalNode {
	return s.GetToken(ACIParserTARGET_SCOPE, 0)
}

func (s *Targetscope_ruleContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Targetscope_ruleContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Targetscope_ruleContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Targetscope_ruleContext) TargetSearchScopes() ITargetSearchScopesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetSearchScopesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetSearchScopesContext)
}

func (s *Targetscope_ruleContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Targetscope_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterTargetscope_rule(s)
	}
}

func (s *Targetscope_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitTargetscope_rule(s)
	}
}

func (p *ACIParser) TargetScope() (localctx ITargetScopeContext) {
	localctx = NewTargetScopeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, ACIParserRULE_targetScope)
	localctx = NewTargetscope_ruleContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(415)
		p.Match(ACIParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(416)
		p.Match(ACIParserTARGET_SCOPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(417)
		p.EqualTo()
	}
	{
		p.SetState(418)
		p.Match(ACIParserDQUOTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(419)
		p.TargetSearchScopes()
	}
	{
		p.SetState(420)
		p.Match(ACIParserDQUOTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(421)
		p.Match(ACIParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetAttributesContext is an interface to support dynamic dispatch.
type ITargetAttributesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTargetAttributesContext differentiates from other interfaces.
	IsTargetAttributesContext()
}

type TargetAttributesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetAttributesContext() *TargetAttributesContext {
	var p = new(TargetAttributesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetAttributes
	return p
}

func InitEmptyTargetAttributesContext(p *TargetAttributesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetAttributes
}

func (*TargetAttributesContext) IsTargetAttributesContext() {}

func NewTargetAttributesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetAttributesContext {
	var p = new(TargetAttributesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_targetAttributes

	return p
}

func (s *TargetAttributesContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetAttributesContext) CopyAll(ctx *TargetAttributesContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TargetAttributesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetAttributesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Targetattr_ruleContext struct {
	TargetAttributesContext
}

func NewTargetattr_ruleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Targetattr_ruleContext {
	var p = new(Targetattr_ruleContext)

	InitEmptyTargetAttributesContext(&p.TargetAttributesContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetAttributesContext))

	return p
}

func (s *Targetattr_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Targetattr_ruleContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Targetattr_ruleContext) TARGET_ATTR() antlr.TerminalNode {
	return s.GetToken(ACIParserTARGET_ATTR, 0)
}

func (s *Targetattr_ruleContext) TargetedAttributes() ITargetedAttributesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetedAttributesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetedAttributesContext)
}

func (s *Targetattr_ruleContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Targetattr_ruleContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Targetattr_ruleContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Targetattr_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterTargetattr_rule(s)
	}
}

func (s *Targetattr_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitTargetattr_rule(s)
	}
}

func (p *ACIParser) TargetAttributes() (localctx ITargetAttributesContext) {
	localctx = NewTargetAttributesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ACIParserRULE_targetAttributes)
	localctx = NewTargetattr_ruleContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(423)
		p.Match(ACIParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(424)
		p.Match(ACIParserTARGET_ATTR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(427)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserEQ:
		{
			p.SetState(425)
			p.EqualTo()
		}

	case ACIParserNE:
		{
			p.SetState(426)
			p.NotEqualTo()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(429)
		p.TargetedAttributes()
	}
	{
		p.SetState(430)
		p.Match(ACIParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetControlContext is an interface to support dynamic dispatch.
type ITargetControlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTargetControlContext differentiates from other interfaces.
	IsTargetControlContext()
}

type TargetControlContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetControlContext() *TargetControlContext {
	var p = new(TargetControlContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetControl
	return p
}

func InitEmptyTargetControlContext(p *TargetControlContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetControl
}

func (*TargetControlContext) IsTargetControlContext() {}

func NewTargetControlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetControlContext {
	var p = new(TargetControlContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_targetControl

	return p
}

func (s *TargetControlContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetControlContext) CopyAll(ctx *TargetControlContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TargetControlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetControlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Targetcontrol_ruleContext struct {
	TargetControlContext
}

func NewTargetcontrol_ruleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Targetcontrol_ruleContext {
	var p = new(Targetcontrol_ruleContext)

	InitEmptyTargetControlContext(&p.TargetControlContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetControlContext))

	return p
}

func (s *Targetcontrol_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Targetcontrol_ruleContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Targetcontrol_ruleContext) TARGET_CONTROL() antlr.TerminalNode {
	return s.GetToken(ACIParserTARGET_CONTROL, 0)
}

func (s *Targetcontrol_ruleContext) ObjectIdentifiers() IObjectIdentifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectIdentifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectIdentifiersContext)
}

func (s *Targetcontrol_ruleContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Targetcontrol_ruleContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Targetcontrol_ruleContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Targetcontrol_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterTargetcontrol_rule(s)
	}
}

func (s *Targetcontrol_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitTargetcontrol_rule(s)
	}
}

func (p *ACIParser) TargetControl() (localctx ITargetControlContext) {
	localctx = NewTargetControlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ACIParserRULE_targetControl)
	localctx = NewTargetcontrol_ruleContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(432)
		p.Match(ACIParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(433)
		p.Match(ACIParserTARGET_CONTROL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(436)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserEQ:
		{
			p.SetState(434)
			p.EqualTo()
		}

	case ACIParserNE:
		{
			p.SetState(435)
			p.NotEqualTo()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(438)
		p.ObjectIdentifiers()
	}
	{
		p.SetState(439)
		p.Match(ACIParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetExtendedOperationContext is an interface to support dynamic dispatch.
type ITargetExtendedOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTargetExtendedOperationContext differentiates from other interfaces.
	IsTargetExtendedOperationContext()
}

type TargetExtendedOperationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetExtendedOperationContext() *TargetExtendedOperationContext {
	var p = new(TargetExtendedOperationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetExtendedOperation
	return p
}

func InitEmptyTargetExtendedOperationContext(p *TargetExtendedOperationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetExtendedOperation
}

func (*TargetExtendedOperationContext) IsTargetExtendedOperationContext() {}

func NewTargetExtendedOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetExtendedOperationContext {
	var p = new(TargetExtendedOperationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_targetExtendedOperation

	return p
}

func (s *TargetExtendedOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetExtendedOperationContext) CopyAll(ctx *TargetExtendedOperationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TargetExtendedOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetExtendedOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Targetextop_ruleContext struct {
	TargetExtendedOperationContext
}

func NewTargetextop_ruleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Targetextop_ruleContext {
	var p = new(Targetextop_ruleContext)

	InitEmptyTargetExtendedOperationContext(&p.TargetExtendedOperationContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetExtendedOperationContext))

	return p
}

func (s *Targetextop_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Targetextop_ruleContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Targetextop_ruleContext) TARGET_EXTENDED_OPERATION() antlr.TerminalNode {
	return s.GetToken(ACIParserTARGET_EXTENDED_OPERATION, 0)
}

func (s *Targetextop_ruleContext) ObjectIdentifiers() IObjectIdentifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectIdentifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectIdentifiersContext)
}

func (s *Targetextop_ruleContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Targetextop_ruleContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Targetextop_ruleContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Targetextop_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterTargetextop_rule(s)
	}
}

func (s *Targetextop_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitTargetextop_rule(s)
	}
}

func (p *ACIParser) TargetExtendedOperation() (localctx ITargetExtendedOperationContext) {
	localctx = NewTargetExtendedOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ACIParserRULE_targetExtendedOperation)
	localctx = NewTargetextop_ruleContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(441)
		p.Match(ACIParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(442)
		p.Match(ACIParserTARGET_EXTENDED_OPERATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(445)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserEQ:
		{
			p.SetState(443)
			p.EqualTo()
		}

	case ACIParserNE:
		{
			p.SetState(444)
			p.NotEqualTo()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(447)
		p.ObjectIdentifiers()
	}
	{
		p.SetState(448)
		p.Match(ACIParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetSearchScopesContext is an interface to support dynamic dispatch.
type ITargetSearchScopesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTargetSearchScopesContext differentiates from other interfaces.
	IsTargetSearchScopesContext()
}

type TargetSearchScopesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetSearchScopesContext() *TargetSearchScopesContext {
	var p = new(TargetSearchScopesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetSearchScopes
	return p
}

func InitEmptyTargetSearchScopesContext(p *TargetSearchScopesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetSearchScopes
}

func (*TargetSearchScopesContext) IsTargetSearchScopesContext() {}

func NewTargetSearchScopesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetSearchScopesContext {
	var p = new(TargetSearchScopesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_targetSearchScopes

	return p
}

func (s *TargetSearchScopesContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetSearchScopesContext) CopyAll(ctx *TargetSearchScopesContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TargetSearchScopesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetSearchScopesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Base_object_targetscopeContext struct {
	TargetSearchScopesContext
}

func NewBase_object_targetscopeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Base_object_targetscopeContext {
	var p = new(Base_object_targetscopeContext)

	InitEmptyTargetSearchScopesContext(&p.TargetSearchScopesContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetSearchScopesContext))

	return p
}

func (s *Base_object_targetscopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Base_object_targetscopeContext) BaseTargetScope() IBaseTargetScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTargetScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTargetScopeContext)
}

func (s *Base_object_targetscopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterBase_object_targetscope(s)
	}
}

func (s *Base_object_targetscopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitBase_object_targetscope(s)
	}
}

type Sub_tree_targetscopeContext struct {
	TargetSearchScopesContext
}

func NewSub_tree_targetscopeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Sub_tree_targetscopeContext {
	var p = new(Sub_tree_targetscopeContext)

	InitEmptyTargetSearchScopesContext(&p.TargetSearchScopesContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetSearchScopesContext))

	return p
}

func (s *Sub_tree_targetscopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sub_tree_targetscopeContext) SubTreeTargetScope() ISubTreeTargetScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubTreeTargetScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubTreeTargetScopeContext)
}

func (s *Sub_tree_targetscopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSub_tree_targetscope(s)
	}
}

func (s *Sub_tree_targetscopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSub_tree_targetscope(s)
	}
}

type Subordinate_targetscopeContext struct {
	TargetSearchScopesContext
}

func NewSubordinate_targetscopeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Subordinate_targetscopeContext {
	var p = new(Subordinate_targetscopeContext)

	InitEmptyTargetSearchScopesContext(&p.TargetSearchScopesContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetSearchScopesContext))

	return p
}

func (s *Subordinate_targetscopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subordinate_targetscopeContext) SubordinateTargetScope() ISubordinateTargetScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubordinateTargetScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubordinateTargetScopeContext)
}

func (s *Subordinate_targetscopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSubordinate_targetscope(s)
	}
}

func (s *Subordinate_targetscopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSubordinate_targetscope(s)
	}
}

type One_level_targetscopeContext struct {
	TargetSearchScopesContext
}

func NewOne_level_targetscopeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *One_level_targetscopeContext {
	var p = new(One_level_targetscopeContext)

	InitEmptyTargetSearchScopesContext(&p.TargetSearchScopesContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetSearchScopesContext))

	return p
}

func (s *One_level_targetscopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *One_level_targetscopeContext) OneLevelTargetScope() IOneLevelTargetScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOneLevelTargetScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOneLevelTargetScopeContext)
}

func (s *One_level_targetscopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterOne_level_targetscope(s)
	}
}

func (s *One_level_targetscopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitOne_level_targetscope(s)
	}
}

func (p *ACIParser) TargetSearchScopes() (localctx ITargetSearchScopesContext) {
	localctx = NewTargetSearchScopesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ACIParserRULE_targetSearchScopes)
	p.SetState(454)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserBASE_OBJECT_SCOPE:
		localctx = NewBase_object_targetscopeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(450)
			p.BaseTargetScope()
		}

	case ACIParserONE_LEVEL_TARGET_SCOPE:
		localctx = NewOne_level_targetscopeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(451)
			p.OneLevelTargetScope()
		}

	case ACIParserSUB_TREE_TARGET_SCOPE:
		localctx = NewSub_tree_targetscopeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(452)
			p.SubTreeTargetScope()
		}

	case ACIParserSUBORDINATE_TARGET_SCOPE:
		localctx = NewSubordinate_targetscopeContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(453)
			p.SubordinateTargetScope()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBaseTargetScopeContext is an interface to support dynamic dispatch.
type IBaseTargetScopeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BASE_OBJECT_SCOPE() antlr.TerminalNode

	// IsBaseTargetScopeContext differentiates from other interfaces.
	IsBaseTargetScopeContext()
}

type BaseTargetScopeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBaseTargetScopeContext() *BaseTargetScopeContext {
	var p = new(BaseTargetScopeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_baseTargetScope
	return p
}

func InitEmptyBaseTargetScopeContext(p *BaseTargetScopeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_baseTargetScope
}

func (*BaseTargetScopeContext) IsBaseTargetScopeContext() {}

func NewBaseTargetScopeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BaseTargetScopeContext {
	var p = new(BaseTargetScopeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_baseTargetScope

	return p
}

func (s *BaseTargetScopeContext) GetParser() antlr.Parser { return s.parser }

func (s *BaseTargetScopeContext) BASE_OBJECT_SCOPE() antlr.TerminalNode {
	return s.GetToken(ACIParserBASE_OBJECT_SCOPE, 0)
}

func (s *BaseTargetScopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BaseTargetScopeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BaseTargetScopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterBaseTargetScope(s)
	}
}

func (s *BaseTargetScopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitBaseTargetScope(s)
	}
}

func (p *ACIParser) BaseTargetScope() (localctx IBaseTargetScopeContext) {
	localctx = NewBaseTargetScopeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ACIParserRULE_baseTargetScope)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(456)
		p.Match(ACIParserBASE_OBJECT_SCOPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOneLevelTargetScopeContext is an interface to support dynamic dispatch.
type IOneLevelTargetScopeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ONE_LEVEL_TARGET_SCOPE() antlr.TerminalNode

	// IsOneLevelTargetScopeContext differentiates from other interfaces.
	IsOneLevelTargetScopeContext()
}

type OneLevelTargetScopeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOneLevelTargetScopeContext() *OneLevelTargetScopeContext {
	var p = new(OneLevelTargetScopeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_oneLevelTargetScope
	return p
}

func InitEmptyOneLevelTargetScopeContext(p *OneLevelTargetScopeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_oneLevelTargetScope
}

func (*OneLevelTargetScopeContext) IsOneLevelTargetScopeContext() {}

func NewOneLevelTargetScopeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OneLevelTargetScopeContext {
	var p = new(OneLevelTargetScopeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_oneLevelTargetScope

	return p
}

func (s *OneLevelTargetScopeContext) GetParser() antlr.Parser { return s.parser }

func (s *OneLevelTargetScopeContext) ONE_LEVEL_TARGET_SCOPE() antlr.TerminalNode {
	return s.GetToken(ACIParserONE_LEVEL_TARGET_SCOPE, 0)
}

func (s *OneLevelTargetScopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OneLevelTargetScopeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OneLevelTargetScopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterOneLevelTargetScope(s)
	}
}

func (s *OneLevelTargetScopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitOneLevelTargetScope(s)
	}
}

func (p *ACIParser) OneLevelTargetScope() (localctx IOneLevelTargetScopeContext) {
	localctx = NewOneLevelTargetScopeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ACIParserRULE_oneLevelTargetScope)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(458)
		p.Match(ACIParserONE_LEVEL_TARGET_SCOPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubTreeTargetScopeContext is an interface to support dynamic dispatch.
type ISubTreeTargetScopeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUB_TREE_TARGET_SCOPE() antlr.TerminalNode

	// IsSubTreeTargetScopeContext differentiates from other interfaces.
	IsSubTreeTargetScopeContext()
}

type SubTreeTargetScopeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubTreeTargetScopeContext() *SubTreeTargetScopeContext {
	var p = new(SubTreeTargetScopeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_subTreeTargetScope
	return p
}

func InitEmptySubTreeTargetScopeContext(p *SubTreeTargetScopeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_subTreeTargetScope
}

func (*SubTreeTargetScopeContext) IsSubTreeTargetScopeContext() {}

func NewSubTreeTargetScopeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubTreeTargetScopeContext {
	var p = new(SubTreeTargetScopeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_subTreeTargetScope

	return p
}

func (s *SubTreeTargetScopeContext) GetParser() antlr.Parser { return s.parser }

func (s *SubTreeTargetScopeContext) SUB_TREE_TARGET_SCOPE() antlr.TerminalNode {
	return s.GetToken(ACIParserSUB_TREE_TARGET_SCOPE, 0)
}

func (s *SubTreeTargetScopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubTreeTargetScopeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubTreeTargetScopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSubTreeTargetScope(s)
	}
}

func (s *SubTreeTargetScopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSubTreeTargetScope(s)
	}
}

func (p *ACIParser) SubTreeTargetScope() (localctx ISubTreeTargetScopeContext) {
	localctx = NewSubTreeTargetScopeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ACIParserRULE_subTreeTargetScope)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(460)
		p.Match(ACIParserSUB_TREE_TARGET_SCOPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubordinateTargetScopeContext is an interface to support dynamic dispatch.
type ISubordinateTargetScopeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUBORDINATE_TARGET_SCOPE() antlr.TerminalNode

	// IsSubordinateTargetScopeContext differentiates from other interfaces.
	IsSubordinateTargetScopeContext()
}

type SubordinateTargetScopeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubordinateTargetScopeContext() *SubordinateTargetScopeContext {
	var p = new(SubordinateTargetScopeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_subordinateTargetScope
	return p
}

func InitEmptySubordinateTargetScopeContext(p *SubordinateTargetScopeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_subordinateTargetScope
}

func (*SubordinateTargetScopeContext) IsSubordinateTargetScopeContext() {}

func NewSubordinateTargetScopeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubordinateTargetScopeContext {
	var p = new(SubordinateTargetScopeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_subordinateTargetScope

	return p
}

func (s *SubordinateTargetScopeContext) GetParser() antlr.Parser { return s.parser }

func (s *SubordinateTargetScopeContext) SUBORDINATE_TARGET_SCOPE() antlr.TerminalNode {
	return s.GetToken(ACIParserSUBORDINATE_TARGET_SCOPE, 0)
}

func (s *SubordinateTargetScopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubordinateTargetScopeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubordinateTargetScopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSubordinateTargetScope(s)
	}
}

func (s *SubordinateTargetScopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSubordinateTargetScope(s)
	}
}

func (p *ACIParser) SubordinateTargetScope() (localctx ISubordinateTargetScopeContext) {
	localctx = NewSubordinateTargetScopeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ACIParserRULE_subordinateTargetScope)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(462)
		p.Match(ACIParserSUBORDINATE_TARGET_SCOPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectIdentifiersContext is an interface to support dynamic dispatch.
type IObjectIdentifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsObjectIdentifiersContext differentiates from other interfaces.
	IsObjectIdentifiersContext()
}

type ObjectIdentifiersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectIdentifiersContext() *ObjectIdentifiersContext {
	var p = new(ObjectIdentifiersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_objectIdentifiers
	return p
}

func InitEmptyObjectIdentifiersContext(p *ObjectIdentifiersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_objectIdentifiers
}

func (*ObjectIdentifiersContext) IsObjectIdentifiersContext() {}

func NewObjectIdentifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectIdentifiersContext {
	var p = new(ObjectIdentifiersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_objectIdentifiers

	return p
}

func (s *ObjectIdentifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectIdentifiersContext) CopyAll(ctx *ObjectIdentifiersContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ObjectIdentifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectIdentifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Quoted_object_identifier_listContext struct {
	ObjectIdentifiersContext
}

func NewQuoted_object_identifier_listContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Quoted_object_identifier_listContext {
	var p = new(Quoted_object_identifier_listContext)

	InitEmptyObjectIdentifiersContext(&p.ObjectIdentifiersContext)
	p.parser = parser
	p.CopyAll(ctx.(*ObjectIdentifiersContext))

	return p
}

func (s *Quoted_object_identifier_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Quoted_object_identifier_listContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Quoted_object_identifier_listContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Quoted_object_identifier_listContext) AllObjectIdentifier() []IObjectIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IObjectIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IObjectIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IObjectIdentifierContext); ok {
			tst[i] = t.(IObjectIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *Quoted_object_identifier_listContext) ObjectIdentifier(i int) IObjectIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectIdentifierContext)
}

func (s *Quoted_object_identifier_listContext) AllORDelimiter() []IORDelimiterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IORDelimiterContext); ok {
			len++
		}
	}

	tst := make([]IORDelimiterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IORDelimiterContext); ok {
			tst[i] = t.(IORDelimiterContext)
			i++
		}
	}

	return tst
}

func (s *Quoted_object_identifier_listContext) ORDelimiter(i int) IORDelimiterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IORDelimiterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IORDelimiterContext)
}

func (s *Quoted_object_identifier_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterQuoted_object_identifier_list(s)
	}
}

func (s *Quoted_object_identifier_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitQuoted_object_identifier_list(s)
	}
}

type List_of_quoted_object_identifiersContext struct {
	ObjectIdentifiersContext
}

func NewList_of_quoted_object_identifiersContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *List_of_quoted_object_identifiersContext {
	var p = new(List_of_quoted_object_identifiersContext)

	InitEmptyObjectIdentifiersContext(&p.ObjectIdentifiersContext)
	p.parser = parser
	p.CopyAll(ctx.(*ObjectIdentifiersContext))

	return p
}

func (s *List_of_quoted_object_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_quoted_object_identifiersContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *List_of_quoted_object_identifiersContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *List_of_quoted_object_identifiersContext) AllObjectIdentifier() []IObjectIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IObjectIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IObjectIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IObjectIdentifierContext); ok {
			tst[i] = t.(IObjectIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *List_of_quoted_object_identifiersContext) ObjectIdentifier(i int) IObjectIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectIdentifierContext)
}

func (s *List_of_quoted_object_identifiersContext) AllORDelimiter() []IORDelimiterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IORDelimiterContext); ok {
			len++
		}
	}

	tst := make([]IORDelimiterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IORDelimiterContext); ok {
			tst[i] = t.(IORDelimiterContext)
			i++
		}
	}

	return tst
}

func (s *List_of_quoted_object_identifiersContext) ORDelimiter(i int) IORDelimiterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IORDelimiterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IORDelimiterContext)
}

func (s *List_of_quoted_object_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterList_of_quoted_object_identifiers(s)
	}
}

func (s *List_of_quoted_object_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitList_of_quoted_object_identifiers(s)
	}
}

func (p *ACIParser) ObjectIdentifiers() (localctx IObjectIdentifiersContext) {
	localctx = NewObjectIdentifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ACIParserRULE_objectIdentifiers)
	var _la int

	p.SetState(489)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) {
	case 1:
		localctx = NewQuoted_object_identifier_listContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(464)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(465)
			p.ObjectIdentifier()
		}
		p.SetState(471)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ACIParserSYMBOLIC_OR {
			{
				p.SetState(466)
				p.ORDelimiter()
			}
			{
				p.SetState(467)
				p.ObjectIdentifier()
			}

			p.SetState(473)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

		{
			p.SetState(474)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewList_of_quoted_object_identifiersContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(476)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(477)
			p.ObjectIdentifier()
		}
		{
			p.SetState(478)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(486)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ACIParserSYMBOLIC_OR {
			{
				p.SetState(479)
				p.ORDelimiter()
			}

			{
				p.SetState(480)
				p.Match(ACIParserDQUOTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(481)
				p.ObjectIdentifier()
			}
			{
				p.SetState(482)
				p.Match(ACIParserDQUOTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(488)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetedAttributesContext is an interface to support dynamic dispatch.
type ITargetedAttributesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTargetedAttributesContext differentiates from other interfaces.
	IsTargetedAttributesContext()
}

type TargetedAttributesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetedAttributesContext() *TargetedAttributesContext {
	var p = new(TargetedAttributesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetedAttributes
	return p
}

func InitEmptyTargetedAttributesContext(p *TargetedAttributesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetedAttributes
}

func (*TargetedAttributesContext) IsTargetedAttributesContext() {}

func NewTargetedAttributesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetedAttributesContext {
	var p = new(TargetedAttributesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_targetedAttributes

	return p
}

func (s *TargetedAttributesContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetedAttributesContext) CopyAll(ctx *TargetedAttributesContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TargetedAttributesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetedAttributesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type List_of_quoted_attributesContext struct {
	TargetedAttributesContext
}

func NewList_of_quoted_attributesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *List_of_quoted_attributesContext {
	var p = new(List_of_quoted_attributesContext)

	InitEmptyTargetedAttributesContext(&p.TargetedAttributesContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetedAttributesContext))

	return p
}

func (s *List_of_quoted_attributesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_quoted_attributesContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *List_of_quoted_attributesContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *List_of_quoted_attributesContext) AllAttributeTypeOrValue() []IAttributeTypeOrValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			len++
		}
	}

	tst := make([]IAttributeTypeOrValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeTypeOrValueContext); ok {
			tst[i] = t.(IAttributeTypeOrValueContext)
			i++
		}
	}

	return tst
}

func (s *List_of_quoted_attributesContext) AttributeTypeOrValue(i int) IAttributeTypeOrValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeTypeOrValueContext)
}

func (s *List_of_quoted_attributesContext) AllORDelimiter() []IORDelimiterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IORDelimiterContext); ok {
			len++
		}
	}

	tst := make([]IORDelimiterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IORDelimiterContext); ok {
			tst[i] = t.(IORDelimiterContext)
			i++
		}
	}

	return tst
}

func (s *List_of_quoted_attributesContext) ORDelimiter(i int) IORDelimiterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IORDelimiterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IORDelimiterContext)
}

func (s *List_of_quoted_attributesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterList_of_quoted_attributes(s)
	}
}

func (s *List_of_quoted_attributesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitList_of_quoted_attributes(s)
	}
}

type Quoted_targeted_attributes_listContext struct {
	TargetedAttributesContext
}

func NewQuoted_targeted_attributes_listContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Quoted_targeted_attributes_listContext {
	var p = new(Quoted_targeted_attributes_listContext)

	InitEmptyTargetedAttributesContext(&p.TargetedAttributesContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetedAttributesContext))

	return p
}

func (s *Quoted_targeted_attributes_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Quoted_targeted_attributes_listContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Quoted_targeted_attributes_listContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Quoted_targeted_attributes_listContext) AllAttributeTypeOrValue() []IAttributeTypeOrValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			len++
		}
	}

	tst := make([]IAttributeTypeOrValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeTypeOrValueContext); ok {
			tst[i] = t.(IAttributeTypeOrValueContext)
			i++
		}
	}

	return tst
}

func (s *Quoted_targeted_attributes_listContext) AttributeTypeOrValue(i int) IAttributeTypeOrValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeTypeOrValueContext)
}

func (s *Quoted_targeted_attributes_listContext) AllORDelimiter() []IORDelimiterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IORDelimiterContext); ok {
			len++
		}
	}

	tst := make([]IORDelimiterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IORDelimiterContext); ok {
			tst[i] = t.(IORDelimiterContext)
			i++
		}
	}

	return tst
}

func (s *Quoted_targeted_attributes_listContext) ORDelimiter(i int) IORDelimiterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IORDelimiterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IORDelimiterContext)
}

func (s *Quoted_targeted_attributes_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterQuoted_targeted_attributes_list(s)
	}
}

func (s *Quoted_targeted_attributes_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitQuoted_targeted_attributes_list(s)
	}
}

type All_attributesContext struct {
	TargetedAttributesContext
}

func NewAll_attributesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *All_attributesContext {
	var p = new(All_attributesContext)

	InitEmptyTargetedAttributesContext(&p.TargetedAttributesContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetedAttributesContext))

	return p
}

func (s *All_attributesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *All_attributesContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *All_attributesContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *All_attributesContext) STAR() antlr.TerminalNode {
	return s.GetToken(ACIParserSTAR, 0)
}

func (s *All_attributesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAll_attributes(s)
	}
}

func (s *All_attributesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAll_attributes(s)
	}
}

func (p *ACIParser) TargetedAttributes() (localctx ITargetedAttributesContext) {
	localctx = NewTargetedAttributesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ACIParserRULE_targetedAttributes)
	var _la int

	p.SetState(519)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext()) {
	case 1:
		localctx = NewQuoted_targeted_attributes_listContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(491)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(492)
			p.AttributeTypeOrValue()
		}
		p.SetState(498)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ACIParserSYMBOLIC_OR {
			{
				p.SetState(493)
				p.ORDelimiter()
			}
			{
				p.SetState(494)
				p.AttributeTypeOrValue()
			}

			p.SetState(500)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

		{
			p.SetState(501)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewList_of_quoted_attributesContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(503)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(504)
			p.AttributeTypeOrValue()
		}
		{
			p.SetState(505)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(513)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ACIParserSYMBOLIC_OR {
			{
				p.SetState(506)
				p.ORDelimiter()
			}

			{
				p.SetState(507)
				p.Match(ACIParserDQUOTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(508)
				p.AttributeTypeOrValue()
			}
			{
				p.SetState(509)
				p.Match(ACIParserDQUOTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(515)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		localctx = NewAll_attributesContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(516)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(517)
			p.Match(ACIParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(518)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectIdentifierContext is an interface to support dynamic dispatch.
type IObjectIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsObjectIdentifierContext differentiates from other interfaces.
	IsObjectIdentifierContext()
}

type ObjectIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectIdentifierContext() *ObjectIdentifierContext {
	var p = new(ObjectIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_objectIdentifier
	return p
}

func InitEmptyObjectIdentifierContext(p *ObjectIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_objectIdentifier
}

func (*ObjectIdentifierContext) IsObjectIdentifierContext() {}

func NewObjectIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectIdentifierContext {
	var p = new(ObjectIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_objectIdentifier

	return p
}

func (s *ObjectIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectIdentifierContext) CopyAll(ctx *ObjectIdentifierContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ObjectIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Object_identifierContext struct {
	ObjectIdentifierContext
}

func NewObject_identifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Object_identifierContext {
	var p = new(Object_identifierContext)

	InitEmptyObjectIdentifierContext(&p.ObjectIdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*ObjectIdentifierContext))

	return p
}

func (s *Object_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Object_identifierContext) AllNumberForm() []INumberFormContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INumberFormContext); ok {
			len++
		}
	}

	tst := make([]INumberFormContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INumberFormContext); ok {
			tst[i] = t.(INumberFormContext)
			i++
		}
	}

	return tst
}

func (s *Object_identifierContext) NumberForm(i int) INumberFormContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberFormContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberFormContext)
}

func (s *Object_identifierContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDOT)
}

func (s *Object_identifierContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDOT, i)
}

func (s *Object_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterObject_identifier(s)
	}
}

func (s *Object_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitObject_identifier(s)
	}
}

func (p *ACIParser) ObjectIdentifier() (localctx IObjectIdentifierContext) {
	localctx = NewObjectIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ACIParserRULE_objectIdentifier)
	var _la int

	localctx = NewObject_identifierContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(521)
		p.NumberForm()
	}
	p.SetState(524)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ACIParserDOT {
		{
			p.SetState(522)
			p.Match(ACIParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(523)
			p.NumberForm()
		}

		p.SetState(526)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberFormContext is an interface to support dynamic dispatch.
type INumberFormContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNumberFormContext differentiates from other interfaces.
	IsNumberFormContext()
}

type NumberFormContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberFormContext() *NumberFormContext {
	var p = new(NumberFormContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_numberForm
	return p
}

func InitEmptyNumberFormContext(p *NumberFormContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_numberForm
}

func (*NumberFormContext) IsNumberFormContext() {}

func NewNumberFormContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberFormContext {
	var p = new(NumberFormContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_numberForm

	return p
}

func (s *NumberFormContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberFormContext) CopyAll(ctx *NumberFormContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *NumberFormContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberFormContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Number_formContext struct {
	NumberFormContext
}

func NewNumber_formContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Number_formContext {
	var p = new(Number_formContext)

	InitEmptyNumberFormContext(&p.NumberFormContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberFormContext))

	return p
}

func (s *Number_formContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Number_formContext) INT() antlr.TerminalNode {
	return s.GetToken(ACIParserINT, 0)
}

func (s *Number_formContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterNumber_form(s)
	}
}

func (s *Number_formContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitNumber_form(s)
	}
}

func (p *ACIParser) NumberForm() (localctx INumberFormContext) {
	localctx = NewNumberFormContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ACIParserRULE_numberForm)
	localctx = NewNumber_formContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(528)
		p.Match(ACIParserINT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetAttrFiltersValueContext is an interface to support dynamic dispatch.
type ITargetAttrFiltersValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTargetAttrFiltersValueContext differentiates from other interfaces.
	IsTargetAttrFiltersValueContext()
}

type TargetAttrFiltersValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetAttrFiltersValueContext() *TargetAttrFiltersValueContext {
	var p = new(TargetAttrFiltersValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetAttrFiltersValue
	return p
}

func InitEmptyTargetAttrFiltersValueContext(p *TargetAttrFiltersValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_targetAttrFiltersValue
}

func (*TargetAttrFiltersValueContext) IsTargetAttrFiltersValueContext() {}

func NewTargetAttrFiltersValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetAttrFiltersValueContext {
	var p = new(TargetAttrFiltersValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_targetAttrFiltersValue

	return p
}

func (s *TargetAttrFiltersValueContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetAttrFiltersValueContext) CopyAll(ctx *TargetAttrFiltersValueContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TargetAttrFiltersValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetAttrFiltersValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Attribute_filter_singleContext struct {
	TargetAttrFiltersValueContext
}

func NewAttribute_filter_singleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Attribute_filter_singleContext {
	var p = new(Attribute_filter_singleContext)

	InitEmptyTargetAttrFiltersValueContext(&p.TargetAttrFiltersValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetAttrFiltersValueContext))

	return p
}

func (s *Attribute_filter_singleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_filter_singleContext) AttributeFilter() IAttributeFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeFilterContext)
}

func (s *Attribute_filter_singleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAttribute_filter_single(s)
	}
}

func (s *Attribute_filter_singleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAttribute_filter_single(s)
	}
}

type Attribute_filters_setsContext struct {
	TargetAttrFiltersValueContext
}

func NewAttribute_filters_setsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Attribute_filters_setsContext {
	var p = new(Attribute_filters_setsContext)

	InitEmptyTargetAttrFiltersValueContext(&p.TargetAttrFiltersValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetAttrFiltersValueContext))

	return p
}

func (s *Attribute_filters_setsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_filters_setsContext) AttributeFilters() IAttributeFiltersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeFiltersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeFiltersContext)
}

func (s *Attribute_filters_setsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAttribute_filters_sets(s)
	}
}

func (s *Attribute_filters_setsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAttribute_filters_sets(s)
	}
}

type Attribute_filters_setContext struct {
	TargetAttrFiltersValueContext
}

func NewAttribute_filters_setContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Attribute_filters_setContext {
	var p = new(Attribute_filters_setContext)

	InitEmptyTargetAttrFiltersValueContext(&p.TargetAttrFiltersValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*TargetAttrFiltersValueContext))

	return p
}

func (s *Attribute_filters_setContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_filters_setContext) AttributeFilterSet() IAttributeFilterSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeFilterSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeFilterSetContext)
}

func (s *Attribute_filters_setContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAttribute_filters_set(s)
	}
}

func (s *Attribute_filters_setContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAttribute_filters_set(s)
	}
}

func (p *ACIParser) TargetAttrFiltersValue() (localctx ITargetAttrFiltersValueContext) {
	localctx = NewTargetAttrFiltersValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ACIParserRULE_targetAttrFiltersValue)
	p.SetState(533)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAttribute_filters_setsContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(530)
			p.AttributeFilters()
		}

	case 2:
		localctx = NewAttribute_filters_setContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(531)
			p.AttributeFilterSet()
		}

	case 3:
		localctx = NewAttribute_filter_singleContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(532)
			p.AttributeFilter()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeFiltersContext is an interface to support dynamic dispatch.
type IAttributeFiltersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAttributeFiltersContext differentiates from other interfaces.
	IsAttributeFiltersContext()
}

type AttributeFiltersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeFiltersContext() *AttributeFiltersContext {
	var p = new(AttributeFiltersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_attributeFilters
	return p
}

func InitEmptyAttributeFiltersContext(p *AttributeFiltersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_attributeFilters
}

func (*AttributeFiltersContext) IsAttributeFiltersContext() {}

func NewAttributeFiltersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeFiltersContext {
	var p = new(AttributeFiltersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_attributeFilters

	return p
}

func (s *AttributeFiltersContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeFiltersContext) CopyAll(ctx *AttributeFiltersContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AttributeFiltersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeFiltersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Attribute_filtersContext struct {
	AttributeFiltersContext
}

func NewAttribute_filtersContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Attribute_filtersContext {
	var p = new(Attribute_filtersContext)

	InitEmptyAttributeFiltersContext(&p.AttributeFiltersContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeFiltersContext))

	return p
}

func (s *Attribute_filtersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_filtersContext) AllAttributeFilterSet() []IAttributeFilterSetContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeFilterSetContext); ok {
			len++
		}
	}

	tst := make([]IAttributeFilterSetContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeFilterSetContext); ok {
			tst[i] = t.(IAttributeFilterSetContext)
			i++
		}
	}

	return tst
}

func (s *Attribute_filtersContext) AttributeFilterSet(i int) IAttributeFilterSetContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeFilterSetContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeFilterSetContext)
}

func (s *Attribute_filtersContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ACIParserCOMMA, 0)
}

func (s *Attribute_filtersContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ACIParserSEMI, 0)
}

func (s *Attribute_filtersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAttribute_filters(s)
	}
}

func (s *Attribute_filtersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAttribute_filters(s)
	}
}

func (p *ACIParser) AttributeFilters() (localctx IAttributeFiltersContext) {
	localctx = NewAttributeFiltersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ACIParserRULE_attributeFilters)
	var _la int

	localctx = NewAttribute_filtersContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(535)
		p.AttributeFilterSet()
	}
	{
		p.SetState(536)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ACIParserCOMMA || _la == ACIParserSEMI) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(537)
		p.AttributeFilterSet()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeFilterSetContext is an interface to support dynamic dispatch.
type IAttributeFilterSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAttributeFilterSetContext differentiates from other interfaces.
	IsAttributeFilterSetContext()
}

type AttributeFilterSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeFilterSetContext() *AttributeFilterSetContext {
	var p = new(AttributeFilterSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_attributeFilterSet
	return p
}

func InitEmptyAttributeFilterSetContext(p *AttributeFilterSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_attributeFilterSet
}

func (*AttributeFilterSetContext) IsAttributeFilterSetContext() {}

func NewAttributeFilterSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeFilterSetContext {
	var p = new(AttributeFilterSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_attributeFilterSet

	return p
}

func (s *AttributeFilterSetContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeFilterSetContext) CopyAll(ctx *AttributeFilterSetContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AttributeFilterSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeFilterSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Attribute_filter_setContext struct {
	AttributeFilterSetContext
}

func NewAttribute_filter_setContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Attribute_filter_setContext {
	var p = new(Attribute_filter_setContext)

	InitEmptyAttributeFilterSetContext(&p.AttributeFilterSetContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeFilterSetContext))

	return p
}

func (s *Attribute_filter_setContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_filter_setContext) AttributeFilterOperation() IAttributeFilterOperationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeFilterOperationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeFilterOperationContext)
}

func (s *Attribute_filter_setContext) AllAttributeFilter() []IAttributeFilterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeFilterContext); ok {
			len++
		}
	}

	tst := make([]IAttributeFilterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeFilterContext); ok {
			tst[i] = t.(IAttributeFilterContext)
			i++
		}
	}

	return tst
}

func (s *Attribute_filter_setContext) AttributeFilter(i int) IAttributeFilterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeFilterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeFilterContext)
}

func (s *Attribute_filter_setContext) AllANDDelimiter() []IANDDelimiterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IANDDelimiterContext); ok {
			len++
		}
	}

	tst := make([]IANDDelimiterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IANDDelimiterContext); ok {
			tst[i] = t.(IANDDelimiterContext)
			i++
		}
	}

	return tst
}

func (s *Attribute_filter_setContext) ANDDelimiter(i int) IANDDelimiterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IANDDelimiterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IANDDelimiterContext)
}

func (s *Attribute_filter_setContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAttribute_filter_set(s)
	}
}

func (s *Attribute_filter_setContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAttribute_filter_set(s)
	}
}

func (p *ACIParser) AttributeFilterSet() (localctx IAttributeFilterSetContext) {
	localctx = NewAttributeFilterSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ACIParserRULE_attributeFilterSet)
	var _la int

	localctx = NewAttribute_filter_setContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(539)
		p.AttributeFilterOperation()
	}
	{
		p.SetState(540)
		p.AttributeFilter()
	}
	p.SetState(546)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ACIParserSYMBOLIC_AND {
		{
			p.SetState(541)
			p.ANDDelimiter()
		}
		{
			p.SetState(542)
			p.AttributeFilter()
		}

		p.SetState(548)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeFilterOperationContext is an interface to support dynamic dispatch.
type IAttributeFilterOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAttributeFilterOperationContext differentiates from other interfaces.
	IsAttributeFilterOperationContext()
}

type AttributeFilterOperationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeFilterOperationContext() *AttributeFilterOperationContext {
	var p = new(AttributeFilterOperationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_attributeFilterOperation
	return p
}

func InitEmptyAttributeFilterOperationContext(p *AttributeFilterOperationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_attributeFilterOperation
}

func (*AttributeFilterOperationContext) IsAttributeFilterOperationContext() {}

func NewAttributeFilterOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeFilterOperationContext {
	var p = new(AttributeFilterOperationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_attributeFilterOperation

	return p
}

func (s *AttributeFilterOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeFilterOperationContext) CopyAll(ctx *AttributeFilterOperationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AttributeFilterOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeFilterOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Add_filter_operationContext struct {
	AttributeFilterOperationContext
}

func NewAdd_filter_operationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Add_filter_operationContext {
	var p = new(Add_filter_operationContext)

	InitEmptyAttributeFilterOperationContext(&p.AttributeFilterOperationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeFilterOperationContext))

	return p
}

func (s *Add_filter_operationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Add_filter_operationContext) AddFilterOperation() IAddFilterOperationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddFilterOperationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddFilterOperationContext)
}

func (s *Add_filter_operationContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Add_filter_operationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAdd_filter_operation(s)
	}
}

func (s *Add_filter_operationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAdd_filter_operation(s)
	}
}

type Delete_filter_operationContext struct {
	AttributeFilterOperationContext
}

func NewDelete_filter_operationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Delete_filter_operationContext {
	var p = new(Delete_filter_operationContext)

	InitEmptyAttributeFilterOperationContext(&p.AttributeFilterOperationContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeFilterOperationContext))

	return p
}

func (s *Delete_filter_operationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delete_filter_operationContext) DelFilterOperation() IDelFilterOperationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelFilterOperationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelFilterOperationContext)
}

func (s *Delete_filter_operationContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Delete_filter_operationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterDelete_filter_operation(s)
	}
}

func (s *Delete_filter_operationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitDelete_filter_operation(s)
	}
}

func (p *ACIParser) AttributeFilterOperation() (localctx IAttributeFilterOperationContext) {
	localctx = NewAttributeFilterOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ACIParserRULE_attributeFilterOperation)
	p.SetState(555)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserADD_PRIVILEGE:
		localctx = NewAdd_filter_operationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(549)
			p.AddFilterOperation()
		}
		{
			p.SetState(550)
			p.EqualTo()
		}

	case ACIParserDELETE_PRIVILEGE:
		localctx = NewDelete_filter_operationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(552)
			p.DelFilterOperation()
		}
		{
			p.SetState(553)
			p.EqualTo()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddFilterOperationContext is an interface to support dynamic dispatch.
type IAddFilterOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD_PRIVILEGE() antlr.TerminalNode

	// IsAddFilterOperationContext differentiates from other interfaces.
	IsAddFilterOperationContext()
}

type AddFilterOperationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddFilterOperationContext() *AddFilterOperationContext {
	var p = new(AddFilterOperationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_addFilterOperation
	return p
}

func InitEmptyAddFilterOperationContext(p *AddFilterOperationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_addFilterOperation
}

func (*AddFilterOperationContext) IsAddFilterOperationContext() {}

func NewAddFilterOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddFilterOperationContext {
	var p = new(AddFilterOperationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_addFilterOperation

	return p
}

func (s *AddFilterOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *AddFilterOperationContext) ADD_PRIVILEGE() antlr.TerminalNode {
	return s.GetToken(ACIParserADD_PRIVILEGE, 0)
}

func (s *AddFilterOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddFilterOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddFilterOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAddFilterOperation(s)
	}
}

func (s *AddFilterOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAddFilterOperation(s)
	}
}

func (p *ACIParser) AddFilterOperation() (localctx IAddFilterOperationContext) {
	localctx = NewAddFilterOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ACIParserRULE_addFilterOperation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(557)
		p.Match(ACIParserADD_PRIVILEGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDelFilterOperationContext is an interface to support dynamic dispatch.
type IDelFilterOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELETE_PRIVILEGE() antlr.TerminalNode

	// IsDelFilterOperationContext differentiates from other interfaces.
	IsDelFilterOperationContext()
}

type DelFilterOperationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelFilterOperationContext() *DelFilterOperationContext {
	var p = new(DelFilterOperationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_delFilterOperation
	return p
}

func InitEmptyDelFilterOperationContext(p *DelFilterOperationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_delFilterOperation
}

func (*DelFilterOperationContext) IsDelFilterOperationContext() {}

func NewDelFilterOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DelFilterOperationContext {
	var p = new(DelFilterOperationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_delFilterOperation

	return p
}

func (s *DelFilterOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *DelFilterOperationContext) DELETE_PRIVILEGE() antlr.TerminalNode {
	return s.GetToken(ACIParserDELETE_PRIVILEGE, 0)
}

func (s *DelFilterOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DelFilterOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DelFilterOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterDelFilterOperation(s)
	}
}

func (s *DelFilterOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitDelFilterOperation(s)
	}
}

func (p *ACIParser) DelFilterOperation() (localctx IDelFilterOperationContext) {
	localctx = NewDelFilterOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ACIParserRULE_delFilterOperation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(559)
		p.Match(ACIParserDELETE_PRIVILEGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeFilterContext is an interface to support dynamic dispatch.
type IAttributeFilterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAttributeFilterContext differentiates from other interfaces.
	IsAttributeFilterContext()
}

type AttributeFilterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeFilterContext() *AttributeFilterContext {
	var p = new(AttributeFilterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_attributeFilter
	return p
}

func InitEmptyAttributeFilterContext(p *AttributeFilterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_attributeFilter
}

func (*AttributeFilterContext) IsAttributeFilterContext() {}

func NewAttributeFilterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeFilterContext {
	var p = new(AttributeFilterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_attributeFilter

	return p
}

func (s *AttributeFilterContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeFilterContext) CopyAll(ctx *AttributeFilterContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AttributeFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeFilterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Attribute_filterContext struct {
	AttributeFilterContext
}

func NewAttribute_filterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Attribute_filterContext {
	var p = new(Attribute_filterContext)

	InitEmptyAttributeFilterContext(&p.AttributeFilterContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeFilterContext))

	return p
}

func (s *Attribute_filterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_filterContext) AttributeTypeOrValue() IAttributeTypeOrValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeTypeOrValueContext)
}

func (s *Attribute_filterContext) COLON() antlr.TerminalNode {
	return s.GetToken(ACIParserCOLON, 0)
}

func (s *Attribute_filterContext) LDAPFilter() ILDAPFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILDAPFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILDAPFilterContext)
}

func (s *Attribute_filterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAttribute_filter(s)
	}
}

func (s *Attribute_filterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAttribute_filter(s)
	}
}

func (p *ACIParser) AttributeFilter() (localctx IAttributeFilterContext) {
	localctx = NewAttributeFilterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ACIParserRULE_attributeFilter)
	localctx = NewAttribute_filterContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(561)
		p.AttributeTypeOrValue()
	}
	{
		p.SetState(562)
		p.Match(ACIParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(563)
		p.LDAPFilter()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindRuleContext is an interface to support dynamic dispatch.
type IBindRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBindRuleContext differentiates from other interfaces.
	IsBindRuleContext()
}

type BindRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindRuleContext() *BindRuleContext {
	var p = new(BindRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindRule
	return p
}

func InitEmptyBindRuleContext(p *BindRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindRule
}

func (*BindRuleContext) IsBindRuleContext() {}

func NewBindRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindRuleContext {
	var p = new(BindRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_bindRule

	return p
}

func (s *BindRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *BindRuleContext) CopyAll(ctx *BindRuleContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BindRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Parenthetical_bind_ruleContext struct {
	BindRuleContext
}

func NewParenthetical_bind_ruleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_bind_ruleContext {
	var p = new(Parenthetical_bind_ruleContext)

	InitEmptyBindRuleContext(&p.BindRuleContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleContext))

	return p
}

func (s *Parenthetical_bind_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_bind_ruleContext) AllBindRuleExprParen() []IBindRuleExprParenContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBindRuleExprParenContext); ok {
			len++
		}
	}

	tst := make([]IBindRuleExprParenContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBindRuleExprParenContext); ok {
			tst[i] = t.(IBindRuleExprParenContext)
			i++
		}
	}

	return tst
}

func (s *Parenthetical_bind_ruleContext) BindRuleExprParen(i int) IBindRuleExprParenContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindRuleExprParenContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindRuleExprParenContext)
}

func (s *Parenthetical_bind_ruleContext) AllBOOLEAN_AND() []antlr.TerminalNode {
	return s.GetTokens(ACIParserBOOLEAN_AND)
}

func (s *Parenthetical_bind_ruleContext) BOOLEAN_AND(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserBOOLEAN_AND, i)
}

func (s *Parenthetical_bind_ruleContext) AllBOOLEAN_OR() []antlr.TerminalNode {
	return s.GetTokens(ACIParserBOOLEAN_OR)
}

func (s *Parenthetical_bind_ruleContext) BOOLEAN_OR(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserBOOLEAN_OR, i)
}

func (s *Parenthetical_bind_ruleContext) AllBOOLEAN_NOT() []antlr.TerminalNode {
	return s.GetTokens(ACIParserBOOLEAN_NOT)
}

func (s *Parenthetical_bind_ruleContext) BOOLEAN_NOT(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserBOOLEAN_NOT, i)
}

func (s *Parenthetical_bind_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_bind_rule(s)
	}
}

func (s *Parenthetical_bind_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_bind_rule(s)
	}
}

type Bind_ruleContext struct {
	BindRuleContext
}

func NewBind_ruleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Bind_ruleContext {
	var p = new(Bind_ruleContext)

	InitEmptyBindRuleContext(&p.BindRuleContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleContext))

	return p
}

func (s *Bind_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_ruleContext) BindRuleExpr() IBindRuleExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindRuleExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindRuleExprContext)
}

func (s *Bind_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterBind_rule(s)
	}
}

func (s *Bind_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitBind_rule(s)
	}
}

func (p *ACIParser) BindRule() (localctx IBindRuleContext) {
	localctx = NewBindRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ACIParserRULE_bindRule)
	var _la int

	p.SetState(574)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext()) {
	case 1:
		localctx = NewBind_ruleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(565)
			p.BindRuleExpr()
		}

	case 2:
		localctx = NewParenthetical_bind_ruleContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(566)
			p.BindRuleExprParen()
		}
		p.SetState(571)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for (int64((_la-91)) & ^0x3f) == 0 && ((int64(1)<<(_la-91))&7) != 0 {
			{
				p.SetState(567)
				_la = p.GetTokenStream().LA(1)

				if !((int64((_la-91)) & ^0x3f) == 0 && ((int64(1)<<(_la-91))&7) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(568)
				p.BindRuleExprParen()
			}

			p.SetState(573)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindRuleExprParenContext is an interface to support dynamic dispatch.
type IBindRuleExprParenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBindRuleExprParenContext differentiates from other interfaces.
	IsBindRuleExprParenContext()
}

type BindRuleExprParenContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindRuleExprParenContext() *BindRuleExprParenContext {
	var p = new(BindRuleExprParenContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindRuleExprParen
	return p
}

func InitEmptyBindRuleExprParenContext(p *BindRuleExprParenContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindRuleExprParen
}

func (*BindRuleExprParenContext) IsBindRuleExprParenContext() {}

func NewBindRuleExprParenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindRuleExprParenContext {
	var p = new(BindRuleExprParenContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_bindRuleExprParen

	return p
}

func (s *BindRuleExprParenContext) GetParser() antlr.Parser { return s.parser }

func (s *BindRuleExprParenContext) CopyAll(ctx *BindRuleExprParenContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BindRuleExprParenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindRuleExprParenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Bind_rule_expression_recursionContext struct {
	BindRuleExprParenContext
}

func NewBind_rule_expression_recursionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Bind_rule_expression_recursionContext {
	var p = new(Bind_rule_expression_recursionContext)

	InitEmptyBindRuleExprParenContext(&p.BindRuleExprParenContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprParenContext))

	return p
}

func (s *Bind_rule_expression_recursionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_rule_expression_recursionContext) BindRuleExpr() IBindRuleExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindRuleExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindRuleExprContext)
}

func (s *Bind_rule_expression_recursionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterBind_rule_expression_recursion(s)
	}
}

func (s *Bind_rule_expression_recursionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitBind_rule_expression_recursion(s)
	}
}

type Parenthetical_bind_rule_req_bool_opContext struct {
	BindRuleExprParenContext
}

func NewParenthetical_bind_rule_req_bool_opContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_bind_rule_req_bool_opContext {
	var p = new(Parenthetical_bind_rule_req_bool_opContext)

	InitEmptyBindRuleExprParenContext(&p.BindRuleExprParenContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprParenContext))

	return p
}

func (s *Parenthetical_bind_rule_req_bool_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_bind_rule_req_bool_opContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Parenthetical_bind_rule_req_bool_opContext) AllBindRuleExpr() []IBindRuleExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBindRuleExprContext); ok {
			len++
		}
	}

	tst := make([]IBindRuleExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBindRuleExprContext); ok {
			tst[i] = t.(IBindRuleExprContext)
			i++
		}
	}

	return tst
}

func (s *Parenthetical_bind_rule_req_bool_opContext) BindRuleExpr(i int) IBindRuleExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindRuleExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindRuleExprContext)
}

func (s *Parenthetical_bind_rule_req_bool_opContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Parenthetical_bind_rule_req_bool_opContext) AllBOOLEAN_AND() []antlr.TerminalNode {
	return s.GetTokens(ACIParserBOOLEAN_AND)
}

func (s *Parenthetical_bind_rule_req_bool_opContext) BOOLEAN_AND(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserBOOLEAN_AND, i)
}

func (s *Parenthetical_bind_rule_req_bool_opContext) AllBOOLEAN_OR() []antlr.TerminalNode {
	return s.GetTokens(ACIParserBOOLEAN_OR)
}

func (s *Parenthetical_bind_rule_req_bool_opContext) BOOLEAN_OR(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserBOOLEAN_OR, i)
}

func (s *Parenthetical_bind_rule_req_bool_opContext) AllBOOLEAN_NOT() []antlr.TerminalNode {
	return s.GetTokens(ACIParserBOOLEAN_NOT)
}

func (s *Parenthetical_bind_rule_req_bool_opContext) BOOLEAN_NOT(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserBOOLEAN_NOT, i)
}

func (s *Parenthetical_bind_rule_req_bool_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_bind_rule_req_bool_op(s)
	}
}

func (s *Parenthetical_bind_rule_req_bool_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_bind_rule_req_bool_op(s)
	}
}

type Parenthetical_bind_rule_expressionContext struct {
	BindRuleExprParenContext
}

func NewParenthetical_bind_rule_expressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_bind_rule_expressionContext {
	var p = new(Parenthetical_bind_rule_expressionContext)

	InitEmptyBindRuleExprParenContext(&p.BindRuleExprParenContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprParenContext))

	return p
}

func (s *Parenthetical_bind_rule_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_bind_rule_expressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Parenthetical_bind_rule_expressionContext) BindRuleExpr() IBindRuleExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindRuleExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindRuleExprContext)
}

func (s *Parenthetical_bind_rule_expressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Parenthetical_bind_rule_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_bind_rule_expression(s)
	}
}

func (s *Parenthetical_bind_rule_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_bind_rule_expression(s)
	}
}

type Negated_bind_rule_expressionContext struct {
	BindRuleExprParenContext
}

func NewNegated_bind_rule_expressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Negated_bind_rule_expressionContext {
	var p = new(Negated_bind_rule_expressionContext)

	InitEmptyBindRuleExprParenContext(&p.BindRuleExprParenContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprParenContext))

	return p
}

func (s *Negated_bind_rule_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Negated_bind_rule_expressionContext) BOOLEAN_NOT() antlr.TerminalNode {
	return s.GetToken(ACIParserBOOLEAN_NOT, 0)
}

func (s *Negated_bind_rule_expressionContext) BindRuleExpr() IBindRuleExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindRuleExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindRuleExprContext)
}

func (s *Negated_bind_rule_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterNegated_bind_rule_expression(s)
	}
}

func (s *Negated_bind_rule_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitNegated_bind_rule_expression(s)
	}
}

func (p *ACIParser) BindRuleExprParen() (localctx IBindRuleExprParenContext) {
	localctx = NewBindRuleExprParenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ACIParserRULE_bindRuleExprParen)
	var _la int

	p.SetState(594)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext()) {
	case 1:
		localctx = NewParenthetical_bind_rule_req_bool_opContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(576)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(577)
			p.BindRuleExpr()
		}
		p.SetState(582)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for (int64((_la-91)) & ^0x3f) == 0 && ((int64(1)<<(_la-91))&7) != 0 {
			{
				p.SetState(578)
				_la = p.GetTokenStream().LA(1)

				if !((int64((_la-91)) & ^0x3f) == 0 && ((int64(1)<<(_la-91))&7) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(579)
				p.BindRuleExpr()
			}

			p.SetState(584)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(585)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewNegated_bind_rule_expressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(587)
			p.Match(ACIParserBOOLEAN_NOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(588)
			p.BindRuleExpr()
		}

	case 3:
		localctx = NewParenthetical_bind_rule_expressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(589)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(590)
			p.BindRuleExpr()
		}
		{
			p.SetState(591)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewBind_rule_expression_recursionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(593)
			p.BindRuleExpr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindRuleExprContext is an interface to support dynamic dispatch.
type IBindRuleExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBindRuleExprContext differentiates from other interfaces.
	IsBindRuleExprContext()
}

type BindRuleExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindRuleExprContext() *BindRuleExprContext {
	var p = new(BindRuleExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindRuleExpr
	return p
}

func InitEmptyBindRuleExprContext(p *BindRuleExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindRuleExpr
}

func (*BindRuleExprContext) IsBindRuleExprContext() {}

func NewBindRuleExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindRuleExprContext {
	var p = new(BindRuleExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_bindRuleExpr

	return p
}

func (s *BindRuleExprContext) GetParser() antlr.Parser { return s.parser }

func (s *BindRuleExprContext) CopyAll(ctx *BindRuleExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BindRuleExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindRuleExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Rule_is_rolednContext struct {
	BindRuleExprContext
}

func NewRule_is_rolednContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Rule_is_rolednContext {
	var p = new(Rule_is_rolednContext)

	InitEmptyBindRuleExprContext(&p.BindRuleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprContext))

	return p
}

func (s *Rule_is_rolednContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rule_is_rolednContext) BindRoleDN() IBindRoleDNContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindRoleDNContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindRoleDNContext)
}

func (s *Rule_is_rolednContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterRule_is_roledn(s)
	}
}

func (s *Rule_is_rolednContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitRule_is_roledn(s)
	}
}

type Rule_is_ipContext struct {
	BindRuleExprContext
}

func NewRule_is_ipContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Rule_is_ipContext {
	var p = new(Rule_is_ipContext)

	InitEmptyBindRuleExprContext(&p.BindRuleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprContext))

	return p
}

func (s *Rule_is_ipContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rule_is_ipContext) BindIP() IBindIPContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindIPContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindIPContext)
}

func (s *Rule_is_ipContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterRule_is_ip(s)
	}
}

func (s *Rule_is_ipContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitRule_is_ip(s)
	}
}

type Rule_is_authmethodContext struct {
	BindRuleExprContext
}

func NewRule_is_authmethodContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Rule_is_authmethodContext {
	var p = new(Rule_is_authmethodContext)

	InitEmptyBindRuleExprContext(&p.BindRuleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprContext))

	return p
}

func (s *Rule_is_authmethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rule_is_authmethodContext) BindAuthMethod() IBindAuthMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindAuthMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindAuthMethodContext)
}

func (s *Rule_is_authmethodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterRule_is_authmethod(s)
	}
}

func (s *Rule_is_authmethodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitRule_is_authmethod(s)
	}
}

type Rule_is_userdnContext struct {
	BindRuleExprContext
}

func NewRule_is_userdnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Rule_is_userdnContext {
	var p = new(Rule_is_userdnContext)

	InitEmptyBindRuleExprContext(&p.BindRuleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprContext))

	return p
}

func (s *Rule_is_userdnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rule_is_userdnContext) BindUserDN() IBindUserDNContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindUserDNContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindUserDNContext)
}

func (s *Rule_is_userdnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterRule_is_userdn(s)
	}
}

func (s *Rule_is_userdnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitRule_is_userdn(s)
	}
}

type Rule_is_userattrContext struct {
	BindRuleExprContext
}

func NewRule_is_userattrContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Rule_is_userattrContext {
	var p = new(Rule_is_userattrContext)

	InitEmptyBindRuleExprContext(&p.BindRuleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprContext))

	return p
}

func (s *Rule_is_userattrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rule_is_userattrContext) BindUserAttr() IBindUserAttrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindUserAttrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindUserAttrContext)
}

func (s *Rule_is_userattrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterRule_is_userattr(s)
	}
}

func (s *Rule_is_userattrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitRule_is_userattr(s)
	}
}

type Rule_is_timeofdayContext struct {
	BindRuleExprContext
}

func NewRule_is_timeofdayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Rule_is_timeofdayContext {
	var p = new(Rule_is_timeofdayContext)

	InitEmptyBindRuleExprContext(&p.BindRuleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprContext))

	return p
}

func (s *Rule_is_timeofdayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rule_is_timeofdayContext) BindTimeOfDay() IBindTimeOfDayContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindTimeOfDayContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindTimeOfDayContext)
}

func (s *Rule_is_timeofdayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterRule_is_timeofday(s)
	}
}

func (s *Rule_is_timeofdayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitRule_is_timeofday(s)
	}
}

type Rule_is_groupattrContext struct {
	BindRuleExprContext
}

func NewRule_is_groupattrContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Rule_is_groupattrContext {
	var p = new(Rule_is_groupattrContext)

	InitEmptyBindRuleExprContext(&p.BindRuleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprContext))

	return p
}

func (s *Rule_is_groupattrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rule_is_groupattrContext) BindGroupAttr() IBindGroupAttrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindGroupAttrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindGroupAttrContext)
}

func (s *Rule_is_groupattrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterRule_is_groupattr(s)
	}
}

func (s *Rule_is_groupattrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitRule_is_groupattr(s)
	}
}

type Rule_is_parentheticalContext struct {
	BindRuleExprContext
}

func NewRule_is_parentheticalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Rule_is_parentheticalContext {
	var p = new(Rule_is_parentheticalContext)

	InitEmptyBindRuleExprContext(&p.BindRuleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprContext))

	return p
}

func (s *Rule_is_parentheticalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rule_is_parentheticalContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Rule_is_parentheticalContext) BindRuleExpr() IBindRuleExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindRuleExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindRuleExprContext)
}

func (s *Rule_is_parentheticalContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Rule_is_parentheticalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterRule_is_parenthetical(s)
	}
}

func (s *Rule_is_parentheticalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitRule_is_parenthetical(s)
	}
}

type Rule_is_ssfContext struct {
	BindRuleExprContext
}

func NewRule_is_ssfContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Rule_is_ssfContext {
	var p = new(Rule_is_ssfContext)

	InitEmptyBindRuleExprContext(&p.BindRuleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprContext))

	return p
}

func (s *Rule_is_ssfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rule_is_ssfContext) BindSecurityStrengthFactor() IBindSecurityStrengthFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindSecurityStrengthFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindSecurityStrengthFactorContext)
}

func (s *Rule_is_ssfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterRule_is_ssf(s)
	}
}

func (s *Rule_is_ssfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitRule_is_ssf(s)
	}
}

type Rule_is_dnsContext struct {
	BindRuleExprContext
}

func NewRule_is_dnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Rule_is_dnsContext {
	var p = new(Rule_is_dnsContext)

	InitEmptyBindRuleExprContext(&p.BindRuleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprContext))

	return p
}

func (s *Rule_is_dnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rule_is_dnsContext) BindDNS() IBindDNSContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindDNSContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindDNSContext)
}

func (s *Rule_is_dnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterRule_is_dns(s)
	}
}

func (s *Rule_is_dnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitRule_is_dns(s)
	}
}

type Rule_is_dayofweekContext struct {
	BindRuleExprContext
}

func NewRule_is_dayofweekContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Rule_is_dayofweekContext {
	var p = new(Rule_is_dayofweekContext)

	InitEmptyBindRuleExprContext(&p.BindRuleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprContext))

	return p
}

func (s *Rule_is_dayofweekContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rule_is_dayofweekContext) BindDayOfWeek() IBindDayOfWeekContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindDayOfWeekContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindDayOfWeekContext)
}

func (s *Rule_is_dayofweekContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterRule_is_dayofweek(s)
	}
}

func (s *Rule_is_dayofweekContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitRule_is_dayofweek(s)
	}
}

type Rule_is_groupdnContext struct {
	BindRuleExprContext
}

func NewRule_is_groupdnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Rule_is_groupdnContext {
	var p = new(Rule_is_groupdnContext)

	InitEmptyBindRuleExprContext(&p.BindRuleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRuleExprContext))

	return p
}

func (s *Rule_is_groupdnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rule_is_groupdnContext) BindGroupDN() IBindGroupDNContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindGroupDNContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindGroupDNContext)
}

func (s *Rule_is_groupdnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterRule_is_groupdn(s)
	}
}

func (s *Rule_is_groupdnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitRule_is_groupdn(s)
	}
}

func (p *ACIParser) BindRuleExpr() (localctx IBindRuleExprContext) {
	localctx = NewBindRuleExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ACIParserRULE_bindRuleExpr)
	p.SetState(611)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		localctx = NewRule_is_parentheticalContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(596)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(597)
			p.BindRuleExpr()
		}
		{
			p.SetState(598)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewRule_is_userdnContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(600)
			p.BindUserDN()
		}

	case 3:
		localctx = NewRule_is_userattrContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(601)
			p.BindUserAttr()
		}

	case 4:
		localctx = NewRule_is_groupdnContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(602)
			p.BindGroupDN()
		}

	case 5:
		localctx = NewRule_is_groupattrContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(603)
			p.BindGroupAttr()
		}

	case 6:
		localctx = NewRule_is_rolednContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(604)
			p.BindRoleDN()
		}

	case 7:
		localctx = NewRule_is_dnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(605)
			p.BindDNS()
		}

	case 8:
		localctx = NewRule_is_ipContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(606)
			p.BindIP()
		}

	case 9:
		localctx = NewRule_is_timeofdayContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(607)
			p.BindTimeOfDay()
		}

	case 10:
		localctx = NewRule_is_dayofweekContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(608)
			p.BindDayOfWeek()
		}

	case 11:
		localctx = NewRule_is_ssfContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(609)
			p.BindSecurityStrengthFactor()
		}

	case 12:
		localctx = NewRule_is_authmethodContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(610)
			p.BindAuthMethod()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindDayOfWeekContext is an interface to support dynamic dispatch.
type IBindDayOfWeekContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBindDayOfWeekContext differentiates from other interfaces.
	IsBindDayOfWeekContext()
}

type BindDayOfWeekContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindDayOfWeekContext() *BindDayOfWeekContext {
	var p = new(BindDayOfWeekContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindDayOfWeek
	return p
}

func InitEmptyBindDayOfWeekContext(p *BindDayOfWeekContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindDayOfWeek
}

func (*BindDayOfWeekContext) IsBindDayOfWeekContext() {}

func NewBindDayOfWeekContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindDayOfWeekContext {
	var p = new(BindDayOfWeekContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_bindDayOfWeek

	return p
}

func (s *BindDayOfWeekContext) GetParser() antlr.Parser { return s.parser }

func (s *BindDayOfWeekContext) CopyAll(ctx *BindDayOfWeekContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BindDayOfWeekContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindDayOfWeekContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Dayofweek_bind_ruleContext struct {
	BindDayOfWeekContext
}

func NewDayofweek_bind_ruleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Dayofweek_bind_ruleContext {
	var p = new(Dayofweek_bind_ruleContext)

	InitEmptyBindDayOfWeekContext(&p.BindDayOfWeekContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindDayOfWeekContext))

	return p
}

func (s *Dayofweek_bind_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dayofweek_bind_ruleContext) BIND_DAY_OF_WEEK() antlr.TerminalNode {
	return s.GetToken(ACIParserBIND_DAY_OF_WEEK, 0)
}

func (s *Dayofweek_bind_ruleContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Dayofweek_bind_ruleContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Dayofweek_bind_ruleContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Dayofweek_bind_ruleContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Dayofweek_bind_ruleContext) AllDoW() []IDoWContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDoWContext); ok {
			len++
		}
	}

	tst := make([]IDoWContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDoWContext); ok {
			tst[i] = t.(IDoWContext)
			i++
		}
	}

	return tst
}

func (s *Dayofweek_bind_ruleContext) DoW(i int) IDoWContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoWContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoWContext)
}

func (s *Dayofweek_bind_ruleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ACIParserCOMMA)
}

func (s *Dayofweek_bind_ruleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserCOMMA, i)
}

func (s *Dayofweek_bind_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterDayofweek_bind_rule(s)
	}
}

func (s *Dayofweek_bind_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitDayofweek_bind_rule(s)
	}
}

type Parenthetical_dayofweek_bind_ruleContext struct {
	BindDayOfWeekContext
}

func NewParenthetical_dayofweek_bind_ruleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_dayofweek_bind_ruleContext {
	var p = new(Parenthetical_dayofweek_bind_ruleContext)

	InitEmptyBindDayOfWeekContext(&p.BindDayOfWeekContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindDayOfWeekContext))

	return p
}

func (s *Parenthetical_dayofweek_bind_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_dayofweek_bind_ruleContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Parenthetical_dayofweek_bind_ruleContext) BindDayOfWeek() IBindDayOfWeekContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindDayOfWeekContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindDayOfWeekContext)
}

func (s *Parenthetical_dayofweek_bind_ruleContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Parenthetical_dayofweek_bind_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_dayofweek_bind_rule(s)
	}
}

func (s *Parenthetical_dayofweek_bind_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_dayofweek_bind_rule(s)
	}
}

func (p *ACIParser) BindDayOfWeek() (localctx IBindDayOfWeekContext) {
	localctx = NewBindDayOfWeekContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ACIParserRULE_bindDayOfWeek)
	var _la int

	p.SetState(633)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserLPAREN:
		localctx = NewParenthetical_dayofweek_bind_ruleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(613)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(614)
			p.BindDayOfWeek()
		}
		{
			p.SetState(615)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserBIND_DAY_OF_WEEK:
		localctx = NewDayofweek_bind_ruleContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(617)
			p.Match(ACIParserBIND_DAY_OF_WEEK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(620)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ACIParserEQ:
			{
				p.SetState(618)
				p.EqualTo()
			}

		case ACIParserNE:
			{
				p.SetState(619)
				p.NotEqualTo()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(622)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(623)
			p.DoW()
		}
		p.SetState(628)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ACIParserCOMMA {
			{
				p.SetState(624)
				p.Match(ACIParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(625)
				p.DoW()
			}

			p.SetState(630)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

		{
			p.SetState(631)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDoWContext is an interface to support dynamic dispatch.
type IDoWContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDoWContext differentiates from other interfaces.
	IsDoWContext()
}

type DoWContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoWContext() *DoWContext {
	var p = new(DoWContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_doW
	return p
}

func InitEmptyDoWContext(p *DoWContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_doW
}

func (*DoWContext) IsDoWContext() {}

func NewDoWContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoWContext {
	var p = new(DoWContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_doW

	return p
}

func (s *DoWContext) GetParser() antlr.Parser { return s.parser }

func (s *DoWContext) CopyAll(ctx *DoWContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *DoWContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoWContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ThurdayContext struct {
	DoWContext
}

func NewThurdayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ThurdayContext {
	var p = new(ThurdayContext)

	InitEmptyDoWContext(&p.DoWContext)
	p.parser = parser
	p.CopyAll(ctx.(*DoWContext))

	return p
}

func (s *ThurdayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThurdayContext) Thur() IThurContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThurContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThurContext)
}

func (s *ThurdayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterThurday(s)
	}
}

func (s *ThurdayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitThurday(s)
	}
}

type MondayContext struct {
	DoWContext
}

func NewMondayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MondayContext {
	var p = new(MondayContext)

	InitEmptyDoWContext(&p.DoWContext)
	p.parser = parser
	p.CopyAll(ctx.(*DoWContext))

	return p
}

func (s *MondayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MondayContext) Mon() IMonContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMonContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMonContext)
}

func (s *MondayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterMonday(s)
	}
}

func (s *MondayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitMonday(s)
	}
}

type FridayContext struct {
	DoWContext
}

func NewFridayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FridayContext {
	var p = new(FridayContext)

	InitEmptyDoWContext(&p.DoWContext)
	p.parser = parser
	p.CopyAll(ctx.(*DoWContext))

	return p
}

func (s *FridayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FridayContext) Fri() IFriContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFriContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFriContext)
}

func (s *FridayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterFriday(s)
	}
}

func (s *FridayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitFriday(s)
	}
}

type SundayContext struct {
	DoWContext
}

func NewSundayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SundayContext {
	var p = new(SundayContext)

	InitEmptyDoWContext(&p.DoWContext)
	p.parser = parser
	p.CopyAll(ctx.(*DoWContext))

	return p
}

func (s *SundayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SundayContext) Sun() ISunContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISunContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISunContext)
}

func (s *SundayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSunday(s)
	}
}

func (s *SundayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSunday(s)
	}
}

type WednesdayContext struct {
	DoWContext
}

func NewWednesdayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WednesdayContext {
	var p = new(WednesdayContext)

	InitEmptyDoWContext(&p.DoWContext)
	p.parser = parser
	p.CopyAll(ctx.(*DoWContext))

	return p
}

func (s *WednesdayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WednesdayContext) Wed() IWedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWedContext)
}

func (s *WednesdayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterWednesday(s)
	}
}

func (s *WednesdayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitWednesday(s)
	}
}

type TuesdayContext struct {
	DoWContext
}

func NewTuesdayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TuesdayContext {
	var p = new(TuesdayContext)

	InitEmptyDoWContext(&p.DoWContext)
	p.parser = parser
	p.CopyAll(ctx.(*DoWContext))

	return p
}

func (s *TuesdayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TuesdayContext) Tues() ITuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITuesContext)
}

func (s *TuesdayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterTuesday(s)
	}
}

func (s *TuesdayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitTuesday(s)
	}
}

type SaturdayContext struct {
	DoWContext
}

func NewSaturdayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SaturdayContext {
	var p = new(SaturdayContext)

	InitEmptyDoWContext(&p.DoWContext)
	p.parser = parser
	p.CopyAll(ctx.(*DoWContext))

	return p
}

func (s *SaturdayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SaturdayContext) Sat() ISatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISatContext)
}

func (s *SaturdayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSaturday(s)
	}
}

func (s *SaturdayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSaturday(s)
	}
}

func (p *ACIParser) DoW() (localctx IDoWContext) {
	localctx = NewDoWContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ACIParserRULE_doW)
	p.SetState(642)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserSUNDAY:
		localctx = NewSundayContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(635)
			p.Sun()
		}

	case ACIParserMONDAY:
		localctx = NewMondayContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(636)
			p.Mon()
		}

	case ACIParserTUESDAY:
		localctx = NewTuesdayContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(637)
			p.Tues()
		}

	case ACIParserWEDNESDAY:
		localctx = NewWednesdayContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(638)
			p.Wed()
		}

	case ACIParserTHURSDAY:
		localctx = NewThurdayContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(639)
			p.Thur()
		}

	case ACIParserFRIDAY:
		localctx = NewFridayContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(640)
			p.Fri()
		}

	case ACIParserSATURDAY:
		localctx = NewSaturdayContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(641)
			p.Sat()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISunContext is an interface to support dynamic dispatch.
type ISunContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUNDAY() antlr.TerminalNode

	// IsSunContext differentiates from other interfaces.
	IsSunContext()
}

type SunContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySunContext() *SunContext {
	var p = new(SunContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_sun
	return p
}

func InitEmptySunContext(p *SunContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_sun
}

func (*SunContext) IsSunContext() {}

func NewSunContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SunContext {
	var p = new(SunContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_sun

	return p
}

func (s *SunContext) GetParser() antlr.Parser { return s.parser }

func (s *SunContext) SUNDAY() antlr.TerminalNode {
	return s.GetToken(ACIParserSUNDAY, 0)
}

func (s *SunContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SunContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SunContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSun(s)
	}
}

func (s *SunContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSun(s)
	}
}

func (p *ACIParser) Sun() (localctx ISunContext) {
	localctx = NewSunContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ACIParserRULE_sun)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(644)
		p.Match(ACIParserSUNDAY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMonContext is an interface to support dynamic dispatch.
type IMonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MONDAY() antlr.TerminalNode

	// IsMonContext differentiates from other interfaces.
	IsMonContext()
}

type MonContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMonContext() *MonContext {
	var p = new(MonContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_mon
	return p
}

func InitEmptyMonContext(p *MonContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_mon
}

func (*MonContext) IsMonContext() {}

func NewMonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MonContext {
	var p = new(MonContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_mon

	return p
}

func (s *MonContext) GetParser() antlr.Parser { return s.parser }

func (s *MonContext) MONDAY() antlr.TerminalNode {
	return s.GetToken(ACIParserMONDAY, 0)
}

func (s *MonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterMon(s)
	}
}

func (s *MonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitMon(s)
	}
}

func (p *ACIParser) Mon() (localctx IMonContext) {
	localctx = NewMonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, ACIParserRULE_mon)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(646)
		p.Match(ACIParserMONDAY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITuesContext is an interface to support dynamic dispatch.
type ITuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TUESDAY() antlr.TerminalNode

	// IsTuesContext differentiates from other interfaces.
	IsTuesContext()
}

type TuesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTuesContext() *TuesContext {
	var p = new(TuesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_tues
	return p
}

func InitEmptyTuesContext(p *TuesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_tues
}

func (*TuesContext) IsTuesContext() {}

func NewTuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TuesContext {
	var p = new(TuesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_tues

	return p
}

func (s *TuesContext) GetParser() antlr.Parser { return s.parser }

func (s *TuesContext) TUESDAY() antlr.TerminalNode {
	return s.GetToken(ACIParserTUESDAY, 0)
}

func (s *TuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterTues(s)
	}
}

func (s *TuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitTues(s)
	}
}

func (p *ACIParser) Tues() (localctx ITuesContext) {
	localctx = NewTuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ACIParserRULE_tues)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(648)
		p.Match(ACIParserTUESDAY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWedContext is an interface to support dynamic dispatch.
type IWedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WEDNESDAY() antlr.TerminalNode

	// IsWedContext differentiates from other interfaces.
	IsWedContext()
}

type WedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWedContext() *WedContext {
	var p = new(WedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_wed
	return p
}

func InitEmptyWedContext(p *WedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_wed
}

func (*WedContext) IsWedContext() {}

func NewWedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WedContext {
	var p = new(WedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_wed

	return p
}

func (s *WedContext) GetParser() antlr.Parser { return s.parser }

func (s *WedContext) WEDNESDAY() antlr.TerminalNode {
	return s.GetToken(ACIParserWEDNESDAY, 0)
}

func (s *WedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterWed(s)
	}
}

func (s *WedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitWed(s)
	}
}

func (p *ACIParser) Wed() (localctx IWedContext) {
	localctx = NewWedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ACIParserRULE_wed)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(650)
		p.Match(ACIParserWEDNESDAY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IThurContext is an interface to support dynamic dispatch.
type IThurContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	THURSDAY() antlr.TerminalNode

	// IsThurContext differentiates from other interfaces.
	IsThurContext()
}

type ThurContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThurContext() *ThurContext {
	var p = new(ThurContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_thur
	return p
}

func InitEmptyThurContext(p *ThurContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_thur
}

func (*ThurContext) IsThurContext() {}

func NewThurContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThurContext {
	var p = new(ThurContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_thur

	return p
}

func (s *ThurContext) GetParser() antlr.Parser { return s.parser }

func (s *ThurContext) THURSDAY() antlr.TerminalNode {
	return s.GetToken(ACIParserTHURSDAY, 0)
}

func (s *ThurContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThurContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThurContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterThur(s)
	}
}

func (s *ThurContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitThur(s)
	}
}

func (p *ACIParser) Thur() (localctx IThurContext) {
	localctx = NewThurContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, ACIParserRULE_thur)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(652)
		p.Match(ACIParserTHURSDAY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFriContext is an interface to support dynamic dispatch.
type IFriContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FRIDAY() antlr.TerminalNode

	// IsFriContext differentiates from other interfaces.
	IsFriContext()
}

type FriContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFriContext() *FriContext {
	var p = new(FriContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_fri
	return p
}

func InitEmptyFriContext(p *FriContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_fri
}

func (*FriContext) IsFriContext() {}

func NewFriContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FriContext {
	var p = new(FriContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_fri

	return p
}

func (s *FriContext) GetParser() antlr.Parser { return s.parser }

func (s *FriContext) FRIDAY() antlr.TerminalNode {
	return s.GetToken(ACIParserFRIDAY, 0)
}

func (s *FriContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FriContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FriContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterFri(s)
	}
}

func (s *FriContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitFri(s)
	}
}

func (p *ACIParser) Fri() (localctx IFriContext) {
	localctx = NewFriContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ACIParserRULE_fri)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(654)
		p.Match(ACIParserFRIDAY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISatContext is an interface to support dynamic dispatch.
type ISatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SATURDAY() antlr.TerminalNode

	// IsSatContext differentiates from other interfaces.
	IsSatContext()
}

type SatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySatContext() *SatContext {
	var p = new(SatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_sat
	return p
}

func InitEmptySatContext(p *SatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_sat
}

func (*SatContext) IsSatContext() {}

func NewSatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SatContext {
	var p = new(SatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_sat

	return p
}

func (s *SatContext) GetParser() antlr.Parser { return s.parser }

func (s *SatContext) SATURDAY() antlr.TerminalNode {
	return s.GetToken(ACIParserSATURDAY, 0)
}

func (s *SatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSat(s)
	}
}

func (s *SatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSat(s)
	}
}

func (p *ACIParser) Sat() (localctx ISatContext) {
	localctx = NewSatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, ACIParserRULE_sat)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(656)
		p.Match(ACIParserSATURDAY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindAuthMethodContext is an interface to support dynamic dispatch.
type IBindAuthMethodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBindAuthMethodContext differentiates from other interfaces.
	IsBindAuthMethodContext()
}

type BindAuthMethodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindAuthMethodContext() *BindAuthMethodContext {
	var p = new(BindAuthMethodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindAuthMethod
	return p
}

func InitEmptyBindAuthMethodContext(p *BindAuthMethodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindAuthMethod
}

func (*BindAuthMethodContext) IsBindAuthMethodContext() {}

func NewBindAuthMethodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindAuthMethodContext {
	var p = new(BindAuthMethodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_bindAuthMethod

	return p
}

func (s *BindAuthMethodContext) GetParser() antlr.Parser { return s.parser }

func (s *BindAuthMethodContext) CopyAll(ctx *BindAuthMethodContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BindAuthMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindAuthMethodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Authentication_methodContext struct {
	BindAuthMethodContext
}

func NewAuthentication_methodContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Authentication_methodContext {
	var p = new(Authentication_methodContext)

	InitEmptyBindAuthMethodContext(&p.BindAuthMethodContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindAuthMethodContext))

	return p
}

func (s *Authentication_methodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Authentication_methodContext) BIND_AUTH_METHOD() antlr.TerminalNode {
	return s.GetToken(ACIParserBIND_AUTH_METHOD, 0)
}

func (s *Authentication_methodContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Authentication_methodContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Authentication_methodContext) AuthenticationMethods() IAuthenticationMethodsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuthenticationMethodsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuthenticationMethodsContext)
}

func (s *Authentication_methodContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Authentication_methodContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Authentication_methodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAuthentication_method(s)
	}
}

func (s *Authentication_methodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAuthentication_method(s)
	}
}

type Parenthetical_authentication_methodContext struct {
	BindAuthMethodContext
}

func NewParenthetical_authentication_methodContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_authentication_methodContext {
	var p = new(Parenthetical_authentication_methodContext)

	InitEmptyBindAuthMethodContext(&p.BindAuthMethodContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindAuthMethodContext))

	return p
}

func (s *Parenthetical_authentication_methodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_authentication_methodContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Parenthetical_authentication_methodContext) BindAuthMethod() IBindAuthMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindAuthMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindAuthMethodContext)
}

func (s *Parenthetical_authentication_methodContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Parenthetical_authentication_methodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_authentication_method(s)
	}
}

func (s *Parenthetical_authentication_methodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_authentication_method(s)
	}
}

func (p *ACIParser) BindAuthMethod() (localctx IBindAuthMethodContext) {
	localctx = NewBindAuthMethodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, ACIParserRULE_bindAuthMethod)
	p.SetState(671)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserLPAREN:
		localctx = NewParenthetical_authentication_methodContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(658)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(659)
			p.BindAuthMethod()
		}
		{
			p.SetState(660)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserBIND_AUTH_METHOD:
		localctx = NewAuthentication_methodContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(662)
			p.Match(ACIParserBIND_AUTH_METHOD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(665)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ACIParserEQ:
			{
				p.SetState(663)
				p.EqualTo()
			}

		case ACIParserNE:
			{
				p.SetState(664)
				p.NotEqualTo()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(667)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(668)
			p.AuthenticationMethods()
		}
		{
			p.SetState(669)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAuthenticationMethodsContext is an interface to support dynamic dispatch.
type IAuthenticationMethodsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAuthenticationMethodsContext differentiates from other interfaces.
	IsAuthenticationMethodsContext()
}

type AuthenticationMethodsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAuthenticationMethodsContext() *AuthenticationMethodsContext {
	var p = new(AuthenticationMethodsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_authenticationMethods
	return p
}

func InitEmptyAuthenticationMethodsContext(p *AuthenticationMethodsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_authenticationMethods
}

func (*AuthenticationMethodsContext) IsAuthenticationMethodsContext() {}

func NewAuthenticationMethodsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AuthenticationMethodsContext {
	var p = new(AuthenticationMethodsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_authenticationMethods

	return p
}

func (s *AuthenticationMethodsContext) GetParser() antlr.Parser { return s.parser }

func (s *AuthenticationMethodsContext) CopyAll(ctx *AuthenticationMethodsContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AuthenticationMethodsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AuthenticationMethodsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SaslContext struct {
	AuthenticationMethodsContext
}

func NewSaslContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SaslContext {
	var p = new(SaslContext)

	InitEmptyAuthenticationMethodsContext(&p.AuthenticationMethodsContext)
	p.parser = parser
	p.CopyAll(ctx.(*AuthenticationMethodsContext))

	return p
}

func (s *SaslContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SaslContext) SASLAuth() ISASLAuthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISASLAuthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISASLAuthContext)
}

func (s *SaslContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSasl(s)
	}
}

func (s *SaslContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSasl(s)
	}
}

type SimpleContext struct {
	AuthenticationMethodsContext
}

func NewSimpleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleContext {
	var p = new(SimpleContext)

	InitEmptyAuthenticationMethodsContext(&p.AuthenticationMethodsContext)
	p.parser = parser
	p.CopyAll(ctx.(*AuthenticationMethodsContext))

	return p
}

func (s *SimpleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleContext) SimpleAuth() ISimpleAuthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleAuthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleAuthContext)
}

func (s *SimpleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSimple(s)
	}
}

func (s *SimpleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSimple(s)
	}
}

type NoneContext struct {
	AuthenticationMethodsContext
}

func NewNoneContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NoneContext {
	var p = new(NoneContext)

	InitEmptyAuthenticationMethodsContext(&p.AuthenticationMethodsContext)
	p.parser = parser
	p.CopyAll(ctx.(*AuthenticationMethodsContext))

	return p
}

func (s *NoneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NoneContext) AnonAuth() IAnonAuthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnonAuthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnonAuthContext)
}

func (s *NoneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterNone(s)
	}
}

func (s *NoneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitNone(s)
	}
}

type SslContext struct {
	AuthenticationMethodsContext
}

func NewSslContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SslContext {
	var p = new(SslContext)

	InitEmptyAuthenticationMethodsContext(&p.AuthenticationMethodsContext)
	p.parser = parser
	p.CopyAll(ctx.(*AuthenticationMethodsContext))

	return p
}

func (s *SslContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SslContext) SSLAuth() ISSLAuthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISSLAuthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISSLAuthContext)
}

func (s *SslContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSsl(s)
	}
}

func (s *SslContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSsl(s)
	}
}

func (p *ACIParser) AuthenticationMethods() (localctx IAuthenticationMethodsContext) {
	localctx = NewAuthenticationMethodsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, ACIParserRULE_authenticationMethods)
	p.SetState(677)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserANONYMOUS:
		localctx = NewNoneContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(673)
			p.AnonAuth()
		}

	case ACIParserSIMPLE:
		localctx = NewSimpleContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(674)
			p.SimpleAuth()
		}

	case ACIParserSSL:
		localctx = NewSslContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(675)
			p.SSLAuth()
		}

	case ACIParserSASL:
		localctx = NewSaslContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(676)
			p.SASLAuth()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnonAuthContext is an interface to support dynamic dispatch.
type IAnonAuthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ANONYMOUS() antlr.TerminalNode

	// IsAnonAuthContext differentiates from other interfaces.
	IsAnonAuthContext()
}

type AnonAuthContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnonAuthContext() *AnonAuthContext {
	var p = new(AnonAuthContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_anonAuth
	return p
}

func InitEmptyAnonAuthContext(p *AnonAuthContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_anonAuth
}

func (*AnonAuthContext) IsAnonAuthContext() {}

func NewAnonAuthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnonAuthContext {
	var p = new(AnonAuthContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_anonAuth

	return p
}

func (s *AnonAuthContext) GetParser() antlr.Parser { return s.parser }

func (s *AnonAuthContext) ANONYMOUS() antlr.TerminalNode {
	return s.GetToken(ACIParserANONYMOUS, 0)
}

func (s *AnonAuthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnonAuthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnonAuthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAnonAuth(s)
	}
}

func (s *AnonAuthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAnonAuth(s)
	}
}

func (p *ACIParser) AnonAuth() (localctx IAnonAuthContext) {
	localctx = NewAnonAuthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, ACIParserRULE_anonAuth)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(679)
		p.Match(ACIParserANONYMOUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleAuthContext is an interface to support dynamic dispatch.
type ISimpleAuthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SIMPLE() antlr.TerminalNode

	// IsSimpleAuthContext differentiates from other interfaces.
	IsSimpleAuthContext()
}

type SimpleAuthContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleAuthContext() *SimpleAuthContext {
	var p = new(SimpleAuthContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_simpleAuth
	return p
}

func InitEmptySimpleAuthContext(p *SimpleAuthContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_simpleAuth
}

func (*SimpleAuthContext) IsSimpleAuthContext() {}

func NewSimpleAuthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleAuthContext {
	var p = new(SimpleAuthContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_simpleAuth

	return p
}

func (s *SimpleAuthContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleAuthContext) SIMPLE() antlr.TerminalNode {
	return s.GetToken(ACIParserSIMPLE, 0)
}

func (s *SimpleAuthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleAuthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleAuthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSimpleAuth(s)
	}
}

func (s *SimpleAuthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSimpleAuth(s)
	}
}

func (p *ACIParser) SimpleAuth() (localctx ISimpleAuthContext) {
	localctx = NewSimpleAuthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, ACIParserRULE_simpleAuth)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(681)
		p.Match(ACIParserSIMPLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISSLAuthContext is an interface to support dynamic dispatch.
type ISSLAuthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SSL() antlr.TerminalNode

	// IsSSLAuthContext differentiates from other interfaces.
	IsSSLAuthContext()
}

type SSLAuthContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySSLAuthContext() *SSLAuthContext {
	var p = new(SSLAuthContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_sSLAuth
	return p
}

func InitEmptySSLAuthContext(p *SSLAuthContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_sSLAuth
}

func (*SSLAuthContext) IsSSLAuthContext() {}

func NewSSLAuthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SSLAuthContext {
	var p = new(SSLAuthContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_sSLAuth

	return p
}

func (s *SSLAuthContext) GetParser() antlr.Parser { return s.parser }

func (s *SSLAuthContext) SSL() antlr.TerminalNode {
	return s.GetToken(ACIParserSSL, 0)
}

func (s *SSLAuthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SSLAuthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SSLAuthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSSLAuth(s)
	}
}

func (s *SSLAuthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSSLAuth(s)
	}
}

func (p *ACIParser) SSLAuth() (localctx ISSLAuthContext) {
	localctx = NewSSLAuthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, ACIParserRULE_sSLAuth)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(683)
		p.Match(ACIParserSSL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISASLAuthContext is an interface to support dynamic dispatch.
type ISASLAuthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SASL() antlr.TerminalNode

	// IsSASLAuthContext differentiates from other interfaces.
	IsSASLAuthContext()
}

type SASLAuthContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySASLAuthContext() *SASLAuthContext {
	var p = new(SASLAuthContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_sASLAuth
	return p
}

func InitEmptySASLAuthContext(p *SASLAuthContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_sASLAuth
}

func (*SASLAuthContext) IsSASLAuthContext() {}

func NewSASLAuthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SASLAuthContext {
	var p = new(SASLAuthContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_sASLAuth

	return p
}

func (s *SASLAuthContext) GetParser() antlr.Parser { return s.parser }

func (s *SASLAuthContext) SASL() antlr.TerminalNode {
	return s.GetToken(ACIParserSASL, 0)
}

func (s *SASLAuthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SASLAuthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SASLAuthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSASLAuth(s)
	}
}

func (s *SASLAuthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSASLAuth(s)
	}
}

func (p *ACIParser) SASLAuth() (localctx ISASLAuthContext) {
	localctx = NewSASLAuthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, ACIParserRULE_sASLAuth)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(685)
		p.Match(ACIParserSASL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindUserDNContext is an interface to support dynamic dispatch.
type IBindUserDNContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBindUserDNContext differentiates from other interfaces.
	IsBindUserDNContext()
}

type BindUserDNContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindUserDNContext() *BindUserDNContext {
	var p = new(BindUserDNContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindUserDN
	return p
}

func InitEmptyBindUserDNContext(p *BindUserDNContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindUserDN
}

func (*BindUserDNContext) IsBindUserDNContext() {}

func NewBindUserDNContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindUserDNContext {
	var p = new(BindUserDNContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_bindUserDN

	return p
}

func (s *BindUserDNContext) GetParser() antlr.Parser { return s.parser }

func (s *BindUserDNContext) CopyAll(ctx *BindUserDNContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BindUserDNContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindUserDNContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Bind_userdnContext struct {
	BindUserDNContext
}

func NewBind_userdnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Bind_userdnContext {
	var p = new(Bind_userdnContext)

	InitEmptyBindUserDNContext(&p.BindUserDNContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindUserDNContext))

	return p
}

func (s *Bind_userdnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_userdnContext) BIND_USER_DN() antlr.TerminalNode {
	return s.GetToken(ACIParserBIND_USER_DN, 0)
}

func (s *Bind_userdnContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Bind_userdnContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Bind_userdnContext) DistinguishedNames() IDistinguishedNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistinguishedNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistinguishedNamesContext)
}

func (s *Bind_userdnContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Bind_userdnContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Bind_userdnContext) LDAPURI() ILDAPURIContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILDAPURIContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILDAPURIContext)
}

func (s *Bind_userdnContext) WHSP() antlr.TerminalNode {
	return s.GetToken(ACIParserWHSP, 0)
}

func (s *Bind_userdnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterBind_userdn(s)
	}
}

func (s *Bind_userdnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitBind_userdn(s)
	}
}

type Parenthetical_bind_userdnContext struct {
	BindUserDNContext
}

func NewParenthetical_bind_userdnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_bind_userdnContext {
	var p = new(Parenthetical_bind_userdnContext)

	InitEmptyBindUserDNContext(&p.BindUserDNContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindUserDNContext))

	return p
}

func (s *Parenthetical_bind_userdnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_bind_userdnContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Parenthetical_bind_userdnContext) BindUserDN() IBindUserDNContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindUserDNContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindUserDNContext)
}

func (s *Parenthetical_bind_userdnContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Parenthetical_bind_userdnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_bind_userdn(s)
	}
}

func (s *Parenthetical_bind_userdnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_bind_userdn(s)
	}
}

func (p *ACIParser) BindUserDN() (localctx IBindUserDNContext) {
	localctx = NewBindUserDNContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, ACIParserRULE_bindUserDN)
	var _la int

	p.SetState(706)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserLPAREN:
		localctx = NewParenthetical_bind_userdnContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(687)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(688)
			p.BindUserDN()
		}
		{
			p.SetState(689)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserBIND_USER_DN:
		localctx = NewBind_userdnContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(691)
			p.Match(ACIParserBIND_USER_DN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(694)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ACIParserEQ:
			{
				p.SetState(692)
				p.EqualTo()
			}

		case ACIParserNE:
			{
				p.SetState(693)
				p.NotEqualTo()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(697)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ACIParserWHSP {
			{
				p.SetState(696)
				p.Match(ACIParserWHSP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(704)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(699)
				p.DistinguishedNames()
			}

		case 2:
			{
				p.SetState(700)
				p.Match(ACIParserDQUOTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(701)
				p.LDAPURI()
			}
			{
				p.SetState(702)
				p.Match(ACIParserDQUOTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindRoleDNContext is an interface to support dynamic dispatch.
type IBindRoleDNContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBindRoleDNContext differentiates from other interfaces.
	IsBindRoleDNContext()
}

type BindRoleDNContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindRoleDNContext() *BindRoleDNContext {
	var p = new(BindRoleDNContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindRoleDN
	return p
}

func InitEmptyBindRoleDNContext(p *BindRoleDNContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindRoleDN
}

func (*BindRoleDNContext) IsBindRoleDNContext() {}

func NewBindRoleDNContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindRoleDNContext {
	var p = new(BindRoleDNContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_bindRoleDN

	return p
}

func (s *BindRoleDNContext) GetParser() antlr.Parser { return s.parser }

func (s *BindRoleDNContext) CopyAll(ctx *BindRoleDNContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BindRoleDNContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindRoleDNContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Bind_rolednContext struct {
	BindRoleDNContext
}

func NewBind_rolednContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Bind_rolednContext {
	var p = new(Bind_rolednContext)

	InitEmptyBindRoleDNContext(&p.BindRoleDNContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRoleDNContext))

	return p
}

func (s *Bind_rolednContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_rolednContext) BIND_ROLE_DN() antlr.TerminalNode {
	return s.GetToken(ACIParserBIND_ROLE_DN, 0)
}

func (s *Bind_rolednContext) DistinguishedNames() IDistinguishedNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistinguishedNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistinguishedNamesContext)
}

func (s *Bind_rolednContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Bind_rolednContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Bind_rolednContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterBind_roledn(s)
	}
}

func (s *Bind_rolednContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitBind_roledn(s)
	}
}

type Parenthetical_bind_rolednContext struct {
	BindRoleDNContext
}

func NewParenthetical_bind_rolednContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_bind_rolednContext {
	var p = new(Parenthetical_bind_rolednContext)

	InitEmptyBindRoleDNContext(&p.BindRoleDNContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindRoleDNContext))

	return p
}

func (s *Parenthetical_bind_rolednContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_bind_rolednContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Parenthetical_bind_rolednContext) BindRoleDN() IBindRoleDNContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindRoleDNContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindRoleDNContext)
}

func (s *Parenthetical_bind_rolednContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Parenthetical_bind_rolednContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_bind_roledn(s)
	}
}

func (s *Parenthetical_bind_rolednContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_bind_roledn(s)
	}
}

func (p *ACIParser) BindRoleDN() (localctx IBindRoleDNContext) {
	localctx = NewBindRoleDNContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, ACIParserRULE_bindRoleDN)
	p.SetState(719)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserLPAREN:
		localctx = NewParenthetical_bind_rolednContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(708)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(709)
			p.BindRoleDN()
		}
		{
			p.SetState(710)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserBIND_ROLE_DN:
		localctx = NewBind_rolednContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(712)
			p.Match(ACIParserBIND_ROLE_DN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(715)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ACIParserEQ:
			{
				p.SetState(713)
				p.EqualTo()
			}

		case ACIParserNE:
			{
				p.SetState(714)
				p.NotEqualTo()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(717)
			p.DistinguishedNames()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindGroupDNContext is an interface to support dynamic dispatch.
type IBindGroupDNContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBindGroupDNContext differentiates from other interfaces.
	IsBindGroupDNContext()
}

type BindGroupDNContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindGroupDNContext() *BindGroupDNContext {
	var p = new(BindGroupDNContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindGroupDN
	return p
}

func InitEmptyBindGroupDNContext(p *BindGroupDNContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindGroupDN
}

func (*BindGroupDNContext) IsBindGroupDNContext() {}

func NewBindGroupDNContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindGroupDNContext {
	var p = new(BindGroupDNContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_bindGroupDN

	return p
}

func (s *BindGroupDNContext) GetParser() antlr.Parser { return s.parser }

func (s *BindGroupDNContext) CopyAll(ctx *BindGroupDNContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BindGroupDNContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindGroupDNContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Bind_groupdnContext struct {
	BindGroupDNContext
}

func NewBind_groupdnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Bind_groupdnContext {
	var p = new(Bind_groupdnContext)

	InitEmptyBindGroupDNContext(&p.BindGroupDNContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindGroupDNContext))

	return p
}

func (s *Bind_groupdnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_groupdnContext) BIND_GROUP_DN() antlr.TerminalNode {
	return s.GetToken(ACIParserBIND_GROUP_DN, 0)
}

func (s *Bind_groupdnContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Bind_groupdnContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Bind_groupdnContext) DistinguishedNames() IDistinguishedNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistinguishedNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistinguishedNamesContext)
}

func (s *Bind_groupdnContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Bind_groupdnContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Bind_groupdnContext) LDAPURI() ILDAPURIContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILDAPURIContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILDAPURIContext)
}

func (s *Bind_groupdnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterBind_groupdn(s)
	}
}

func (s *Bind_groupdnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitBind_groupdn(s)
	}
}

type Parenthetical_bind_groupdnContext struct {
	BindGroupDNContext
}

func NewParenthetical_bind_groupdnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_bind_groupdnContext {
	var p = new(Parenthetical_bind_groupdnContext)

	InitEmptyBindGroupDNContext(&p.BindGroupDNContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindGroupDNContext))

	return p
}

func (s *Parenthetical_bind_groupdnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_bind_groupdnContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Parenthetical_bind_groupdnContext) BindGroupDN() IBindGroupDNContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindGroupDNContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindGroupDNContext)
}

func (s *Parenthetical_bind_groupdnContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Parenthetical_bind_groupdnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_bind_groupdn(s)
	}
}

func (s *Parenthetical_bind_groupdnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_bind_groupdn(s)
	}
}

func (p *ACIParser) BindGroupDN() (localctx IBindGroupDNContext) {
	localctx = NewBindGroupDNContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, ACIParserRULE_bindGroupDN)
	p.SetState(737)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserLPAREN:
		localctx = NewParenthetical_bind_groupdnContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(721)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(722)
			p.BindGroupDN()
		}
		{
			p.SetState(723)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserBIND_GROUP_DN:
		localctx = NewBind_groupdnContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(725)
			p.Match(ACIParserBIND_GROUP_DN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(728)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ACIParserEQ:
			{
				p.SetState(726)
				p.EqualTo()
			}

		case ACIParserNE:
			{
				p.SetState(727)
				p.NotEqualTo()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(735)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(730)
				p.DistinguishedNames()
			}

		case 2:
			{
				p.SetState(731)
				p.Match(ACIParserDQUOTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(732)
				p.LDAPURI()
			}
			{
				p.SetState(733)
				p.Match(ACIParserDQUOTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindUserAttrContext is an interface to support dynamic dispatch.
type IBindUserAttrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBindUserAttrContext differentiates from other interfaces.
	IsBindUserAttrContext()
}

type BindUserAttrContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindUserAttrContext() *BindUserAttrContext {
	var p = new(BindUserAttrContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindUserAttr
	return p
}

func InitEmptyBindUserAttrContext(p *BindUserAttrContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindUserAttr
}

func (*BindUserAttrContext) IsBindUserAttrContext() {}

func NewBindUserAttrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindUserAttrContext {
	var p = new(BindUserAttrContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_bindUserAttr

	return p
}

func (s *BindUserAttrContext) GetParser() antlr.Parser { return s.parser }

func (s *BindUserAttrContext) CopyAll(ctx *BindUserAttrContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BindUserAttrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindUserAttrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Parenthetical_bind_userattrContext struct {
	BindUserAttrContext
}

func NewParenthetical_bind_userattrContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_bind_userattrContext {
	var p = new(Parenthetical_bind_userattrContext)

	InitEmptyBindUserAttrContext(&p.BindUserAttrContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindUserAttrContext))

	return p
}

func (s *Parenthetical_bind_userattrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_bind_userattrContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Parenthetical_bind_userattrContext) BindUserAttr() IBindUserAttrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindUserAttrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindUserAttrContext)
}

func (s *Parenthetical_bind_userattrContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Parenthetical_bind_userattrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_bind_userattr(s)
	}
}

func (s *Parenthetical_bind_userattrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_bind_userattr(s)
	}
}

type Bind_userattrContext struct {
	BindUserAttrContext
}

func NewBind_userattrContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Bind_userattrContext {
	var p = new(Bind_userattrContext)

	InitEmptyBindUserAttrContext(&p.BindUserAttrContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindUserAttrContext))

	return p
}

func (s *Bind_userattrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_userattrContext) BIND_USER_ATTR() antlr.TerminalNode {
	return s.GetToken(ACIParserBIND_USER_ATTR, 0)
}

func (s *Bind_userattrContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Bind_userattrContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Bind_userattrContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Bind_userattrContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Bind_userattrContext) AttributeBindTypeOrValue() IAttributeBindTypeOrValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeBindTypeOrValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeBindTypeOrValueContext)
}

func (s *Bind_userattrContext) Inheritance() IInheritanceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInheritanceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInheritanceContext)
}

func (s *Bind_userattrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterBind_userattr(s)
	}
}

func (s *Bind_userattrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitBind_userattr(s)
	}
}

func (p *ACIParser) BindUserAttr() (localctx IBindUserAttrContext) {
	localctx = NewBindUserAttrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, ACIParserRULE_bindUserAttr)
	p.SetState(755)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserLPAREN:
		localctx = NewParenthetical_bind_userattrContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(739)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(740)
			p.BindUserAttr()
		}
		{
			p.SetState(741)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserBIND_USER_ATTR:
		localctx = NewBind_userattrContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(743)
			p.Match(ACIParserBIND_USER_ATTR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(746)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ACIParserEQ:
			{
				p.SetState(744)
				p.EqualTo()
			}

		case ACIParserNE:
			{
				p.SetState(745)
				p.NotEqualTo()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(748)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(751)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ACIParserSTAR, ACIParserKEY_OR_VALUE:
			{
				p.SetState(749)
				p.AttributeBindTypeOrValue()
			}

		case ACIParserPARENT:
			{
				p.SetState(750)
				p.Inheritance()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(753)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindGroupAttrContext is an interface to support dynamic dispatch.
type IBindGroupAttrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBindGroupAttrContext differentiates from other interfaces.
	IsBindGroupAttrContext()
}

type BindGroupAttrContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindGroupAttrContext() *BindGroupAttrContext {
	var p = new(BindGroupAttrContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindGroupAttr
	return p
}

func InitEmptyBindGroupAttrContext(p *BindGroupAttrContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindGroupAttr
}

func (*BindGroupAttrContext) IsBindGroupAttrContext() {}

func NewBindGroupAttrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindGroupAttrContext {
	var p = new(BindGroupAttrContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_bindGroupAttr

	return p
}

func (s *BindGroupAttrContext) GetParser() antlr.Parser { return s.parser }

func (s *BindGroupAttrContext) CopyAll(ctx *BindGroupAttrContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BindGroupAttrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindGroupAttrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Parenthetical_bind_groupattrContext struct {
	BindGroupAttrContext
}

func NewParenthetical_bind_groupattrContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_bind_groupattrContext {
	var p = new(Parenthetical_bind_groupattrContext)

	InitEmptyBindGroupAttrContext(&p.BindGroupAttrContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindGroupAttrContext))

	return p
}

func (s *Parenthetical_bind_groupattrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_bind_groupattrContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Parenthetical_bind_groupattrContext) BindGroupAttr() IBindGroupAttrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindGroupAttrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindGroupAttrContext)
}

func (s *Parenthetical_bind_groupattrContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Parenthetical_bind_groupattrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_bind_groupattr(s)
	}
}

func (s *Parenthetical_bind_groupattrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_bind_groupattr(s)
	}
}

type Bind_groupattrContext struct {
	BindGroupAttrContext
}

func NewBind_groupattrContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Bind_groupattrContext {
	var p = new(Bind_groupattrContext)

	InitEmptyBindGroupAttrContext(&p.BindGroupAttrContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindGroupAttrContext))

	return p
}

func (s *Bind_groupattrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_groupattrContext) BIND_GROUP_ATTR() antlr.TerminalNode {
	return s.GetToken(ACIParserBIND_GROUP_ATTR, 0)
}

func (s *Bind_groupattrContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Bind_groupattrContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Bind_groupattrContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Bind_groupattrContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Bind_groupattrContext) AttributeBindTypeOrValue() IAttributeBindTypeOrValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeBindTypeOrValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeBindTypeOrValueContext)
}

func (s *Bind_groupattrContext) Inheritance() IInheritanceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInheritanceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInheritanceContext)
}

func (s *Bind_groupattrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterBind_groupattr(s)
	}
}

func (s *Bind_groupattrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitBind_groupattr(s)
	}
}

func (p *ACIParser) BindGroupAttr() (localctx IBindGroupAttrContext) {
	localctx = NewBindGroupAttrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, ACIParserRULE_bindGroupAttr)
	p.SetState(773)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserLPAREN:
		localctx = NewParenthetical_bind_groupattrContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(757)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(758)
			p.BindGroupAttr()
		}
		{
			p.SetState(759)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserBIND_GROUP_ATTR:
		localctx = NewBind_groupattrContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(761)
			p.Match(ACIParserBIND_GROUP_ATTR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(764)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ACIParserEQ:
			{
				p.SetState(762)
				p.EqualTo()
			}

		case ACIParserNE:
			{
				p.SetState(763)
				p.NotEqualTo()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(766)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(769)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ACIParserSTAR, ACIParserKEY_OR_VALUE:
			{
				p.SetState(767)
				p.AttributeBindTypeOrValue()
			}

		case ACIParserPARENT:
			{
				p.SetState(768)
				p.Inheritance()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(771)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindSecurityStrengthFactorContext is an interface to support dynamic dispatch.
type IBindSecurityStrengthFactorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBindSecurityStrengthFactorContext differentiates from other interfaces.
	IsBindSecurityStrengthFactorContext()
}

type BindSecurityStrengthFactorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindSecurityStrengthFactorContext() *BindSecurityStrengthFactorContext {
	var p = new(BindSecurityStrengthFactorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindSecurityStrengthFactor
	return p
}

func InitEmptyBindSecurityStrengthFactorContext(p *BindSecurityStrengthFactorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindSecurityStrengthFactor
}

func (*BindSecurityStrengthFactorContext) IsBindSecurityStrengthFactorContext() {}

func NewBindSecurityStrengthFactorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindSecurityStrengthFactorContext {
	var p = new(BindSecurityStrengthFactorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_bindSecurityStrengthFactor

	return p
}

func (s *BindSecurityStrengthFactorContext) GetParser() antlr.Parser { return s.parser }

func (s *BindSecurityStrengthFactorContext) CopyAll(ctx *BindSecurityStrengthFactorContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BindSecurityStrengthFactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindSecurityStrengthFactorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Bind_ssfContext struct {
	BindSecurityStrengthFactorContext
}

func NewBind_ssfContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Bind_ssfContext {
	var p = new(Bind_ssfContext)

	InitEmptyBindSecurityStrengthFactorContext(&p.BindSecurityStrengthFactorContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindSecurityStrengthFactorContext))

	return p
}

func (s *Bind_ssfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_ssfContext) BIND_SSF() antlr.TerminalNode {
	return s.GetToken(ACIParserBIND_SSF, 0)
}

func (s *Bind_ssfContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Bind_ssfContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Bind_ssfContext) INT() antlr.TerminalNode {
	return s.GetToken(ACIParserINT, 0)
}

func (s *Bind_ssfContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Bind_ssfContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Bind_ssfContext) GreaterThan() IGreaterThanContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGreaterThanContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGreaterThanContext)
}

func (s *Bind_ssfContext) GreaterThanOrEqual() IGreaterThanOrEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGreaterThanOrEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGreaterThanOrEqualContext)
}

func (s *Bind_ssfContext) LessThan() ILessThanContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILessThanContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILessThanContext)
}

func (s *Bind_ssfContext) LessThanOrEqual() ILessThanOrEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILessThanOrEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILessThanOrEqualContext)
}

func (s *Bind_ssfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterBind_ssf(s)
	}
}

func (s *Bind_ssfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitBind_ssf(s)
	}
}

type Parenthetical_ssfContext struct {
	BindSecurityStrengthFactorContext
}

func NewParenthetical_ssfContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_ssfContext {
	var p = new(Parenthetical_ssfContext)

	InitEmptyBindSecurityStrengthFactorContext(&p.BindSecurityStrengthFactorContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindSecurityStrengthFactorContext))

	return p
}

func (s *Parenthetical_ssfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_ssfContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Parenthetical_ssfContext) BindSecurityStrengthFactor() IBindSecurityStrengthFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindSecurityStrengthFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindSecurityStrengthFactorContext)
}

func (s *Parenthetical_ssfContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Parenthetical_ssfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_ssf(s)
	}
}

func (s *Parenthetical_ssfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_ssf(s)
	}
}

func (p *ACIParser) BindSecurityStrengthFactor() (localctx IBindSecurityStrengthFactorContext) {
	localctx = NewBindSecurityStrengthFactorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, ACIParserRULE_bindSecurityStrengthFactor)
	p.SetState(792)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserLPAREN:
		localctx = NewParenthetical_ssfContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(775)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(776)
			p.BindSecurityStrengthFactor()
		}
		{
			p.SetState(777)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserBIND_SSF:
		localctx = NewBind_ssfContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(779)
			p.Match(ACIParserBIND_SSF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(786)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ACIParserEQ:
			{
				p.SetState(780)
				p.EqualTo()
			}

		case ACIParserNE:
			{
				p.SetState(781)
				p.NotEqualTo()
			}

		case ACIParserGT:
			{
				p.SetState(782)
				p.GreaterThan()
			}

		case ACIParserGE:
			{
				p.SetState(783)
				p.GreaterThanOrEqual()
			}

		case ACIParserLT:
			{
				p.SetState(784)
				p.LessThan()
			}

		case ACIParserLE:
			{
				p.SetState(785)
				p.LessThanOrEqual()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(788)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(789)
			p.Match(ACIParserINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(790)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindTimeOfDayContext is an interface to support dynamic dispatch.
type IBindTimeOfDayContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBindTimeOfDayContext differentiates from other interfaces.
	IsBindTimeOfDayContext()
}

type BindTimeOfDayContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindTimeOfDayContext() *BindTimeOfDayContext {
	var p = new(BindTimeOfDayContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindTimeOfDay
	return p
}

func InitEmptyBindTimeOfDayContext(p *BindTimeOfDayContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindTimeOfDay
}

func (*BindTimeOfDayContext) IsBindTimeOfDayContext() {}

func NewBindTimeOfDayContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindTimeOfDayContext {
	var p = new(BindTimeOfDayContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_bindTimeOfDay

	return p
}

func (s *BindTimeOfDayContext) GetParser() antlr.Parser { return s.parser }

func (s *BindTimeOfDayContext) CopyAll(ctx *BindTimeOfDayContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BindTimeOfDayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindTimeOfDayContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Parenthetical_bind_timeofdayContext struct {
	BindTimeOfDayContext
}

func NewParenthetical_bind_timeofdayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_bind_timeofdayContext {
	var p = new(Parenthetical_bind_timeofdayContext)

	InitEmptyBindTimeOfDayContext(&p.BindTimeOfDayContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindTimeOfDayContext))

	return p
}

func (s *Parenthetical_bind_timeofdayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_bind_timeofdayContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Parenthetical_bind_timeofdayContext) BindTimeOfDay() IBindTimeOfDayContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindTimeOfDayContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindTimeOfDayContext)
}

func (s *Parenthetical_bind_timeofdayContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Parenthetical_bind_timeofdayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_bind_timeofday(s)
	}
}

func (s *Parenthetical_bind_timeofdayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_bind_timeofday(s)
	}
}

type Bind_timeofdayContext struct {
	BindTimeOfDayContext
}

func NewBind_timeofdayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Bind_timeofdayContext {
	var p = new(Bind_timeofdayContext)

	InitEmptyBindTimeOfDayContext(&p.BindTimeOfDayContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindTimeOfDayContext))

	return p
}

func (s *Bind_timeofdayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_timeofdayContext) BIND_TIME_OF_DAY() antlr.TerminalNode {
	return s.GetToken(ACIParserBIND_TIME_OF_DAY, 0)
}

func (s *Bind_timeofdayContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Bind_timeofdayContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Bind_timeofdayContext) INT() antlr.TerminalNode {
	return s.GetToken(ACIParserINT, 0)
}

func (s *Bind_timeofdayContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Bind_timeofdayContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Bind_timeofdayContext) GreaterThan() IGreaterThanContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGreaterThanContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGreaterThanContext)
}

func (s *Bind_timeofdayContext) GreaterThanOrEqual() IGreaterThanOrEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGreaterThanOrEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGreaterThanOrEqualContext)
}

func (s *Bind_timeofdayContext) LessThan() ILessThanContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILessThanContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILessThanContext)
}

func (s *Bind_timeofdayContext) LessThanOrEqual() ILessThanOrEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILessThanOrEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILessThanOrEqualContext)
}

func (s *Bind_timeofdayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterBind_timeofday(s)
	}
}

func (s *Bind_timeofdayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitBind_timeofday(s)
	}
}

func (p *ACIParser) BindTimeOfDay() (localctx IBindTimeOfDayContext) {
	localctx = NewBindTimeOfDayContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, ACIParserRULE_bindTimeOfDay)
	p.SetState(811)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserLPAREN:
		localctx = NewParenthetical_bind_timeofdayContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(794)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(795)
			p.BindTimeOfDay()
		}
		{
			p.SetState(796)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserBIND_TIME_OF_DAY:
		localctx = NewBind_timeofdayContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(798)
			p.Match(ACIParserBIND_TIME_OF_DAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(805)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ACIParserEQ:
			{
				p.SetState(799)
				p.EqualTo()
			}

		case ACIParserNE:
			{
				p.SetState(800)
				p.NotEqualTo()
			}

		case ACIParserGT:
			{
				p.SetState(801)
				p.GreaterThan()
			}

		case ACIParserGE:
			{
				p.SetState(802)
				p.GreaterThanOrEqual()
			}

		case ACIParserLT:
			{
				p.SetState(803)
				p.LessThan()
			}

		case ACIParserLE:
			{
				p.SetState(804)
				p.LessThanOrEqual()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(807)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(808)
			p.Match(ACIParserINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(809)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindIPContext is an interface to support dynamic dispatch.
type IBindIPContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBindIPContext differentiates from other interfaces.
	IsBindIPContext()
}

type BindIPContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindIPContext() *BindIPContext {
	var p = new(BindIPContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindIP
	return p
}

func InitEmptyBindIPContext(p *BindIPContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindIP
}

func (*BindIPContext) IsBindIPContext() {}

func NewBindIPContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindIPContext {
	var p = new(BindIPContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_bindIP

	return p
}

func (s *BindIPContext) GetParser() antlr.Parser { return s.parser }

func (s *BindIPContext) CopyAll(ctx *BindIPContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BindIPContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindIPContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Bind_ipContext struct {
	BindIPContext
}

func NewBind_ipContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Bind_ipContext {
	var p = new(Bind_ipContext)

	InitEmptyBindIPContext(&p.BindIPContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindIPContext))

	return p
}

func (s *Bind_ipContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_ipContext) BIND_IP() antlr.TerminalNode {
	return s.GetToken(ACIParserBIND_IP, 0)
}

func (s *Bind_ipContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Bind_ipContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Bind_ipContext) IPAddresses() IIPAddressesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIPAddressesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIPAddressesContext)
}

func (s *Bind_ipContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Bind_ipContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Bind_ipContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterBind_ip(s)
	}
}

func (s *Bind_ipContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitBind_ip(s)
	}
}

type Parenthetical_bind_ipContext struct {
	BindIPContext
}

func NewParenthetical_bind_ipContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_bind_ipContext {
	var p = new(Parenthetical_bind_ipContext)

	InitEmptyBindIPContext(&p.BindIPContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindIPContext))

	return p
}

func (s *Parenthetical_bind_ipContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_bind_ipContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Parenthetical_bind_ipContext) BindIP() IBindIPContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindIPContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindIPContext)
}

func (s *Parenthetical_bind_ipContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Parenthetical_bind_ipContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_bind_ip(s)
	}
}

func (s *Parenthetical_bind_ipContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_bind_ip(s)
	}
}

func (p *ACIParser) BindIP() (localctx IBindIPContext) {
	localctx = NewBindIPContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, ACIParserRULE_bindIP)
	p.SetState(826)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserLPAREN:
		localctx = NewParenthetical_bind_ipContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(813)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(814)
			p.BindIP()
		}
		{
			p.SetState(815)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserBIND_IP:
		localctx = NewBind_ipContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(817)
			p.Match(ACIParserBIND_IP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(820)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ACIParserEQ:
			{
				p.SetState(818)
				p.EqualTo()
			}

		case ACIParserNE:
			{
				p.SetState(819)
				p.NotEqualTo()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(822)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(823)
			p.IPAddresses()
		}
		{
			p.SetState(824)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindDNSContext is an interface to support dynamic dispatch.
type IBindDNSContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBindDNSContext differentiates from other interfaces.
	IsBindDNSContext()
}

type BindDNSContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindDNSContext() *BindDNSContext {
	var p = new(BindDNSContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindDNS
	return p
}

func InitEmptyBindDNSContext(p *BindDNSContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindDNS
}

func (*BindDNSContext) IsBindDNSContext() {}

func NewBindDNSContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindDNSContext {
	var p = new(BindDNSContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_bindDNS

	return p
}

func (s *BindDNSContext) GetParser() antlr.Parser { return s.parser }

func (s *BindDNSContext) CopyAll(ctx *BindDNSContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BindDNSContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindDNSContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Dns_bind_ruleContext struct {
	BindDNSContext
}

func NewDns_bind_ruleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Dns_bind_ruleContext {
	var p = new(Dns_bind_ruleContext)

	InitEmptyBindDNSContext(&p.BindDNSContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindDNSContext))

	return p
}

func (s *Dns_bind_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dns_bind_ruleContext) BIND_DNS() antlr.TerminalNode {
	return s.GetToken(ACIParserBIND_DNS, 0)
}

func (s *Dns_bind_ruleContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Dns_bind_ruleContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Dns_bind_ruleContext) FQDN() IFQDNContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFQDNContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFQDNContext)
}

func (s *Dns_bind_ruleContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Dns_bind_ruleContext) NotEqualTo() INotEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotEqualToContext)
}

func (s *Dns_bind_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterDns_bind_rule(s)
	}
}

func (s *Dns_bind_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitDns_bind_rule(s)
	}
}

type Parenthetical_bind_dnsContext struct {
	BindDNSContext
}

func NewParenthetical_bind_dnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_bind_dnsContext {
	var p = new(Parenthetical_bind_dnsContext)

	InitEmptyBindDNSContext(&p.BindDNSContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindDNSContext))

	return p
}

func (s *Parenthetical_bind_dnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_bind_dnsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Parenthetical_bind_dnsContext) BindDNS() IBindDNSContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindDNSContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindDNSContext)
}

func (s *Parenthetical_bind_dnsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Parenthetical_bind_dnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_bind_dns(s)
	}
}

func (s *Parenthetical_bind_dnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_bind_dns(s)
	}
}

func (p *ACIParser) BindDNS() (localctx IBindDNSContext) {
	localctx = NewBindDNSContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, ACIParserRULE_bindDNS)
	p.SetState(841)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserLPAREN:
		localctx = NewParenthetical_bind_dnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(828)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(829)
			p.BindDNS()
		}
		{
			p.SetState(830)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserBIND_DNS:
		localctx = NewDns_bind_ruleContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(832)
			p.Match(ACIParserBIND_DNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(835)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ACIParserEQ:
			{
				p.SetState(833)
				p.EqualTo()
			}

		case ACIParserNE:
			{
				p.SetState(834)
				p.NotEqualTo()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(837)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(838)
			p.FQDN()
		}
		{
			p.SetState(839)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIPAddressesContext is an interface to support dynamic dispatch.
type IIPAddressesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIPAddressesContext differentiates from other interfaces.
	IsIPAddressesContext()
}

type IPAddressesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIPAddressesContext() *IPAddressesContext {
	var p = new(IPAddressesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_iPAddresses
	return p
}

func InitEmptyIPAddressesContext(p *IPAddressesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_iPAddresses
}

func (*IPAddressesContext) IsIPAddressesContext() {}

func NewIPAddressesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IPAddressesContext {
	var p = new(IPAddressesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_iPAddresses

	return p
}

func (s *IPAddressesContext) GetParser() antlr.Parser { return s.parser }

func (s *IPAddressesContext) CopyAll(ctx *IPAddressesContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *IPAddressesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IPAddressesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type IpsContext struct {
	IPAddressesContext
}

func NewIpsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IpsContext {
	var p = new(IpsContext)

	InitEmptyIPAddressesContext(&p.IPAddressesContext)
	p.parser = parser
	p.CopyAll(ctx.(*IPAddressesContext))

	return p
}

func (s *IpsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IpsContext) AllIPAddress() []IIPAddressContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIPAddressContext); ok {
			len++
		}
	}

	tst := make([]IIPAddressContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIPAddressContext); ok {
			tst[i] = t.(IIPAddressContext)
			i++
		}
	}

	return tst
}

func (s *IpsContext) IPAddress(i int) IIPAddressContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIPAddressContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIPAddressContext)
}

func (s *IpsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ACIParserCOMMA)
}

func (s *IpsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserCOMMA, i)
}

func (s *IpsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterIps(s)
	}
}

func (s *IpsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitIps(s)
	}
}

func (p *ACIParser) IPAddresses() (localctx IIPAddressesContext) {
	localctx = NewIPAddressesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, ACIParserRULE_iPAddresses)
	var _la int

	var _alt int

	localctx = NewIpsContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(851)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1 + 1
	for ok := true; ok; ok = _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1 + 1:
			{
				p.SetState(843)
				p.IPAddress()
			}
			p.SetState(848)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == ACIParserCOMMA {
				{
					p.SetState(844)
					p.Match(ACIParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(845)
					p.IPAddress()
				}

				p.SetState(850)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(853)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIPAddressContext is an interface to support dynamic dispatch.
type IIPAddressContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIPAddressContext differentiates from other interfaces.
	IsIPAddressContext()
}

type IPAddressContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIPAddressContext() *IPAddressContext {
	var p = new(IPAddressContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_iPAddress
	return p
}

func InitEmptyIPAddressContext(p *IPAddressContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_iPAddress
}

func (*IPAddressContext) IsIPAddressContext() {}

func NewIPAddressContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IPAddressContext {
	var p = new(IPAddressContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_iPAddress

	return p
}

func (s *IPAddressContext) GetParser() antlr.Parser { return s.parser }

func (s *IPAddressContext) CopyAll(ctx *IPAddressContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *IPAddressContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IPAddressContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Ipv6_addressContext struct {
	IPAddressContext
}

func NewIpv6_addressContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Ipv6_addressContext {
	var p = new(Ipv6_addressContext)

	InitEmptyIPAddressContext(&p.IPAddressContext)
	p.parser = parser
	p.CopyAll(ctx.(*IPAddressContext))

	return p
}

func (s *Ipv6_addressContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ipv6_addressContext) IPv6Address() IIPv6AddressContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIPv6AddressContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIPv6AddressContext)
}

func (s *Ipv6_addressContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterIpv6_address(s)
	}
}

func (s *Ipv6_addressContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitIpv6_address(s)
	}
}

type Ipv4_addressContext struct {
	IPAddressContext
}

func NewIpv4_addressContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Ipv4_addressContext {
	var p = new(Ipv4_addressContext)

	InitEmptyIPAddressContext(&p.IPAddressContext)
	p.parser = parser
	p.CopyAll(ctx.(*IPAddressContext))

	return p
}

func (s *Ipv4_addressContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ipv4_addressContext) IPv4Address() IIPv4AddressContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIPv4AddressContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIPv4AddressContext)
}

func (s *Ipv4_addressContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterIpv4_address(s)
	}
}

func (s *Ipv4_addressContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitIpv4_address(s)
	}
}

func (p *ACIParser) IPAddress() (localctx IIPAddressContext) {
	localctx = NewIPAddressContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, ACIParserRULE_iPAddress)
	p.SetState(857)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserINT:
		localctx = NewIpv4_addressContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(855)
			p.IPv4Address()
		}

	case ACIParserSTAR, ACIParserKEY_OR_VALUE:
		localctx = NewIpv6_addressContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(856)
			p.IPv6Address()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIPv4AddressContext is an interface to support dynamic dispatch.
type IIPv4AddressContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIPv4AddressContext differentiates from other interfaces.
	IsIPv4AddressContext()
}

type IPv4AddressContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIPv4AddressContext() *IPv4AddressContext {
	var p = new(IPv4AddressContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_iPv4Address
	return p
}

func InitEmptyIPv4AddressContext(p *IPv4AddressContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_iPv4Address
}

func (*IPv4AddressContext) IsIPv4AddressContext() {}

func NewIPv4AddressContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IPv4AddressContext {
	var p = new(IPv4AddressContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_iPv4Address

	return p
}

func (s *IPv4AddressContext) GetParser() antlr.Parser { return s.parser }

func (s *IPv4AddressContext) CopyAll(ctx *IPv4AddressContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *IPv4AddressContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IPv4AddressContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Ipv4Context struct {
	IPv4AddressContext
}

func NewIpv4Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *Ipv4Context {
	var p = new(Ipv4Context)

	InitEmptyIPv4AddressContext(&p.IPv4AddressContext)
	p.parser = parser
	p.CopyAll(ctx.(*IPv4AddressContext))

	return p
}

func (s *Ipv4Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ipv4Context) AllINT() []antlr.TerminalNode {
	return s.GetTokens(ACIParserINT)
}

func (s *Ipv4Context) INT(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserINT, i)
}

func (s *Ipv4Context) DOT() antlr.TerminalNode {
	return s.GetToken(ACIParserDOT, 0)
}

func (s *Ipv4Context) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(ACIParserSTAR)
}

func (s *Ipv4Context) STAR(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserSTAR, i)
}

func (s *Ipv4Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterIpv4(s)
	}
}

func (s *Ipv4Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitIpv4(s)
	}
}

func (p *ACIParser) IPv4Address() (localctx IIPv4AddressContext) {
	localctx = NewIPv4AddressContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, ACIParserRULE_iPv4Address)
	var _la int

	var _alt int

	localctx = NewIpv4Context(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(859)
		p.Match(ACIParserINT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	{
		p.SetState(860)
		p.Match(ACIParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(864)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(861)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ACIParserSTAR || _la == ACIParserINT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(866)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIPv6AddressContext is an interface to support dynamic dispatch.
type IIPv6AddressContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIPv6AddressContext differentiates from other interfaces.
	IsIPv6AddressContext()
}

type IPv6AddressContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIPv6AddressContext() *IPv6AddressContext {
	var p = new(IPv6AddressContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_iPv6Address
	return p
}

func InitEmptyIPv6AddressContext(p *IPv6AddressContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_iPv6Address
}

func (*IPv6AddressContext) IsIPv6AddressContext() {}

func NewIPv6AddressContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IPv6AddressContext {
	var p = new(IPv6AddressContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_iPv6Address

	return p
}

func (s *IPv6AddressContext) GetParser() antlr.Parser { return s.parser }

func (s *IPv6AddressContext) CopyAll(ctx *IPv6AddressContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *IPv6AddressContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IPv6AddressContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Ipv6Context struct {
	IPv6AddressContext
}

func NewIpv6Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *Ipv6Context {
	var p = new(Ipv6Context)

	InitEmptyIPv6AddressContext(&p.IPv6AddressContext)
	p.parser = parser
	p.CopyAll(ctx.(*IPv6AddressContext))

	return p
}

func (s *Ipv6Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ipv6Context) AllAttributeTypeOrValue() []IAttributeTypeOrValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			len++
		}
	}

	tst := make([]IAttributeTypeOrValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeTypeOrValueContext); ok {
			tst[i] = t.(IAttributeTypeOrValueContext)
			i++
		}
	}

	return tst
}

func (s *Ipv6Context) AttributeTypeOrValue(i int) IAttributeTypeOrValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeTypeOrValueContext)
}

func (s *Ipv6Context) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(ACIParserCOLON)
}

func (s *Ipv6Context) COLON(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserCOLON, i)
}

func (s *Ipv6Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterIpv6(s)
	}
}

func (s *Ipv6Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitIpv6(s)
	}
}

func (p *ACIParser) IPv6Address() (localctx IIPv6AddressContext) {
	localctx = NewIPv6AddressContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, ACIParserRULE_iPv6Address)
	var _la int

	var _alt int

	localctx = NewIpv6Context(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(867)
		p.AttributeTypeOrValue()
	}
	p.SetState(870)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(868)
				p.Match(ACIParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(869)
				p.AttributeTypeOrValue()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(872)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(875)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ACIParserCOLON {
		{
			p.SetState(874)
			p.Match(ACIParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFQDNContext is an interface to support dynamic dispatch.
type IFQDNContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFQDNContext differentiates from other interfaces.
	IsFQDNContext()
}

type FQDNContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFQDNContext() *FQDNContext {
	var p = new(FQDNContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_fQDN
	return p
}

func InitEmptyFQDNContext(p *FQDNContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_fQDN
}

func (*FQDNContext) IsFQDNContext() {}

func NewFQDNContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FQDNContext {
	var p = new(FQDNContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_fQDN

	return p
}

func (s *FQDNContext) GetParser() antlr.Parser { return s.parser }

func (s *FQDNContext) CopyAll(ctx *FQDNContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *FQDNContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FQDNContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type FqdnContext struct {
	FQDNContext
}

func NewFqdnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FqdnContext {
	var p = new(FqdnContext)

	InitEmptyFQDNContext(&p.FQDNContext)
	p.parser = parser
	p.CopyAll(ctx.(*FQDNContext))

	return p
}

func (s *FqdnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FqdnContext) AllAttributeTypeOrValue() []IAttributeTypeOrValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			len++
		}
	}

	tst := make([]IAttributeTypeOrValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeTypeOrValueContext); ok {
			tst[i] = t.(IAttributeTypeOrValueContext)
			i++
		}
	}

	return tst
}

func (s *FqdnContext) AttributeTypeOrValue(i int) IAttributeTypeOrValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeTypeOrValueContext)
}

func (s *FqdnContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDOT)
}

func (s *FqdnContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDOT, i)
}

func (s *FqdnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterFqdn(s)
	}
}

func (s *FqdnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitFqdn(s)
	}
}

func (p *ACIParser) FQDN() (localctx IFQDNContext) {
	localctx = NewFQDNContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, ACIParserRULE_fQDN)
	var _la int

	localctx = NewFqdnContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(877)
		p.AttributeTypeOrValue()
	}
	p.SetState(880)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ACIParserDOT {
		{
			p.SetState(878)
			p.Match(ACIParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(879)
			p.AttributeTypeOrValue()
		}

		p.SetState(882)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILDAPURIContext is an interface to support dynamic dispatch.
type ILDAPURIContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLDAPURIContext differentiates from other interfaces.
	IsLDAPURIContext()
}

type LDAPURIContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLDAPURIContext() *LDAPURIContext {
	var p = new(LDAPURIContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_lDAPURI
	return p
}

func InitEmptyLDAPURIContext(p *LDAPURIContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_lDAPURI
}

func (*LDAPURIContext) IsLDAPURIContext() {}

func NewLDAPURIContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LDAPURIContext {
	var p = new(LDAPURIContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_lDAPURI

	return p
}

func (s *LDAPURIContext) GetParser() antlr.Parser { return s.parser }

func (s *LDAPURIContext) CopyAll(ctx *LDAPURIContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LDAPURIContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LDAPURIContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Fully_qualified_ldapuriContext struct {
	LDAPURIContext
}

func NewFully_qualified_ldapuriContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Fully_qualified_ldapuriContext {
	var p = new(Fully_qualified_ldapuriContext)

	InitEmptyLDAPURIContext(&p.LDAPURIContext)
	p.parser = parser
	p.CopyAll(ctx.(*LDAPURIContext))

	return p
}

func (s *Fully_qualified_ldapuriContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fully_qualified_ldapuriContext) DistinguishedName() IDistinguishedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistinguishedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistinguishedNameContext)
}

func (s *Fully_qualified_ldapuriContext) URIAttributeList() IURIAttributeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IURIAttributeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IURIAttributeListContext)
}

func (s *Fully_qualified_ldapuriContext) URISearchScopes() IURISearchScopesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IURISearchScopesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IURISearchScopesContext)
}

func (s *Fully_qualified_ldapuriContext) URISearchFilter() IURISearchFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IURISearchFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IURISearchFilterContext)
}

func (s *Fully_qualified_ldapuriContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterFully_qualified_ldapuri(s)
	}
}

func (s *Fully_qualified_ldapuriContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitFully_qualified_ldapuri(s)
	}
}

type Fully_qualified_ldapuri_attr_bindtype_or_valueContext struct {
	LDAPURIContext
}

func NewFully_qualified_ldapuri_attr_bindtype_or_valueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Fully_qualified_ldapuri_attr_bindtype_or_valueContext {
	var p = new(Fully_qualified_ldapuri_attr_bindtype_or_valueContext)

	InitEmptyLDAPURIContext(&p.LDAPURIContext)
	p.parser = parser
	p.CopyAll(ctx.(*LDAPURIContext))

	return p
}

func (s *Fully_qualified_ldapuri_attr_bindtype_or_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fully_qualified_ldapuri_attr_bindtype_or_valueContext) DistinguishedName() IDistinguishedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistinguishedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistinguishedNameContext)
}

func (s *Fully_qualified_ldapuri_attr_bindtype_or_valueContext) QMARK() antlr.TerminalNode {
	return s.GetToken(ACIParserQMARK, 0)
}

func (s *Fully_qualified_ldapuri_attr_bindtype_or_valueContext) AttributeBindTypeOrValue() IAttributeBindTypeOrValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeBindTypeOrValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeBindTypeOrValueContext)
}

func (s *Fully_qualified_ldapuri_attr_bindtype_or_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterFully_qualified_ldapuri_attr_bindtype_or_value(s)
	}
}

func (s *Fully_qualified_ldapuri_attr_bindtype_or_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitFully_qualified_ldapuri_attr_bindtype_or_value(s)
	}
}

func (p *ACIParser) LDAPURI() (localctx ILDAPURIContext) {
	localctx = NewLDAPURIContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, ACIParserRULE_lDAPURI)
	p.SetState(893)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		localctx = NewFully_qualified_ldapuriContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(884)
			p.DistinguishedName()
		}
		{
			p.SetState(885)
			p.URIAttributeList()
		}
		{
			p.SetState(886)
			p.URISearchScopes()
		}
		{
			p.SetState(887)
			p.URISearchFilter()
		}

	case 2:
		localctx = NewFully_qualified_ldapuri_attr_bindtype_or_valueContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(889)
			p.DistinguishedName()
		}
		{
			p.SetState(890)
			p.Match(ACIParserQMARK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(891)
			p.AttributeBindTypeOrValue()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IURISearchFilterContext is an interface to support dynamic dispatch.
type IURISearchFilterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsURISearchFilterContext differentiates from other interfaces.
	IsURISearchFilterContext()
}

type URISearchFilterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyURISearchFilterContext() *URISearchFilterContext {
	var p = new(URISearchFilterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_uRISearchFilter
	return p
}

func InitEmptyURISearchFilterContext(p *URISearchFilterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_uRISearchFilter
}

func (*URISearchFilterContext) IsURISearchFilterContext() {}

func NewURISearchFilterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *URISearchFilterContext {
	var p = new(URISearchFilterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_uRISearchFilter

	return p
}

func (s *URISearchFilterContext) GetParser() antlr.Parser { return s.parser }

func (s *URISearchFilterContext) CopyAll(ctx *URISearchFilterContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *URISearchFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *URISearchFilterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UriSearchFilterContext struct {
	URISearchFilterContext
}

func NewUriSearchFilterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UriSearchFilterContext {
	var p = new(UriSearchFilterContext)

	InitEmptyURISearchFilterContext(&p.URISearchFilterContext)
	p.parser = parser
	p.CopyAll(ctx.(*URISearchFilterContext))

	return p
}

func (s *UriSearchFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UriSearchFilterContext) QMARK() antlr.TerminalNode {
	return s.GetToken(ACIParserQMARK, 0)
}

func (s *UriSearchFilterContext) LDAPFilter() ILDAPFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILDAPFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILDAPFilterContext)
}

func (s *UriSearchFilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterUriSearchFilter(s)
	}
}

func (s *UriSearchFilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitUriSearchFilter(s)
	}
}

func (p *ACIParser) URISearchFilter() (localctx IURISearchFilterContext) {
	localctx = NewURISearchFilterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, ACIParserRULE_uRISearchFilter)
	localctx = NewUriSearchFilterContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(895)
		p.Match(ACIParserQMARK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(896)
		p.LDAPFilter()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IURISearchScopesContext is an interface to support dynamic dispatch.
type IURISearchScopesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsURISearchScopesContext differentiates from other interfaces.
	IsURISearchScopesContext()
}

type URISearchScopesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyURISearchScopesContext() *URISearchScopesContext {
	var p = new(URISearchScopesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_uRISearchScopes
	return p
}

func InitEmptyURISearchScopesContext(p *URISearchScopesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_uRISearchScopes
}

func (*URISearchScopesContext) IsURISearchScopesContext() {}

func NewURISearchScopesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *URISearchScopesContext {
	var p = new(URISearchScopesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_uRISearchScopes

	return p
}

func (s *URISearchScopesContext) GetParser() antlr.Parser { return s.parser }

func (s *URISearchScopesContext) CopyAll(ctx *URISearchScopesContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *URISearchScopesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *URISearchScopesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UriSearchScopesContext struct {
	URISearchScopesContext
}

func NewUriSearchScopesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UriSearchScopesContext {
	var p = new(UriSearchScopesContext)

	InitEmptyURISearchScopesContext(&p.URISearchScopesContext)
	p.parser = parser
	p.CopyAll(ctx.(*URISearchScopesContext))

	return p
}

func (s *UriSearchScopesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UriSearchScopesContext) QMARK() antlr.TerminalNode {
	return s.GetToken(ACIParserQMARK, 0)
}

func (s *UriSearchScopesContext) BASE_OBJECT_SCOPE() antlr.TerminalNode {
	return s.GetToken(ACIParserBASE_OBJECT_SCOPE, 0)
}

func (s *UriSearchScopesContext) ONE_LEVEL_SCOPE() antlr.TerminalNode {
	return s.GetToken(ACIParserONE_LEVEL_SCOPE, 0)
}

func (s *UriSearchScopesContext) SUB_TREE_SCOPE() antlr.TerminalNode {
	return s.GetToken(ACIParserSUB_TREE_SCOPE, 0)
}

func (s *UriSearchScopesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterUriSearchScopes(s)
	}
}

func (s *UriSearchScopesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitUriSearchScopes(s)
	}
}

func (p *ACIParser) URISearchScopes() (localctx IURISearchScopesContext) {
	localctx = NewURISearchScopesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, ACIParserRULE_uRISearchScopes)
	var _la int

	localctx = NewUriSearchScopesContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(898)
		p.Match(ACIParserQMARK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(900)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&11) != 0 {
		{
			p.SetState(899)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&11) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IURIAttributeListContext is an interface to support dynamic dispatch.
type IURIAttributeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsURIAttributeListContext differentiates from other interfaces.
	IsURIAttributeListContext()
}

type URIAttributeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyURIAttributeListContext() *URIAttributeListContext {
	var p = new(URIAttributeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_uRIAttributeList
	return p
}

func InitEmptyURIAttributeListContext(p *URIAttributeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_uRIAttributeList
}

func (*URIAttributeListContext) IsURIAttributeListContext() {}

func NewURIAttributeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *URIAttributeListContext {
	var p = new(URIAttributeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_uRIAttributeList

	return p
}

func (s *URIAttributeListContext) GetParser() antlr.Parser { return s.parser }

func (s *URIAttributeListContext) CopyAll(ctx *URIAttributeListContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *URIAttributeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *URIAttributeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UriAttributeListContext struct {
	URIAttributeListContext
}

func NewUriAttributeListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UriAttributeListContext {
	var p = new(UriAttributeListContext)

	InitEmptyURIAttributeListContext(&p.URIAttributeListContext)
	p.parser = parser
	p.CopyAll(ctx.(*URIAttributeListContext))

	return p
}

func (s *UriAttributeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UriAttributeListContext) QMARK() antlr.TerminalNode {
	return s.GetToken(ACIParserQMARK, 0)
}

func (s *UriAttributeListContext) AllAttributeTypeOrValue() []IAttributeTypeOrValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			len++
		}
	}

	tst := make([]IAttributeTypeOrValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeTypeOrValueContext); ok {
			tst[i] = t.(IAttributeTypeOrValueContext)
			i++
		}
	}

	return tst
}

func (s *UriAttributeListContext) AttributeTypeOrValue(i int) IAttributeTypeOrValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeTypeOrValueContext)
}

func (s *UriAttributeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ACIParserCOMMA)
}

func (s *UriAttributeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserCOMMA, i)
}

func (s *UriAttributeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterUriAttributeList(s)
	}
}

func (s *UriAttributeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitUriAttributeList(s)
	}
}

func (p *ACIParser) URIAttributeList() (localctx IURIAttributeListContext) {
	localctx = NewURIAttributeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, ACIParserRULE_uRIAttributeList)
	var _la int

	localctx = NewUriAttributeListContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(902)
		p.Match(ACIParserQMARK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(911)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ACIParserSTAR || _la == ACIParserKEY_OR_VALUE {
		{
			p.SetState(903)
			p.AttributeTypeOrValue()
		}
		p.SetState(908)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ACIParserCOMMA {
			{
				p.SetState(904)
				p.Match(ACIParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(905)
				p.AttributeTypeOrValue()
			}

			p.SetState(910)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDistinguishedNamesContext is an interface to support dynamic dispatch.
type IDistinguishedNamesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDistinguishedNamesContext differentiates from other interfaces.
	IsDistinguishedNamesContext()
}

type DistinguishedNamesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistinguishedNamesContext() *DistinguishedNamesContext {
	var p = new(DistinguishedNamesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_distinguishedNames
	return p
}

func InitEmptyDistinguishedNamesContext(p *DistinguishedNamesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_distinguishedNames
}

func (*DistinguishedNamesContext) IsDistinguishedNamesContext() {}

func NewDistinguishedNamesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DistinguishedNamesContext {
	var p = new(DistinguishedNamesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_distinguishedNames

	return p
}

func (s *DistinguishedNamesContext) GetParser() antlr.Parser { return s.parser }

func (s *DistinguishedNamesContext) CopyAll(ctx *DistinguishedNamesContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *DistinguishedNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistinguishedNamesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type List_of_quoted_distinguished_namesContext struct {
	DistinguishedNamesContext
}

func NewList_of_quoted_distinguished_namesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *List_of_quoted_distinguished_namesContext {
	var p = new(List_of_quoted_distinguished_namesContext)

	InitEmptyDistinguishedNamesContext(&p.DistinguishedNamesContext)
	p.parser = parser
	p.CopyAll(ctx.(*DistinguishedNamesContext))

	return p
}

func (s *List_of_quoted_distinguished_namesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_quoted_distinguished_namesContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *List_of_quoted_distinguished_namesContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *List_of_quoted_distinguished_namesContext) AllDistinguishedName() []IDistinguishedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDistinguishedNameContext); ok {
			len++
		}
	}

	tst := make([]IDistinguishedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDistinguishedNameContext); ok {
			tst[i] = t.(IDistinguishedNameContext)
			i++
		}
	}

	return tst
}

func (s *List_of_quoted_distinguished_namesContext) DistinguishedName(i int) IDistinguishedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistinguishedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistinguishedNameContext)
}

func (s *List_of_quoted_distinguished_namesContext) AllORDelimiter() []IORDelimiterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IORDelimiterContext); ok {
			len++
		}
	}

	tst := make([]IORDelimiterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IORDelimiterContext); ok {
			tst[i] = t.(IORDelimiterContext)
			i++
		}
	}

	return tst
}

func (s *List_of_quoted_distinguished_namesContext) ORDelimiter(i int) IORDelimiterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IORDelimiterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IORDelimiterContext)
}

func (s *List_of_quoted_distinguished_namesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterList_of_quoted_distinguished_names(s)
	}
}

func (s *List_of_quoted_distinguished_namesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitList_of_quoted_distinguished_names(s)
	}
}

type Quoted_distinguished_name_listContext struct {
	DistinguishedNamesContext
}

func NewQuoted_distinguished_name_listContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Quoted_distinguished_name_listContext {
	var p = new(Quoted_distinguished_name_listContext)

	InitEmptyDistinguishedNamesContext(&p.DistinguishedNamesContext)
	p.parser = parser
	p.CopyAll(ctx.(*DistinguishedNamesContext))

	return p
}

func (s *Quoted_distinguished_name_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Quoted_distinguished_name_listContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ACIParserDQUOTE)
}

func (s *Quoted_distinguished_name_listContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserDQUOTE, i)
}

func (s *Quoted_distinguished_name_listContext) AllDistinguishedName() []IDistinguishedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDistinguishedNameContext); ok {
			len++
		}
	}

	tst := make([]IDistinguishedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDistinguishedNameContext); ok {
			tst[i] = t.(IDistinguishedNameContext)
			i++
		}
	}

	return tst
}

func (s *Quoted_distinguished_name_listContext) DistinguishedName(i int) IDistinguishedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistinguishedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistinguishedNameContext)
}

func (s *Quoted_distinguished_name_listContext) AllORDelimiter() []IORDelimiterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IORDelimiterContext); ok {
			len++
		}
	}

	tst := make([]IORDelimiterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IORDelimiterContext); ok {
			tst[i] = t.(IORDelimiterContext)
			i++
		}
	}

	return tst
}

func (s *Quoted_distinguished_name_listContext) ORDelimiter(i int) IORDelimiterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IORDelimiterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IORDelimiterContext)
}

func (s *Quoted_distinguished_name_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterQuoted_distinguished_name_list(s)
	}
}

func (s *Quoted_distinguished_name_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitQuoted_distinguished_name_list(s)
	}
}

func (p *ACIParser) DistinguishedNames() (localctx IDistinguishedNamesContext) {
	localctx = NewDistinguishedNamesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, ACIParserRULE_distinguishedNames)
	var _la int

	p.SetState(938)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext()) {
	case 1:
		localctx = NewQuoted_distinguished_name_listContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(913)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(914)
			p.DistinguishedName()
		}
		p.SetState(920)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ACIParserSYMBOLIC_OR {
			{
				p.SetState(915)
				p.ORDelimiter()
			}
			{
				p.SetState(916)
				p.DistinguishedName()
			}

			p.SetState(922)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

		{
			p.SetState(923)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewList_of_quoted_distinguished_namesContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(925)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(926)
			p.DistinguishedName()
		}
		{
			p.SetState(927)
			p.Match(ACIParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(935)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ACIParserSYMBOLIC_OR {
			{
				p.SetState(928)
				p.ORDelimiter()
			}

			{
				p.SetState(929)
				p.Match(ACIParserDQUOTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(930)
				p.DistinguishedName()
			}
			{
				p.SetState(931)
				p.Match(ACIParserDQUOTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(937)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDistinguishedNameContext is an interface to support dynamic dispatch.
type IDistinguishedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDistinguishedNameContext differentiates from other interfaces.
	IsDistinguishedNameContext()
}

type DistinguishedNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistinguishedNameContext() *DistinguishedNameContext {
	var p = new(DistinguishedNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_distinguishedName
	return p
}

func InitEmptyDistinguishedNameContext(p *DistinguishedNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_distinguishedName
}

func (*DistinguishedNameContext) IsDistinguishedNameContext() {}

func NewDistinguishedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DistinguishedNameContext {
	var p = new(DistinguishedNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_distinguishedName

	return p
}

func (s *DistinguishedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DistinguishedNameContext) CopyAll(ctx *DistinguishedNameContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *DistinguishedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistinguishedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Self_dn_aliasContext struct {
	DistinguishedNameContext
}

func NewSelf_dn_aliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Self_dn_aliasContext {
	var p = new(Self_dn_aliasContext)

	InitEmptyDistinguishedNameContext(&p.DistinguishedNameContext)
	p.parser = parser
	p.CopyAll(ctx.(*DistinguishedNameContext))

	return p
}

func (s *Self_dn_aliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Self_dn_aliasContext) LOCAL_LDAP_SCHEME() antlr.TerminalNode {
	return s.GetToken(ACIParserLOCAL_LDAP_SCHEME, 0)
}

func (s *Self_dn_aliasContext) SELF() antlr.TerminalNode {
	return s.GetToken(ACIParserSELF, 0)
}

func (s *Self_dn_aliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSelf_dn_alias(s)
	}
}

func (s *Self_dn_aliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSelf_dn_alias(s)
	}
}

type Parent_dn_aliasContext struct {
	DistinguishedNameContext
}

func NewParent_dn_aliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parent_dn_aliasContext {
	var p = new(Parent_dn_aliasContext)

	InitEmptyDistinguishedNameContext(&p.DistinguishedNameContext)
	p.parser = parser
	p.CopyAll(ctx.(*DistinguishedNameContext))

	return p
}

func (s *Parent_dn_aliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parent_dn_aliasContext) LOCAL_LDAP_SCHEME() antlr.TerminalNode {
	return s.GetToken(ACIParserLOCAL_LDAP_SCHEME, 0)
}

func (s *Parent_dn_aliasContext) PARENT() antlr.TerminalNode {
	return s.GetToken(ACIParserPARENT, 0)
}

func (s *Parent_dn_aliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParent_dn_alias(s)
	}
}

func (s *Parent_dn_aliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParent_dn_alias(s)
	}
}

type Any_user_dn_aliasContext struct {
	DistinguishedNameContext
}

func NewAny_user_dn_aliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Any_user_dn_aliasContext {
	var p = new(Any_user_dn_aliasContext)

	InitEmptyDistinguishedNameContext(&p.DistinguishedNameContext)
	p.parser = parser
	p.CopyAll(ctx.(*DistinguishedNameContext))

	return p
}

func (s *Any_user_dn_aliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Any_user_dn_aliasContext) LOCAL_LDAP_SCHEME() antlr.TerminalNode {
	return s.GetToken(ACIParserLOCAL_LDAP_SCHEME, 0)
}

func (s *Any_user_dn_aliasContext) ALL_USERS() antlr.TerminalNode {
	return s.GetToken(ACIParserALL_USERS, 0)
}

func (s *Any_user_dn_aliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAny_user_dn_alias(s)
	}
}

func (s *Any_user_dn_aliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAny_user_dn_alias(s)
	}
}

type DnContext struct {
	DistinguishedNameContext
}

func NewDnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DnContext {
	var p = new(DnContext)

	InitEmptyDistinguishedNameContext(&p.DistinguishedNameContext)
	p.parser = parser
	p.CopyAll(ctx.(*DistinguishedNameContext))

	return p
}

func (s *DnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DnContext) LOCAL_LDAP_SCHEME() antlr.TerminalNode {
	return s.GetToken(ACIParserLOCAL_LDAP_SCHEME, 0)
}

func (s *DnContext) AllAVAOrRDN() []IAVAOrRDNContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAVAOrRDNContext); ok {
			len++
		}
	}

	tst := make([]IAVAOrRDNContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAVAOrRDNContext); ok {
			tst[i] = t.(IAVAOrRDNContext)
			i++
		}
	}

	return tst
}

func (s *DnContext) AVAOrRDN(i int) IAVAOrRDNContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAVAOrRDNContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAVAOrRDNContext)
}

func (s *DnContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ACIParserCOMMA)
}

func (s *DnContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserCOMMA, i)
}

func (s *DnContext) AllRDNMacros() []IRDNMacrosContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRDNMacrosContext); ok {
			len++
		}
	}

	tst := make([]IRDNMacrosContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRDNMacrosContext); ok {
			tst[i] = t.(IRDNMacrosContext)
			i++
		}
	}

	return tst
}

func (s *DnContext) RDNMacros(i int) IRDNMacrosContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRDNMacrosContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRDNMacrosContext)
}

func (s *DnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterDn(s)
	}
}

func (s *DnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitDn(s)
	}
}

type Anonymous_dn_aliasContext struct {
	DistinguishedNameContext
}

func NewAnonymous_dn_aliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Anonymous_dn_aliasContext {
	var p = new(Anonymous_dn_aliasContext)

	InitEmptyDistinguishedNameContext(&p.DistinguishedNameContext)
	p.parser = parser
	p.CopyAll(ctx.(*DistinguishedNameContext))

	return p
}

func (s *Anonymous_dn_aliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Anonymous_dn_aliasContext) LOCAL_LDAP_SCHEME() antlr.TerminalNode {
	return s.GetToken(ACIParserLOCAL_LDAP_SCHEME, 0)
}

func (s *Anonymous_dn_aliasContext) ANYONE() antlr.TerminalNode {
	return s.GetToken(ACIParserANYONE, 0)
}

func (s *Anonymous_dn_aliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAnonymous_dn_alias(s)
	}
}

func (s *Anonymous_dn_aliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAnonymous_dn_alias(s)
	}
}

func (p *ACIParser) DistinguishedName() (localctx IDistinguishedNameContext) {
	localctx = NewDistinguishedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, ACIParserRULE_distinguishedName)
	var _la int

	p.SetState(960)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDnContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(940)
			p.Match(ACIParserLOCAL_LDAP_SCHEME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(941)
			p.AVAOrRDN()
		}
		p.SetState(949)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ACIParserCOMMA {
			{
				p.SetState(942)
				p.Match(ACIParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(945)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case ACIParserLPAREN, ACIParserSTAR, ACIParserKEY_OR_VALUE:
				{
					p.SetState(943)
					p.AVAOrRDN()
				}

			case ACIParserRDN_MACROS:
				{
					p.SetState(944)
					p.RDNMacros()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(951)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewAnonymous_dn_aliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(952)
			p.Match(ACIParserLOCAL_LDAP_SCHEME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(953)
			p.Match(ACIParserANYONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewAny_user_dn_aliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(954)
			p.Match(ACIParserLOCAL_LDAP_SCHEME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(955)
			p.Match(ACIParserALL_USERS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewSelf_dn_aliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(956)
			p.Match(ACIParserLOCAL_LDAP_SCHEME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(957)
			p.Match(ACIParserSELF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewParent_dn_aliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(958)
			p.Match(ACIParserLOCAL_LDAP_SCHEME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(959)
			p.Match(ACIParserPARENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRDNMacrosContext is an interface to support dynamic dispatch.
type IRDNMacrosContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRDNMacrosContext differentiates from other interfaces.
	IsRDNMacrosContext()
}

type RDNMacrosContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRDNMacrosContext() *RDNMacrosContext {
	var p = new(RDNMacrosContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_rDNMacros
	return p
}

func InitEmptyRDNMacrosContext(p *RDNMacrosContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_rDNMacros
}

func (*RDNMacrosContext) IsRDNMacrosContext() {}

func NewRDNMacrosContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RDNMacrosContext {
	var p = new(RDNMacrosContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_rDNMacros

	return p
}

func (s *RDNMacrosContext) GetParser() antlr.Parser { return s.parser }

func (s *RDNMacrosContext) CopyAll(ctx *RDNMacrosContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RDNMacrosContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RDNMacrosContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Rdn_macroContext struct {
	RDNMacrosContext
}

func NewRdn_macroContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Rdn_macroContext {
	var p = new(Rdn_macroContext)

	InitEmptyRDNMacrosContext(&p.RDNMacrosContext)
	p.parser = parser
	p.CopyAll(ctx.(*RDNMacrosContext))

	return p
}

func (s *Rdn_macroContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rdn_macroContext) RDN_MACROS() antlr.TerminalNode {
	return s.GetToken(ACIParserRDN_MACROS, 0)
}

func (s *Rdn_macroContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterRdn_macro(s)
	}
}

func (s *Rdn_macroContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitRdn_macro(s)
	}
}

func (p *ACIParser) RDNMacros() (localctx IRDNMacrosContext) {
	localctx = NewRDNMacrosContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, ACIParserRULE_rDNMacros)
	localctx = NewRdn_macroContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(962)
		p.Match(ACIParserRDN_MACROS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILDAPFilterContext is an interface to support dynamic dispatch.
type ILDAPFilterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLDAPFilterContext differentiates from other interfaces.
	IsLDAPFilterContext()
}

type LDAPFilterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLDAPFilterContext() *LDAPFilterContext {
	var p = new(LDAPFilterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_lDAPFilter
	return p
}

func InitEmptyLDAPFilterContext(p *LDAPFilterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_lDAPFilter
}

func (*LDAPFilterContext) IsLDAPFilterContext() {}

func NewLDAPFilterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LDAPFilterContext {
	var p = new(LDAPFilterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_lDAPFilter

	return p
}

func (s *LDAPFilterContext) GetParser() antlr.Parser { return s.parser }

func (s *LDAPFilterContext) CopyAll(ctx *LDAPFilterContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LDAPFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LDAPFilterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Parenthetical_filterContext struct {
	LDAPFilterContext
}

func NewParenthetical_filterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_filterContext {
	var p = new(Parenthetical_filterContext)

	InitEmptyLDAPFilterContext(&p.LDAPFilterContext)
	p.parser = parser
	p.CopyAll(ctx.(*LDAPFilterContext))

	return p
}

func (s *Parenthetical_filterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_filterContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Parenthetical_filterContext) LDAPFilterExpr() ILDAPFilterExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILDAPFilterExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILDAPFilterExprContext)
}

func (s *Parenthetical_filterContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Parenthetical_filterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_filter(s)
	}
}

func (s *Parenthetical_filterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_filter(s)
	}
}

type FilterContext struct {
	LDAPFilterContext
}

func NewFilterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FilterContext {
	var p = new(FilterContext)

	InitEmptyLDAPFilterContext(&p.LDAPFilterContext)
	p.parser = parser
	p.CopyAll(ctx.(*LDAPFilterContext))

	return p
}

func (s *FilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterContext) AllLDAPFilterExpr() []ILDAPFilterExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILDAPFilterExprContext); ok {
			len++
		}
	}

	tst := make([]ILDAPFilterExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILDAPFilterExprContext); ok {
			tst[i] = t.(ILDAPFilterExprContext)
			i++
		}
	}

	return tst
}

func (s *FilterContext) LDAPFilterExpr(i int) ILDAPFilterExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILDAPFilterExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILDAPFilterExprContext)
}

func (s *FilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterFilter(s)
	}
}

func (s *FilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitFilter(s)
	}
}

func (p *ACIParser) LDAPFilter() (localctx ILDAPFilterContext) {
	localctx = NewLDAPFilterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, ACIParserRULE_lDAPFilter)
	var _la int

	p.SetState(974)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext()) {
	case 1:
		localctx = NewParenthetical_filterContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(964)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(965)
			p.LDAPFilterExpr()
		}
		{
			p.SetState(966)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewFilterContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(971)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1140850720) != 0) || _la == ACIParserKEY_OR_VALUE {
			{
				p.SetState(968)
				p.LDAPFilterExpr()
			}

			p.SetState(973)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILDAPFilterExprContext is an interface to support dynamic dispatch.
type ILDAPFilterExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLDAPFilterExprContext differentiates from other interfaces.
	IsLDAPFilterExprContext()
}

type LDAPFilterExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLDAPFilterExprContext() *LDAPFilterExprContext {
	var p = new(LDAPFilterExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_lDAPFilterExpr
	return p
}

func InitEmptyLDAPFilterExprContext(p *LDAPFilterExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_lDAPFilterExpr
}

func (*LDAPFilterExprContext) IsLDAPFilterExprContext() {}

func NewLDAPFilterExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LDAPFilterExprContext {
	var p = new(LDAPFilterExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_lDAPFilterExpr

	return p
}

func (s *LDAPFilterExprContext) GetParser() antlr.Parser { return s.parser }

func (s *LDAPFilterExprContext) CopyAll(ctx *LDAPFilterExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LDAPFilterExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LDAPFilterExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Not_filter_expressionContext struct {
	LDAPFilterExprContext
}

func NewNot_filter_expressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Not_filter_expressionContext {
	var p = new(Not_filter_expressionContext)

	InitEmptyLDAPFilterExprContext(&p.LDAPFilterExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*LDAPFilterExprContext))

	return p
}

func (s *Not_filter_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Not_filter_expressionContext) FILTER_NOT() antlr.TerminalNode {
	return s.GetToken(ACIParserFILTER_NOT, 0)
}

func (s *Not_filter_expressionContext) LDAPFilterExpr() ILDAPFilterExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILDAPFilterExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILDAPFilterExprContext)
}

func (s *Not_filter_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterNot_filter_expression(s)
	}
}

func (s *Not_filter_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitNot_filter_expression(s)
	}
}

type Ava_expressionContext struct {
	LDAPFilterExprContext
}

func NewAva_expressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Ava_expressionContext {
	var p = new(Ava_expressionContext)

	InitEmptyLDAPFilterExprContext(&p.LDAPFilterExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*LDAPFilterExprContext))

	return p
}

func (s *Ava_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ava_expressionContext) AVAOrRDN() IAVAOrRDNContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAVAOrRDNContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAVAOrRDNContext)
}

func (s *Ava_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAva_expression(s)
	}
}

func (s *Ava_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAva_expression(s)
	}
}

type Parenthetical_filter_expression_opt_boolContext struct {
	LDAPFilterExprContext
}

func NewParenthetical_filter_expression_opt_boolContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_filter_expression_opt_boolContext {
	var p = new(Parenthetical_filter_expression_opt_boolContext)

	InitEmptyLDAPFilterExprContext(&p.LDAPFilterExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*LDAPFilterExprContext))

	return p
}

func (s *Parenthetical_filter_expression_opt_boolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_filter_expression_opt_boolContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(ACIParserLPAREN)
}

func (s *Parenthetical_filter_expression_opt_boolContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, i)
}

func (s *Parenthetical_filter_expression_opt_boolContext) AllLDAPFilterExpr() []ILDAPFilterExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILDAPFilterExprContext); ok {
			len++
		}
	}

	tst := make([]ILDAPFilterExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILDAPFilterExprContext); ok {
			tst[i] = t.(ILDAPFilterExprContext)
			i++
		}
	}

	return tst
}

func (s *Parenthetical_filter_expression_opt_boolContext) LDAPFilterExpr(i int) ILDAPFilterExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILDAPFilterExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILDAPFilterExprContext)
}

func (s *Parenthetical_filter_expression_opt_boolContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(ACIParserRPAREN)
}

func (s *Parenthetical_filter_expression_opt_boolContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, i)
}

func (s *Parenthetical_filter_expression_opt_boolContext) AllFILTER_AND() []antlr.TerminalNode {
	return s.GetTokens(ACIParserFILTER_AND)
}

func (s *Parenthetical_filter_expression_opt_boolContext) FILTER_AND(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserFILTER_AND, i)
}

func (s *Parenthetical_filter_expression_opt_boolContext) AllFILTER_OR() []antlr.TerminalNode {
	return s.GetTokens(ACIParserFILTER_OR)
}

func (s *Parenthetical_filter_expression_opt_boolContext) FILTER_OR(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserFILTER_OR, i)
}

func (s *Parenthetical_filter_expression_opt_boolContext) AllFILTER_NOT() []antlr.TerminalNode {
	return s.GetTokens(ACIParserFILTER_NOT)
}

func (s *Parenthetical_filter_expression_opt_boolContext) FILTER_NOT(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserFILTER_NOT, i)
}

func (s *Parenthetical_filter_expression_opt_boolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_filter_expression_opt_bool(s)
	}
}

func (s *Parenthetical_filter_expression_opt_boolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_filter_expression_opt_bool(s)
	}
}

func (p *ACIParser) LDAPFilterExpr() (localctx ILDAPFilterExprContext) {
	localctx = NewLDAPFilterExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, ACIParserRULE_lDAPFilterExpr)
	var _la int

	var _alt int

	p.SetState(990)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 89, p.GetParserRuleContext()) {
	case 1:
		localctx = NewParenthetical_filter_expression_opt_boolContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(983)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1 + 1
		for ok := true; ok; ok = _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1 + 1:
				{
					p.SetState(976)
					p.Match(ACIParserLPAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(978)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(977)
						_la = p.GetTokenStream().LA(1)

						if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&117440512) != 0) {
							p.GetErrorHandler().RecoverInline(p)
						} else {
							p.GetErrorHandler().ReportMatch(p)
							p.Consume()
						}
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}
				{
					p.SetState(980)
					p.LDAPFilterExpr()
				}
				{
					p.SetState(981)
					p.Match(ACIParserRPAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(985)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		localctx = NewNot_filter_expressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(987)
			p.Match(ACIParserFILTER_NOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(988)
			p.LDAPFilterExpr()
		}

	case 3:
		localctx = NewAva_expressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(989)
			p.AVAOrRDN()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAVAOrRDNContext is an interface to support dynamic dispatch.
type IAVAOrRDNContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAVAOrRDNContext differentiates from other interfaces.
	IsAVAOrRDNContext()
}

type AVAOrRDNContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAVAOrRDNContext() *AVAOrRDNContext {
	var p = new(AVAOrRDNContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_aVAOrRDN
	return p
}

func InitEmptyAVAOrRDNContext(p *AVAOrRDNContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_aVAOrRDN
}

func (*AVAOrRDNContext) IsAVAOrRDNContext() {}

func NewAVAOrRDNContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AVAOrRDNContext {
	var p = new(AVAOrRDNContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_aVAOrRDN

	return p
}

func (s *AVAOrRDNContext) GetParser() antlr.Parser { return s.parser }

func (s *AVAOrRDNContext) CopyAll(ctx *AVAOrRDNContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AVAOrRDNContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AVAOrRDNContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Parenthetical_ava_or_rdnContext struct {
	AVAOrRDNContext
}

func NewParenthetical_ava_or_rdnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Parenthetical_ava_or_rdnContext {
	var p = new(Parenthetical_ava_or_rdnContext)

	InitEmptyAVAOrRDNContext(&p.AVAOrRDNContext)
	p.parser = parser
	p.CopyAll(ctx.(*AVAOrRDNContext))

	return p
}

func (s *Parenthetical_ava_or_rdnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthetical_ava_or_rdnContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserLPAREN, 0)
}

func (s *Parenthetical_ava_or_rdnContext) AllAttributeTypeOrValue() []IAttributeTypeOrValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			len++
		}
	}

	tst := make([]IAttributeTypeOrValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeTypeOrValueContext); ok {
			tst[i] = t.(IAttributeTypeOrValueContext)
			i++
		}
	}

	return tst
}

func (s *Parenthetical_ava_or_rdnContext) AttributeTypeOrValue(i int) IAttributeTypeOrValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeTypeOrValueContext)
}

func (s *Parenthetical_ava_or_rdnContext) AttributeComparisonOperator() IAttributeComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeComparisonOperatorContext)
}

func (s *Parenthetical_ava_or_rdnContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ACIParserRPAREN, 0)
}

func (s *Parenthetical_ava_or_rdnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterParenthetical_ava_or_rdn(s)
	}
}

func (s *Parenthetical_ava_or_rdnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitParenthetical_ava_or_rdn(s)
	}
}

type Ava_or_rdnContext struct {
	AVAOrRDNContext
}

func NewAva_or_rdnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Ava_or_rdnContext {
	var p = new(Ava_or_rdnContext)

	InitEmptyAVAOrRDNContext(&p.AVAOrRDNContext)
	p.parser = parser
	p.CopyAll(ctx.(*AVAOrRDNContext))

	return p
}

func (s *Ava_or_rdnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ava_or_rdnContext) AllAttributeTypeOrValue() []IAttributeTypeOrValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			len++
		}
	}

	tst := make([]IAttributeTypeOrValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeTypeOrValueContext); ok {
			tst[i] = t.(IAttributeTypeOrValueContext)
			i++
		}
	}

	return tst
}

func (s *Ava_or_rdnContext) AttributeTypeOrValue(i int) IAttributeTypeOrValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeTypeOrValueContext)
}

func (s *Ava_or_rdnContext) AttributeComparisonOperator() IAttributeComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeComparisonOperatorContext)
}

func (s *Ava_or_rdnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAva_or_rdn(s)
	}
}

func (s *Ava_or_rdnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAva_or_rdn(s)
	}
}

func (p *ACIParser) AVAOrRDN() (localctx IAVAOrRDNContext) {
	localctx = NewAVAOrRDNContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, ACIParserRULE_aVAOrRDN)
	p.SetState(1002)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserLPAREN:
		localctx = NewParenthetical_ava_or_rdnContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(992)
			p.Match(ACIParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(993)
			p.AttributeTypeOrValue()
		}
		{
			p.SetState(994)
			p.AttributeComparisonOperator()
		}
		{
			p.SetState(995)
			p.AttributeTypeOrValue()
		}
		{
			p.SetState(996)
			p.Match(ACIParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserSTAR, ACIParserKEY_OR_VALUE:
		localctx = NewAva_or_rdnContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(998)
			p.AttributeTypeOrValue()
		}
		{
			p.SetState(999)
			p.AttributeComparisonOperator()
		}
		{
			p.SetState(1000)
			p.AttributeTypeOrValue()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInheritanceContext is an interface to support dynamic dispatch.
type IInheritanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsInheritanceContext differentiates from other interfaces.
	IsInheritanceContext()
}

type InheritanceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInheritanceContext() *InheritanceContext {
	var p = new(InheritanceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_inheritance
	return p
}

func InitEmptyInheritanceContext(p *InheritanceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_inheritance
}

func (*InheritanceContext) IsInheritanceContext() {}

func NewInheritanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InheritanceContext {
	var p = new(InheritanceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_inheritance

	return p
}

func (s *InheritanceContext) GetParser() antlr.Parser { return s.parser }

func (s *InheritanceContext) CopyAll(ctx *InheritanceContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *InheritanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InheritanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Inheritance_expressionContext struct {
	InheritanceContext
}

func NewInheritance_expressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Inheritance_expressionContext {
	var p = new(Inheritance_expressionContext)

	InitEmptyInheritanceContext(&p.InheritanceContext)
	p.parser = parser
	p.CopyAll(ctx.(*InheritanceContext))

	return p
}

func (s *Inheritance_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inheritance_expressionContext) PARENT() antlr.TerminalNode {
	return s.GetToken(ACIParserPARENT, 0)
}

func (s *Inheritance_expressionContext) InheritanceLevels() IInheritanceLevelsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInheritanceLevelsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInheritanceLevelsContext)
}

func (s *Inheritance_expressionContext) DOT() antlr.TerminalNode {
	return s.GetToken(ACIParserDOT, 0)
}

func (s *Inheritance_expressionContext) AttributeBindTypeOrValue() IAttributeBindTypeOrValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeBindTypeOrValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeBindTypeOrValueContext)
}

func (s *Inheritance_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterInheritance_expression(s)
	}
}

func (s *Inheritance_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitInheritance_expression(s)
	}
}

func (p *ACIParser) Inheritance() (localctx IInheritanceContext) {
	localctx = NewInheritanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, ACIParserRULE_inheritance)
	localctx = NewInheritance_expressionContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1004)
		p.Match(ACIParserPARENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1005)
		p.InheritanceLevels()
	}
	{
		p.SetState(1006)
		p.Match(ACIParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1007)
		p.AttributeBindTypeOrValue()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInheritanceLevelsContext is an interface to support dynamic dispatch.
type IInheritanceLevelsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsInheritanceLevelsContext differentiates from other interfaces.
	IsInheritanceLevelsContext()
}

type InheritanceLevelsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInheritanceLevelsContext() *InheritanceLevelsContext {
	var p = new(InheritanceLevelsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_inheritanceLevels
	return p
}

func InitEmptyInheritanceLevelsContext(p *InheritanceLevelsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_inheritanceLevels
}

func (*InheritanceLevelsContext) IsInheritanceLevelsContext() {}

func NewInheritanceLevelsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InheritanceLevelsContext {
	var p = new(InheritanceLevelsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_inheritanceLevels

	return p
}

func (s *InheritanceLevelsContext) GetParser() antlr.Parser { return s.parser }

func (s *InheritanceLevelsContext) CopyAll(ctx *InheritanceLevelsContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *InheritanceLevelsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InheritanceLevelsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Inheritance_levelsContext struct {
	InheritanceLevelsContext
}

func NewInheritance_levelsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Inheritance_levelsContext {
	var p = new(Inheritance_levelsContext)

	InitEmptyInheritanceLevelsContext(&p.InheritanceLevelsContext)
	p.parser = parser
	p.CopyAll(ctx.(*InheritanceLevelsContext))

	return p
}

func (s *Inheritance_levelsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inheritance_levelsContext) LBRAK() antlr.TerminalNode {
	return s.GetToken(ACIParserLBRAK, 0)
}

func (s *Inheritance_levelsContext) RBRAK() antlr.TerminalNode {
	return s.GetToken(ACIParserRBRAK, 0)
}

func (s *Inheritance_levelsContext) AllINT() []antlr.TerminalNode {
	return s.GetTokens(ACIParserINT)
}

func (s *Inheritance_levelsContext) INT(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserINT, i)
}

func (s *Inheritance_levelsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ACIParserCOMMA)
}

func (s *Inheritance_levelsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ACIParserCOMMA, i)
}

func (s *Inheritance_levelsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterInheritance_levels(s)
	}
}

func (s *Inheritance_levelsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitInheritance_levels(s)
	}
}

func (p *ACIParser) InheritanceLevels() (localctx IInheritanceLevelsContext) {
	localctx = NewInheritanceLevelsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, ACIParserRULE_inheritanceLevels)
	var _la int

	var _alt int

	localctx = NewInheritance_levelsContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1009)
		p.Match(ACIParserLBRAK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1018)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1 + 1
	for ok := true; ok; ok = _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1 + 1:
			{
				p.SetState(1010)
				p.Match(ACIParserINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1015)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == ACIParserCOMMA {
				{
					p.SetState(1011)
					p.Match(ACIParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1012)
					p.Match(ACIParserINT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1017)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1020)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 92, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1022)
		p.Match(ACIParserRBRAK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeBindTypeOrValueContext is an interface to support dynamic dispatch.
type IAttributeBindTypeOrValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAttributeBindTypeOrValueContext differentiates from other interfaces.
	IsAttributeBindTypeOrValueContext()
}

type AttributeBindTypeOrValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeBindTypeOrValueContext() *AttributeBindTypeOrValueContext {
	var p = new(AttributeBindTypeOrValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_attributeBindTypeOrValue
	return p
}

func InitEmptyAttributeBindTypeOrValueContext(p *AttributeBindTypeOrValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_attributeBindTypeOrValue
}

func (*AttributeBindTypeOrValueContext) IsAttributeBindTypeOrValueContext() {}

func NewAttributeBindTypeOrValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeBindTypeOrValueContext {
	var p = new(AttributeBindTypeOrValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_attributeBindTypeOrValue

	return p
}

func (s *AttributeBindTypeOrValueContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeBindTypeOrValueContext) CopyAll(ctx *AttributeBindTypeOrValueContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AttributeBindTypeOrValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeBindTypeOrValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Attr_bind_type_or_valueContext struct {
	AttributeBindTypeOrValueContext
}

func NewAttr_bind_type_or_valueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Attr_bind_type_or_valueContext {
	var p = new(Attr_bind_type_or_valueContext)

	InitEmptyAttributeBindTypeOrValueContext(&p.AttributeBindTypeOrValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeBindTypeOrValueContext))

	return p
}

func (s *Attr_bind_type_or_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_bind_type_or_valueContext) AllAttributeTypeOrValue() []IAttributeTypeOrValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			len++
		}
	}

	tst := make([]IAttributeTypeOrValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeTypeOrValueContext); ok {
			tst[i] = t.(IAttributeTypeOrValueContext)
			i++
		}
	}

	return tst
}

func (s *Attr_bind_type_or_valueContext) AttributeTypeOrValue(i int) IAttributeTypeOrValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeTypeOrValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeTypeOrValueContext)
}

func (s *Attr_bind_type_or_valueContext) HASH() antlr.TerminalNode {
	return s.GetToken(ACIParserHASH, 0)
}

func (s *Attr_bind_type_or_valueContext) BindTypes() IBindTypesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindTypesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindTypesContext)
}

func (s *Attr_bind_type_or_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterAttr_bind_type_or_value(s)
	}
}

func (s *Attr_bind_type_or_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitAttr_bind_type_or_value(s)
	}
}

func (p *ACIParser) AttributeBindTypeOrValue() (localctx IAttributeBindTypeOrValueContext) {
	localctx = NewAttributeBindTypeOrValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, ACIParserRULE_attributeBindTypeOrValue)
	localctx = NewAttr_bind_type_or_valueContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1024)
		p.AttributeTypeOrValue()
	}
	{
		p.SetState(1025)
		p.Match(ACIParserHASH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1028)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserBINDTYPE_USER_DN, ACIParserBINDTYPE_GROUP_DN, ACIParserBINDTYPE_ROLE_DN, ACIParserBINDTYPE_SELF_DN, ACIParserBINDTYPE_LDAP_URL:
		{
			p.SetState(1026)
			p.BindTypes()
		}

	case ACIParserSTAR, ACIParserKEY_OR_VALUE:
		{
			p.SetState(1027)
			p.AttributeTypeOrValue()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindTypesContext is an interface to support dynamic dispatch.
type IBindTypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBindTypesContext differentiates from other interfaces.
	IsBindTypesContext()
}

type BindTypesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindTypesContext() *BindTypesContext {
	var p = new(BindTypesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindTypes
	return p
}

func InitEmptyBindTypesContext(p *BindTypesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_bindTypes
}

func (*BindTypesContext) IsBindTypesContext() {}

func NewBindTypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindTypesContext {
	var p = new(BindTypesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_bindTypes

	return p
}

func (s *BindTypesContext) GetParser() antlr.Parser { return s.parser }

func (s *BindTypesContext) CopyAll(ctx *BindTypesContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BindTypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindTypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BtSELFDNContext struct {
	BindTypesContext
}

func NewBtSELFDNContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BtSELFDNContext {
	var p = new(BtSELFDNContext)

	InitEmptyBindTypesContext(&p.BindTypesContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindTypesContext))

	return p
}

func (s *BtSELFDNContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BtSELFDNContext) SelfDN() ISelfDNContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelfDNContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelfDNContext)
}

func (s *BtSELFDNContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterBtSELFDN(s)
	}
}

func (s *BtSELFDNContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitBtSELFDN(s)
	}
}

type BtLDAPURLContext struct {
	BindTypesContext
}

func NewBtLDAPURLContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BtLDAPURLContext {
	var p = new(BtLDAPURLContext)

	InitEmptyBindTypesContext(&p.BindTypesContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindTypesContext))

	return p
}

func (s *BtLDAPURLContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BtLDAPURLContext) LDAPURL() ILDAPURLContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILDAPURLContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILDAPURLContext)
}

func (s *BtLDAPURLContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterBtLDAPURL(s)
	}
}

func (s *BtLDAPURLContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitBtLDAPURL(s)
	}
}

type BtROLEDNContext struct {
	BindTypesContext
}

func NewBtROLEDNContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BtROLEDNContext {
	var p = new(BtROLEDNContext)

	InitEmptyBindTypesContext(&p.BindTypesContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindTypesContext))

	return p
}

func (s *BtROLEDNContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BtROLEDNContext) RoleDN() IRoleDNContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleDNContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleDNContext)
}

func (s *BtROLEDNContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterBtROLEDN(s)
	}
}

func (s *BtROLEDNContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitBtROLEDN(s)
	}
}

type BtUSERDNContext struct {
	BindTypesContext
}

func NewBtUSERDNContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BtUSERDNContext {
	var p = new(BtUSERDNContext)

	InitEmptyBindTypesContext(&p.BindTypesContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindTypesContext))

	return p
}

func (s *BtUSERDNContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BtUSERDNContext) UserDN() IUserDNContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserDNContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserDNContext)
}

func (s *BtUSERDNContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterBtUSERDN(s)
	}
}

func (s *BtUSERDNContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitBtUSERDN(s)
	}
}

type BtGROUPDNContext struct {
	BindTypesContext
}

func NewBtGROUPDNContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BtGROUPDNContext {
	var p = new(BtGROUPDNContext)

	InitEmptyBindTypesContext(&p.BindTypesContext)
	p.parser = parser
	p.CopyAll(ctx.(*BindTypesContext))

	return p
}

func (s *BtGROUPDNContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BtGROUPDNContext) GroupDN() IGroupDNContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupDNContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupDNContext)
}

func (s *BtGROUPDNContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterBtGROUPDN(s)
	}
}

func (s *BtGROUPDNContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitBtGROUPDN(s)
	}
}

func (p *ACIParser) BindTypes() (localctx IBindTypesContext) {
	localctx = NewBindTypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, ACIParserRULE_bindTypes)
	p.SetState(1035)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserBINDTYPE_USER_DN:
		localctx = NewBtUSERDNContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1030)
			p.UserDN()
		}

	case ACIParserBINDTYPE_GROUP_DN:
		localctx = NewBtGROUPDNContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1031)
			p.GroupDN()
		}

	case ACIParserBINDTYPE_ROLE_DN:
		localctx = NewBtROLEDNContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1032)
			p.RoleDN()
		}

	case ACIParserBINDTYPE_SELF_DN:
		localctx = NewBtSELFDNContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1033)
			p.SelfDN()
		}

	case ACIParserBINDTYPE_LDAP_URL:
		localctx = NewBtLDAPURLContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1034)
			p.LDAPURL()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserDNContext is an interface to support dynamic dispatch.
type IUserDNContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BINDTYPE_USER_DN() antlr.TerminalNode

	// IsUserDNContext differentiates from other interfaces.
	IsUserDNContext()
}

type UserDNContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserDNContext() *UserDNContext {
	var p = new(UserDNContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_userDN
	return p
}

func InitEmptyUserDNContext(p *UserDNContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_userDN
}

func (*UserDNContext) IsUserDNContext() {}

func NewUserDNContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserDNContext {
	var p = new(UserDNContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_userDN

	return p
}

func (s *UserDNContext) GetParser() antlr.Parser { return s.parser }

func (s *UserDNContext) BINDTYPE_USER_DN() antlr.TerminalNode {
	return s.GetToken(ACIParserBINDTYPE_USER_DN, 0)
}

func (s *UserDNContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserDNContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserDNContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterUserDN(s)
	}
}

func (s *UserDNContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitUserDN(s)
	}
}

func (p *ACIParser) UserDN() (localctx IUserDNContext) {
	localctx = NewUserDNContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, ACIParserRULE_userDN)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1037)
		p.Match(ACIParserBINDTYPE_USER_DN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleDNContext is an interface to support dynamic dispatch.
type IRoleDNContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BINDTYPE_ROLE_DN() antlr.TerminalNode

	// IsRoleDNContext differentiates from other interfaces.
	IsRoleDNContext()
}

type RoleDNContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleDNContext() *RoleDNContext {
	var p = new(RoleDNContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_roleDN
	return p
}

func InitEmptyRoleDNContext(p *RoleDNContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_roleDN
}

func (*RoleDNContext) IsRoleDNContext() {}

func NewRoleDNContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleDNContext {
	var p = new(RoleDNContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_roleDN

	return p
}

func (s *RoleDNContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleDNContext) BINDTYPE_ROLE_DN() antlr.TerminalNode {
	return s.GetToken(ACIParserBINDTYPE_ROLE_DN, 0)
}

func (s *RoleDNContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleDNContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleDNContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterRoleDN(s)
	}
}

func (s *RoleDNContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitRoleDN(s)
	}
}

func (p *ACIParser) RoleDN() (localctx IRoleDNContext) {
	localctx = NewRoleDNContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, ACIParserRULE_roleDN)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1039)
		p.Match(ACIParserBINDTYPE_ROLE_DN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelfDNContext is an interface to support dynamic dispatch.
type ISelfDNContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BINDTYPE_SELF_DN() antlr.TerminalNode

	// IsSelfDNContext differentiates from other interfaces.
	IsSelfDNContext()
}

type SelfDNContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelfDNContext() *SelfDNContext {
	var p = new(SelfDNContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_selfDN
	return p
}

func InitEmptySelfDNContext(p *SelfDNContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_selfDN
}

func (*SelfDNContext) IsSelfDNContext() {}

func NewSelfDNContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelfDNContext {
	var p = new(SelfDNContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_selfDN

	return p
}

func (s *SelfDNContext) GetParser() antlr.Parser { return s.parser }

func (s *SelfDNContext) BINDTYPE_SELF_DN() antlr.TerminalNode {
	return s.GetToken(ACIParserBINDTYPE_SELF_DN, 0)
}

func (s *SelfDNContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelfDNContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelfDNContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterSelfDN(s)
	}
}

func (s *SelfDNContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitSelfDN(s)
	}
}

func (p *ACIParser) SelfDN() (localctx ISelfDNContext) {
	localctx = NewSelfDNContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, ACIParserRULE_selfDN)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1041)
		p.Match(ACIParserBINDTYPE_SELF_DN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupDNContext is an interface to support dynamic dispatch.
type IGroupDNContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BINDTYPE_GROUP_DN() antlr.TerminalNode

	// IsGroupDNContext differentiates from other interfaces.
	IsGroupDNContext()
}

type GroupDNContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupDNContext() *GroupDNContext {
	var p = new(GroupDNContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_groupDN
	return p
}

func InitEmptyGroupDNContext(p *GroupDNContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_groupDN
}

func (*GroupDNContext) IsGroupDNContext() {}

func NewGroupDNContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupDNContext {
	var p = new(GroupDNContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_groupDN

	return p
}

func (s *GroupDNContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupDNContext) BINDTYPE_GROUP_DN() antlr.TerminalNode {
	return s.GetToken(ACIParserBINDTYPE_GROUP_DN, 0)
}

func (s *GroupDNContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupDNContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupDNContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterGroupDN(s)
	}
}

func (s *GroupDNContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitGroupDN(s)
	}
}

func (p *ACIParser) GroupDN() (localctx IGroupDNContext) {
	localctx = NewGroupDNContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, ACIParserRULE_groupDN)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1043)
		p.Match(ACIParserBINDTYPE_GROUP_DN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILDAPURLContext is an interface to support dynamic dispatch.
type ILDAPURLContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BINDTYPE_LDAP_URL() antlr.TerminalNode

	// IsLDAPURLContext differentiates from other interfaces.
	IsLDAPURLContext()
}

type LDAPURLContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLDAPURLContext() *LDAPURLContext {
	var p = new(LDAPURLContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_lDAPURL
	return p
}

func InitEmptyLDAPURLContext(p *LDAPURLContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_lDAPURL
}

func (*LDAPURLContext) IsLDAPURLContext() {}

func NewLDAPURLContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LDAPURLContext {
	var p = new(LDAPURLContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_lDAPURL

	return p
}

func (s *LDAPURLContext) GetParser() antlr.Parser { return s.parser }

func (s *LDAPURLContext) BINDTYPE_LDAP_URL() antlr.TerminalNode {
	return s.GetToken(ACIParserBINDTYPE_LDAP_URL, 0)
}

func (s *LDAPURLContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LDAPURLContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LDAPURLContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterLDAPURL(s)
	}
}

func (s *LDAPURLContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitLDAPURL(s)
	}
}

func (p *ACIParser) LDAPURL() (localctx ILDAPURLContext) {
	localctx = NewLDAPURLContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, ACIParserRULE_lDAPURL)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1045)
		p.Match(ACIParserBINDTYPE_LDAP_URL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeTypeOrValueContext is an interface to support dynamic dispatch.
type IAttributeTypeOrValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAttributeTypeOrValueContext differentiates from other interfaces.
	IsAttributeTypeOrValueContext()
}

type AttributeTypeOrValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeTypeOrValueContext() *AttributeTypeOrValueContext {
	var p = new(AttributeTypeOrValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_attributeTypeOrValue
	return p
}

func InitEmptyAttributeTypeOrValueContext(p *AttributeTypeOrValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_attributeTypeOrValue
}

func (*AttributeTypeOrValueContext) IsAttributeTypeOrValueContext() {}

func NewAttributeTypeOrValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeTypeOrValueContext {
	var p = new(AttributeTypeOrValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_attributeTypeOrValue

	return p
}

func (s *AttributeTypeOrValueContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeTypeOrValueContext) CopyAll(ctx *AttributeTypeOrValueContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AttributeTypeOrValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeTypeOrValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Presence_key_or_valueContext struct {
	AttributeTypeOrValueContext
}

func NewPresence_key_or_valueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Presence_key_or_valueContext {
	var p = new(Presence_key_or_valueContext)

	InitEmptyAttributeTypeOrValueContext(&p.AttributeTypeOrValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeTypeOrValueContext))

	return p
}

func (s *Presence_key_or_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Presence_key_or_valueContext) STAR() antlr.TerminalNode {
	return s.GetToken(ACIParserSTAR, 0)
}

func (s *Presence_key_or_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterPresence_key_or_value(s)
	}
}

func (s *Presence_key_or_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitPresence_key_or_value(s)
	}
}

type Key_or_valueContext struct {
	AttributeTypeOrValueContext
}

func NewKey_or_valueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Key_or_valueContext {
	var p = new(Key_or_valueContext)

	InitEmptyAttributeTypeOrValueContext(&p.AttributeTypeOrValueContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeTypeOrValueContext))

	return p
}

func (s *Key_or_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Key_or_valueContext) KEY_OR_VALUE() antlr.TerminalNode {
	return s.GetToken(ACIParserKEY_OR_VALUE, 0)
}

func (s *Key_or_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterKey_or_value(s)
	}
}

func (s *Key_or_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitKey_or_value(s)
	}
}

func (p *ACIParser) AttributeTypeOrValue() (localctx IAttributeTypeOrValueContext) {
	localctx = NewAttributeTypeOrValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, ACIParserRULE_attributeTypeOrValue)
	p.SetState(1049)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserKEY_OR_VALUE:
		localctx = NewKey_or_valueContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1047)
			p.Match(ACIParserKEY_OR_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ACIParserSTAR:
		localctx = NewPresence_key_or_valueContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1048)
			p.Match(ACIParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeComparisonOperatorContext is an interface to support dynamic dispatch.
type IAttributeComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAttributeComparisonOperatorContext differentiates from other interfaces.
	IsAttributeComparisonOperatorContext()
}

type AttributeComparisonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeComparisonOperatorContext() *AttributeComparisonOperatorContext {
	var p = new(AttributeComparisonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_attributeComparisonOperator
	return p
}

func InitEmptyAttributeComparisonOperatorContext(p *AttributeComparisonOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_attributeComparisonOperator
}

func (*AttributeComparisonOperatorContext) IsAttributeComparisonOperatorContext() {}

func NewAttributeComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeComparisonOperatorContext {
	var p = new(AttributeComparisonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_attributeComparisonOperator

	return p
}

func (s *AttributeComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeComparisonOperatorContext) CopyAll(ctx *AttributeComparisonOperatorContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AttributeComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Equal_toContext struct {
	AttributeComparisonOperatorContext
}

func NewEqual_toContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Equal_toContext {
	var p = new(Equal_toContext)

	InitEmptyAttributeComparisonOperatorContext(&p.AttributeComparisonOperatorContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeComparisonOperatorContext))

	return p
}

func (s *Equal_toContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Equal_toContext) EqualTo() IEqualToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualToContext)
}

func (s *Equal_toContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterEqual_to(s)
	}
}

func (s *Equal_toContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitEqual_to(s)
	}
}

type Greater_than_or_equalContext struct {
	AttributeComparisonOperatorContext
}

func NewGreater_than_or_equalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Greater_than_or_equalContext {
	var p = new(Greater_than_or_equalContext)

	InitEmptyAttributeComparisonOperatorContext(&p.AttributeComparisonOperatorContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeComparisonOperatorContext))

	return p
}

func (s *Greater_than_or_equalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Greater_than_or_equalContext) GreaterThanOrEqual() IGreaterThanOrEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGreaterThanOrEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGreaterThanOrEqualContext)
}

func (s *Greater_than_or_equalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterGreater_than_or_equal(s)
	}
}

func (s *Greater_than_or_equalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitGreater_than_or_equal(s)
	}
}

type Extensible_rule_with_dn_oidContext struct {
	AttributeComparisonOperatorContext
}

func NewExtensible_rule_with_dn_oidContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Extensible_rule_with_dn_oidContext {
	var p = new(Extensible_rule_with_dn_oidContext)

	InitEmptyAttributeComparisonOperatorContext(&p.AttributeComparisonOperatorContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeComparisonOperatorContext))

	return p
}

func (s *Extensible_rule_with_dn_oidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Extensible_rule_with_dn_oidContext) ExtensibleRuleDNOID() IExtensibleRuleDNOIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtensibleRuleDNOIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtensibleRuleDNOIDContext)
}

func (s *Extensible_rule_with_dn_oidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterExtensible_rule_with_dn_oid(s)
	}
}

func (s *Extensible_rule_with_dn_oidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitExtensible_rule_with_dn_oid(s)
	}
}

type Less_than_or_equalContext struct {
	AttributeComparisonOperatorContext
}

func NewLess_than_or_equalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Less_than_or_equalContext {
	var p = new(Less_than_or_equalContext)

	InitEmptyAttributeComparisonOperatorContext(&p.AttributeComparisonOperatorContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeComparisonOperatorContext))

	return p
}

func (s *Less_than_or_equalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Less_than_or_equalContext) LessThanOrEqual() ILessThanOrEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILessThanOrEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILessThanOrEqualContext)
}

func (s *Less_than_or_equalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterLess_than_or_equal(s)
	}
}

func (s *Less_than_or_equalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitLess_than_or_equal(s)
	}
}

type Extensible_rule_with_attrsContext struct {
	AttributeComparisonOperatorContext
}

func NewExtensible_rule_with_attrsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Extensible_rule_with_attrsContext {
	var p = new(Extensible_rule_with_attrsContext)

	InitEmptyAttributeComparisonOperatorContext(&p.AttributeComparisonOperatorContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeComparisonOperatorContext))

	return p
}

func (s *Extensible_rule_with_attrsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Extensible_rule_with_attrsContext) ExtensibleRuleAttr() IExtensibleRuleAttrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtensibleRuleAttrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtensibleRuleAttrContext)
}

func (s *Extensible_rule_with_attrsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterExtensible_rule_with_attrs(s)
	}
}

func (s *Extensible_rule_with_attrsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitExtensible_rule_with_attrs(s)
	}
}

type Extensible_rule_with_dnContext struct {
	AttributeComparisonOperatorContext
}

func NewExtensible_rule_with_dnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Extensible_rule_with_dnContext {
	var p = new(Extensible_rule_with_dnContext)

	InitEmptyAttributeComparisonOperatorContext(&p.AttributeComparisonOperatorContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeComparisonOperatorContext))

	return p
}

func (s *Extensible_rule_with_dnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Extensible_rule_with_dnContext) ExtensibleRuleDN() IExtensibleRuleDNContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtensibleRuleDNContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtensibleRuleDNContext)
}

func (s *Extensible_rule_with_dnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterExtensible_rule_with_dn(s)
	}
}

func (s *Extensible_rule_with_dnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitExtensible_rule_with_dn(s)
	}
}

type Extensible_ruleContext struct {
	AttributeComparisonOperatorContext
}

func NewExtensible_ruleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Extensible_ruleContext {
	var p = new(Extensible_ruleContext)

	InitEmptyAttributeComparisonOperatorContext(&p.AttributeComparisonOperatorContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeComparisonOperatorContext))

	return p
}

func (s *Extensible_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Extensible_ruleContext) ExtensibleRule() IExtensibleRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtensibleRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtensibleRuleContext)
}

func (s *Extensible_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterExtensible_rule(s)
	}
}

func (s *Extensible_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitExtensible_rule(s)
	}
}

type ApproxContext struct {
	AttributeComparisonOperatorContext
}

func NewApproxContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ApproxContext {
	var p = new(ApproxContext)

	InitEmptyAttributeComparisonOperatorContext(&p.AttributeComparisonOperatorContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttributeComparisonOperatorContext))

	return p
}

func (s *ApproxContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ApproxContext) Approximate() IApproximateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IApproximateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IApproximateContext)
}

func (s *ApproxContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterApprox(s)
	}
}

func (s *ApproxContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitApprox(s)
	}
}

func (p *ACIParser) AttributeComparisonOperator() (localctx IAttributeComparisonOperatorContext) {
	localctx = NewAttributeComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, ACIParserRULE_attributeComparisonOperator)
	p.SetState(1059)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ACIParserEQ:
		localctx = NewEqual_toContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1051)
			p.EqualTo()
		}

	case ACIParserGE:
		localctx = NewGreater_than_or_equalContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1052)
			p.GreaterThanOrEqual()
		}

	case ACIParserLE:
		localctx = NewLess_than_or_equalContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1053)
			p.LessThanOrEqual()
		}

	case ACIParserAPX:
		localctx = NewApproxContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1054)
			p.Approximate()
		}

	case ACIParserCOLON:
		localctx = NewExtensible_ruleContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1055)
			p.ExtensibleRule()
		}

	case ACIParserEXD:
		localctx = NewExtensible_rule_with_dnContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1056)
			p.ExtensibleRuleDN()
		}

	case ACIParserEXA:
		localctx = NewExtensible_rule_with_attrsContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1057)
			p.ExtensibleRuleAttr()
		}

	case ACIParserEXO:
		localctx = NewExtensible_rule_with_dn_oidContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1058)
			p.ExtensibleRuleDNOID()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEqualToContext is an interface to support dynamic dispatch.
type IEqualToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQ() antlr.TerminalNode

	// IsEqualToContext differentiates from other interfaces.
	IsEqualToContext()
}

type EqualToContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEqualToContext() *EqualToContext {
	var p = new(EqualToContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_equalTo
	return p
}

func InitEmptyEqualToContext(p *EqualToContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_equalTo
}

func (*EqualToContext) IsEqualToContext() {}

func NewEqualToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqualToContext {
	var p = new(EqualToContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_equalTo

	return p
}

func (s *EqualToContext) GetParser() antlr.Parser { return s.parser }

func (s *EqualToContext) EQ() antlr.TerminalNode {
	return s.GetToken(ACIParserEQ, 0)
}

func (s *EqualToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqualToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterEqualTo(s)
	}
}

func (s *EqualToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitEqualTo(s)
	}
}

func (p *ACIParser) EqualTo() (localctx IEqualToContext) {
	localctx = NewEqualToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, ACIParserRULE_equalTo)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1061)
		p.Match(ACIParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INotEqualToContext is an interface to support dynamic dispatch.
type INotEqualToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NE() antlr.TerminalNode

	// IsNotEqualToContext differentiates from other interfaces.
	IsNotEqualToContext()
}

type NotEqualToContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotEqualToContext() *NotEqualToContext {
	var p = new(NotEqualToContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_notEqualTo
	return p
}

func InitEmptyNotEqualToContext(p *NotEqualToContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_notEqualTo
}

func (*NotEqualToContext) IsNotEqualToContext() {}

func NewNotEqualToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotEqualToContext {
	var p = new(NotEqualToContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_notEqualTo

	return p
}

func (s *NotEqualToContext) GetParser() antlr.Parser { return s.parser }

func (s *NotEqualToContext) NE() antlr.TerminalNode {
	return s.GetToken(ACIParserNE, 0)
}

func (s *NotEqualToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotEqualToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotEqualToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterNotEqualTo(s)
	}
}

func (s *NotEqualToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitNotEqualTo(s)
	}
}

func (p *ACIParser) NotEqualTo() (localctx INotEqualToContext) {
	localctx = NewNotEqualToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, ACIParserRULE_notEqualTo)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1063)
		p.Match(ACIParserNE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGreaterThanContext is an interface to support dynamic dispatch.
type IGreaterThanContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GT() antlr.TerminalNode

	// IsGreaterThanContext differentiates from other interfaces.
	IsGreaterThanContext()
}

type GreaterThanContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGreaterThanContext() *GreaterThanContext {
	var p = new(GreaterThanContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_greaterThan
	return p
}

func InitEmptyGreaterThanContext(p *GreaterThanContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_greaterThan
}

func (*GreaterThanContext) IsGreaterThanContext() {}

func NewGreaterThanContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GreaterThanContext {
	var p = new(GreaterThanContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_greaterThan

	return p
}

func (s *GreaterThanContext) GetParser() antlr.Parser { return s.parser }

func (s *GreaterThanContext) GT() antlr.TerminalNode {
	return s.GetToken(ACIParserGT, 0)
}

func (s *GreaterThanContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GreaterThanContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GreaterThanContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterGreaterThan(s)
	}
}

func (s *GreaterThanContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitGreaterThan(s)
	}
}

func (p *ACIParser) GreaterThan() (localctx IGreaterThanContext) {
	localctx = NewGreaterThanContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, ACIParserRULE_greaterThan)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1065)
		p.Match(ACIParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILessThanContext is an interface to support dynamic dispatch.
type ILessThanContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode

	// IsLessThanContext differentiates from other interfaces.
	IsLessThanContext()
}

type LessThanContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLessThanContext() *LessThanContext {
	var p = new(LessThanContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_lessThan
	return p
}

func InitEmptyLessThanContext(p *LessThanContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_lessThan
}

func (*LessThanContext) IsLessThanContext() {}

func NewLessThanContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LessThanContext {
	var p = new(LessThanContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_lessThan

	return p
}

func (s *LessThanContext) GetParser() antlr.Parser { return s.parser }

func (s *LessThanContext) LT() antlr.TerminalNode {
	return s.GetToken(ACIParserLT, 0)
}

func (s *LessThanContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LessThanContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LessThanContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterLessThan(s)
	}
}

func (s *LessThanContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitLessThan(s)
	}
}

func (p *ACIParser) LessThan() (localctx ILessThanContext) {
	localctx = NewLessThanContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, ACIParserRULE_lessThan)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1067)
		p.Match(ACIParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGreaterThanOrEqualContext is an interface to support dynamic dispatch.
type IGreaterThanOrEqualContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GE() antlr.TerminalNode

	// IsGreaterThanOrEqualContext differentiates from other interfaces.
	IsGreaterThanOrEqualContext()
}

type GreaterThanOrEqualContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGreaterThanOrEqualContext() *GreaterThanOrEqualContext {
	var p = new(GreaterThanOrEqualContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_greaterThanOrEqual
	return p
}

func InitEmptyGreaterThanOrEqualContext(p *GreaterThanOrEqualContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_greaterThanOrEqual
}

func (*GreaterThanOrEqualContext) IsGreaterThanOrEqualContext() {}

func NewGreaterThanOrEqualContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GreaterThanOrEqualContext {
	var p = new(GreaterThanOrEqualContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_greaterThanOrEqual

	return p
}

func (s *GreaterThanOrEqualContext) GetParser() antlr.Parser { return s.parser }

func (s *GreaterThanOrEqualContext) GE() antlr.TerminalNode {
	return s.GetToken(ACIParserGE, 0)
}

func (s *GreaterThanOrEqualContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GreaterThanOrEqualContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GreaterThanOrEqualContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterGreaterThanOrEqual(s)
	}
}

func (s *GreaterThanOrEqualContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitGreaterThanOrEqual(s)
	}
}

func (p *ACIParser) GreaterThanOrEqual() (localctx IGreaterThanOrEqualContext) {
	localctx = NewGreaterThanOrEqualContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, ACIParserRULE_greaterThanOrEqual)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1069)
		p.Match(ACIParserGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILessThanOrEqualContext is an interface to support dynamic dispatch.
type ILessThanOrEqualContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LE() antlr.TerminalNode

	// IsLessThanOrEqualContext differentiates from other interfaces.
	IsLessThanOrEqualContext()
}

type LessThanOrEqualContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLessThanOrEqualContext() *LessThanOrEqualContext {
	var p = new(LessThanOrEqualContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_lessThanOrEqual
	return p
}

func InitEmptyLessThanOrEqualContext(p *LessThanOrEqualContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_lessThanOrEqual
}

func (*LessThanOrEqualContext) IsLessThanOrEqualContext() {}

func NewLessThanOrEqualContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LessThanOrEqualContext {
	var p = new(LessThanOrEqualContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_lessThanOrEqual

	return p
}

func (s *LessThanOrEqualContext) GetParser() antlr.Parser { return s.parser }

func (s *LessThanOrEqualContext) LE() antlr.TerminalNode {
	return s.GetToken(ACIParserLE, 0)
}

func (s *LessThanOrEqualContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LessThanOrEqualContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LessThanOrEqualContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterLessThanOrEqual(s)
	}
}

func (s *LessThanOrEqualContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitLessThanOrEqual(s)
	}
}

func (p *ACIParser) LessThanOrEqual() (localctx ILessThanOrEqualContext) {
	localctx = NewLessThanOrEqualContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, ACIParserRULE_lessThanOrEqual)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1071)
		p.Match(ACIParserLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IApproximateContext is an interface to support dynamic dispatch.
type IApproximateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	APX() antlr.TerminalNode

	// IsApproximateContext differentiates from other interfaces.
	IsApproximateContext()
}

type ApproximateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyApproximateContext() *ApproximateContext {
	var p = new(ApproximateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_approximate
	return p
}

func InitEmptyApproximateContext(p *ApproximateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_approximate
}

func (*ApproximateContext) IsApproximateContext() {}

func NewApproximateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ApproximateContext {
	var p = new(ApproximateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_approximate

	return p
}

func (s *ApproximateContext) GetParser() antlr.Parser { return s.parser }

func (s *ApproximateContext) APX() antlr.TerminalNode {
	return s.GetToken(ACIParserAPX, 0)
}

func (s *ApproximateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ApproximateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ApproximateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterApproximate(s)
	}
}

func (s *ApproximateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitApproximate(s)
	}
}

func (p *ACIParser) Approximate() (localctx IApproximateContext) {
	localctx = NewApproximateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, ACIParserRULE_approximate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1073)
		p.Match(ACIParserAPX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExtensibleRuleContext is an interface to support dynamic dispatch.
type IExtensibleRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLON() antlr.TerminalNode

	// IsExtensibleRuleContext differentiates from other interfaces.
	IsExtensibleRuleContext()
}

type ExtensibleRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensibleRuleContext() *ExtensibleRuleContext {
	var p = new(ExtensibleRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_extensibleRule
	return p
}

func InitEmptyExtensibleRuleContext(p *ExtensibleRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_extensibleRule
}

func (*ExtensibleRuleContext) IsExtensibleRuleContext() {}

func NewExtensibleRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensibleRuleContext {
	var p = new(ExtensibleRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_extensibleRule

	return p
}

func (s *ExtensibleRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensibleRuleContext) COLON() antlr.TerminalNode {
	return s.GetToken(ACIParserCOLON, 0)
}

func (s *ExtensibleRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensibleRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensibleRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterExtensibleRule(s)
	}
}

func (s *ExtensibleRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitExtensibleRule(s)
	}
}

func (p *ACIParser) ExtensibleRule() (localctx IExtensibleRuleContext) {
	localctx = NewExtensibleRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, ACIParserRULE_extensibleRule)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1075)
		p.Match(ACIParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExtensibleRuleDNOIDContext is an interface to support dynamic dispatch.
type IExtensibleRuleDNOIDContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXO() antlr.TerminalNode

	// IsExtensibleRuleDNOIDContext differentiates from other interfaces.
	IsExtensibleRuleDNOIDContext()
}

type ExtensibleRuleDNOIDContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensibleRuleDNOIDContext() *ExtensibleRuleDNOIDContext {
	var p = new(ExtensibleRuleDNOIDContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_extensibleRuleDNOID
	return p
}

func InitEmptyExtensibleRuleDNOIDContext(p *ExtensibleRuleDNOIDContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_extensibleRuleDNOID
}

func (*ExtensibleRuleDNOIDContext) IsExtensibleRuleDNOIDContext() {}

func NewExtensibleRuleDNOIDContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensibleRuleDNOIDContext {
	var p = new(ExtensibleRuleDNOIDContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_extensibleRuleDNOID

	return p
}

func (s *ExtensibleRuleDNOIDContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensibleRuleDNOIDContext) EXO() antlr.TerminalNode {
	return s.GetToken(ACIParserEXO, 0)
}

func (s *ExtensibleRuleDNOIDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensibleRuleDNOIDContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensibleRuleDNOIDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterExtensibleRuleDNOID(s)
	}
}

func (s *ExtensibleRuleDNOIDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitExtensibleRuleDNOID(s)
	}
}

func (p *ACIParser) ExtensibleRuleDNOID() (localctx IExtensibleRuleDNOIDContext) {
	localctx = NewExtensibleRuleDNOIDContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, ACIParserRULE_extensibleRuleDNOID)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1077)
		p.Match(ACIParserEXO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExtensibleRuleDNContext is an interface to support dynamic dispatch.
type IExtensibleRuleDNContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXD() antlr.TerminalNode

	// IsExtensibleRuleDNContext differentiates from other interfaces.
	IsExtensibleRuleDNContext()
}

type ExtensibleRuleDNContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensibleRuleDNContext() *ExtensibleRuleDNContext {
	var p = new(ExtensibleRuleDNContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_extensibleRuleDN
	return p
}

func InitEmptyExtensibleRuleDNContext(p *ExtensibleRuleDNContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_extensibleRuleDN
}

func (*ExtensibleRuleDNContext) IsExtensibleRuleDNContext() {}

func NewExtensibleRuleDNContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensibleRuleDNContext {
	var p = new(ExtensibleRuleDNContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_extensibleRuleDN

	return p
}

func (s *ExtensibleRuleDNContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensibleRuleDNContext) EXD() antlr.TerminalNode {
	return s.GetToken(ACIParserEXD, 0)
}

func (s *ExtensibleRuleDNContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensibleRuleDNContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensibleRuleDNContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterExtensibleRuleDN(s)
	}
}

func (s *ExtensibleRuleDNContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitExtensibleRuleDN(s)
	}
}

func (p *ACIParser) ExtensibleRuleDN() (localctx IExtensibleRuleDNContext) {
	localctx = NewExtensibleRuleDNContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, ACIParserRULE_extensibleRuleDN)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1079)
		p.Match(ACIParserEXD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExtensibleRuleAttrContext is an interface to support dynamic dispatch.
type IExtensibleRuleAttrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXA() antlr.TerminalNode

	// IsExtensibleRuleAttrContext differentiates from other interfaces.
	IsExtensibleRuleAttrContext()
}

type ExtensibleRuleAttrContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensibleRuleAttrContext() *ExtensibleRuleAttrContext {
	var p = new(ExtensibleRuleAttrContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_extensibleRuleAttr
	return p
}

func InitEmptyExtensibleRuleAttrContext(p *ExtensibleRuleAttrContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_extensibleRuleAttr
}

func (*ExtensibleRuleAttrContext) IsExtensibleRuleAttrContext() {}

func NewExtensibleRuleAttrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensibleRuleAttrContext {
	var p = new(ExtensibleRuleAttrContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_extensibleRuleAttr

	return p
}

func (s *ExtensibleRuleAttrContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensibleRuleAttrContext) EXA() antlr.TerminalNode {
	return s.GetToken(ACIParserEXA, 0)
}

func (s *ExtensibleRuleAttrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensibleRuleAttrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensibleRuleAttrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterExtensibleRuleAttr(s)
	}
}

func (s *ExtensibleRuleAttrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitExtensibleRuleAttr(s)
	}
}

func (p *ACIParser) ExtensibleRuleAttr() (localctx IExtensibleRuleAttrContext) {
	localctx = NewExtensibleRuleAttrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, ACIParserRULE_extensibleRuleAttr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1081)
		p.Match(ACIParserEXA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IORDelimiterContext is an interface to support dynamic dispatch.
type IORDelimiterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SYMBOLIC_OR() antlr.TerminalNode

	// IsORDelimiterContext differentiates from other interfaces.
	IsORDelimiterContext()
}

type ORDelimiterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyORDelimiterContext() *ORDelimiterContext {
	var p = new(ORDelimiterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_oRDelimiter
	return p
}

func InitEmptyORDelimiterContext(p *ORDelimiterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_oRDelimiter
}

func (*ORDelimiterContext) IsORDelimiterContext() {}

func NewORDelimiterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ORDelimiterContext {
	var p = new(ORDelimiterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_oRDelimiter

	return p
}

func (s *ORDelimiterContext) GetParser() antlr.Parser { return s.parser }

func (s *ORDelimiterContext) SYMBOLIC_OR() antlr.TerminalNode {
	return s.GetToken(ACIParserSYMBOLIC_OR, 0)
}

func (s *ORDelimiterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ORDelimiterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ORDelimiterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterORDelimiter(s)
	}
}

func (s *ORDelimiterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitORDelimiter(s)
	}
}

func (p *ACIParser) ORDelimiter() (localctx IORDelimiterContext) {
	localctx = NewORDelimiterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, ACIParserRULE_oRDelimiter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1083)
		p.Match(ACIParserSYMBOLIC_OR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IANDDelimiterContext is an interface to support dynamic dispatch.
type IANDDelimiterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SYMBOLIC_AND() antlr.TerminalNode

	// IsANDDelimiterContext differentiates from other interfaces.
	IsANDDelimiterContext()
}

type ANDDelimiterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyANDDelimiterContext() *ANDDelimiterContext {
	var p = new(ANDDelimiterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_aNDDelimiter
	return p
}

func InitEmptyANDDelimiterContext(p *ANDDelimiterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ACIParserRULE_aNDDelimiter
}

func (*ANDDelimiterContext) IsANDDelimiterContext() {}

func NewANDDelimiterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ANDDelimiterContext {
	var p = new(ANDDelimiterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ACIParserRULE_aNDDelimiter

	return p
}

func (s *ANDDelimiterContext) GetParser() antlr.Parser { return s.parser }

func (s *ANDDelimiterContext) SYMBOLIC_AND() antlr.TerminalNode {
	return s.GetToken(ACIParserSYMBOLIC_AND, 0)
}

func (s *ANDDelimiterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ANDDelimiterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ANDDelimiterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.EnterANDDelimiter(s)
	}
}

func (s *ANDDelimiterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ACIParserListener); ok {
		listenerT.ExitANDDelimiter(s)
	}
}

func (p *ACIParser) ANDDelimiter() (localctx IANDDelimiterContext) {
	localctx = NewANDDelimiterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, ACIParserRULE_aNDDelimiter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1085)
		p.Match(ACIParserSYMBOLIC_AND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}
